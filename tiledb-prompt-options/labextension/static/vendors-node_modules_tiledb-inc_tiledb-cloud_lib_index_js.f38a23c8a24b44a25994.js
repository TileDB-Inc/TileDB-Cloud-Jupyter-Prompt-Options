(self["webpackChunk_tiledb_inc_tiledb_prompt_options"] = self["webpackChunk_tiledb_inc_tiledb_prompt_options"] || []).push([["vendors-node_modules_tiledb-inc_tiledb-cloud_lib_index_js"],{

/***/ "./node_modules/@tiledb-inc/tiledb-cloud/lib/TileDBQuery/TileDBQuery.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@tiledb-inc/tiledb-cloud/lib/TileDBQuery/TileDBQuery.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getResults = exports.TileDBQuery = void 0;
const dataToQuery_1 = __importDefault(__webpack_require__(/*! ../utils/dataToQuery */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/dataToQuery.js"));
const bufferToData_1 = __importStar(__webpack_require__(/*! ../utils/bufferToData */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/bufferToData.js"));
const capnpQueryDeSerializer_1 = __importDefault(__webpack_require__(/*! ../utils/capnpQueryDeSerializer */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/capnpQueryDeSerializer.js"));
const setNullables_1 = __importDefault(__webpack_require__(/*! ../utils/setNullables */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/setNullables.js"));
const v1_1 = __webpack_require__(/*! ../v1 */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/v1/index.js");
const v2_1 = __webpack_require__(/*! ../v2 */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/v2/index.js");
const getByteLengthOfDatatype_1 = __importDefault(__webpack_require__(/*! ../utils/getByteLengthOfDatatype */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/getByteLengthOfDatatype.js"));
const flatten_1 = __importDefault(__webpack_require__(/*! ../utils/flatten */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/flatten.js"));
const getWriterBody_1 = __importDefault(__webpack_require__(/*! ../utils/getWriterBody */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/getWriterBody.js"));
const groupValuesByOffsets_1 = __importDefault(__webpack_require__(/*! ../utils/groupValuesByOffsets */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/groupValuesByOffsets.js"));
const isArrayOfArrays_1 = __importDefault(__webpack_require__(/*! ../utils/isArrayOfArrays */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/isArrayOfArrays.js"));
class TileDBQuery {
    constructor(params) {
        this.configurationParams = params;
    }
    WriteQuery(namespace, arrayName, data) {
        var _a, _b, _c, _d, _e;
        return __awaiter(this, void 0, void 0, function* () {
            const config = new v2_1.Configuration(this.configurationParams);
            const baseV1 = (_a = config.basePath) === null || _a === void 0 ? void 0 : _a.replace("v2", "v1");
            // Add versioning if basePath exists
            const configV1 = new v2_1.Configuration(Object.assign(Object.assign({}, this.configurationParams), (baseV1 ? { basePath: baseV1 } : {})));
            const queryAPI = new v2_1.QueryApi(config);
            const arrayAPI = new v1_1.ArrayApi(configV1);
            try {
                const arraySchemaResponse = yield arrayAPI.getArray(namespace, arrayName, "application/json");
                const arraySchema = arraySchemaResponse.data;
                const body = getWriterBody_1.default(data, arraySchema);
                const queryResponse = yield queryAPI.submitQuery(namespace, arrayName, v2_1.Querytype.Write, "application/capnp", body, undefined, undefined, undefined, {
                    headers: {
                        "Content-Type": "application/capnp",
                    },
                    responseType: "arraybuffer",
                });
                /**
                 * Axios in nodeJS environments casts the response to a Buffer object
                 * we convert it back to an ArrayBuffer if needed
                 */
                const queryData = convertToArrayBufferIfNodeBuffer(queryResponse.data);
                const bufferWithoutFirstEightBytes = queryData.slice(8);
                return capnpQueryDeSerializer_1.default(bufferWithoutFirstEightBytes);
            }
            catch (e) {
                /**
                 * Since we set the responseType to "arrayBuffer", in case the
                 * response error message is a buffer, we deserialize the message before throwing
                 */
                const errorIsABuffer = ((_c = (_b = e === null || e === void 0 ? void 0 : e.response) === null || _b === void 0 ? void 0 : _b.data) === null || _c === void 0 ? void 0 : _c.buffer) || ((_e = (_d = e === null || e === void 0 ? void 0 : e.response) === null || _d === void 0 ? void 0 : _d.data) === null || _e === void 0 ? void 0 : _e.length);
                if (errorIsABuffer) {
                    const errorArrayBuffer = convertToArrayBufferIfNodeBuffer(e.response.data);
                    const decodedMessage = new TextDecoder().decode(errorArrayBuffer);
                    throw new Error(decodedMessage);
                }
                else {
                    throw e;
                }
            }
        });
    }
    ReadIncompleteQuery(arraySchema, queryAsArrayBuffer, namespace, arrayName) {
        return __awaiter(this, void 0, void 0, function* () {
            const config = new v2_1.Configuration(this.configurationParams);
            const queryAPI = new v2_1.QueryApi(config);
            const queryResponse = yield queryAPI.submitQuery(namespace, arrayName, v2_1.Querytype.Read, "application/capnp", queryAsArrayBuffer, undefined, undefined, undefined, {
                headers: {
                    "Content-Type": "application/capnp",
                },
                responseType: "arraybuffer",
            });
            /**
             * Axios in nodeJS environments casts the response to a Buffer object
             * we convert it back to an ArrayBuffer if needed
             */
            const queryData = convertToArrayBufferIfNodeBuffer(queryResponse.data);
            /**
             * First 8 bytes of the response, contain a Uint64 number
             * which is the size of the response we skip it.
             */
            const bufferWithoutFirstEightBytes = queryData.slice(8);
            /**
             * Deserialize buffer to a Query object
             */
            const queryObject = capnpQueryDeSerializer_1.default(bufferWithoutFirstEightBytes);
            const attributeHeaders = queryObject.attributeBufferHeaders;
            const results = this.getResultsFromArrayBuffer(arraySchema, bufferWithoutFirstEightBytes, attributeHeaders);
            return {
                results,
                query: queryObject,
                queryAsArrayBuffer: bufferWithoutFirstEightBytes,
            };
        });
    }
    ReadQuery(namespace, arrayName, body) {
        var _a;
        return __asyncGenerator(this, arguments, function* ReadQuery_1() {
            const config = new v2_1.Configuration(this.configurationParams);
            const baseV1 = (_a = config.basePath) === null || _a === void 0 ? void 0 : _a.replace("v2", "v1");
            // Add versioning if basePath exists
            const configV1 = new v2_1.Configuration(Object.assign(Object.assign({}, this.configurationParams), (baseV1 ? { basePath: baseV1 } : {})));
            const queryAPI = new v2_1.QueryApi(config);
            const arrayAPI = new v1_1.ArrayApi(configV1);
            try {
                // Get ArraySchema of arrray, to get type information of the dimensions and the attributes
                const arraySchemaResponse = yield __await(arrayAPI.getArray(namespace, arrayName, "application/json"));
                const arraySchema = arraySchemaResponse.data;
                /**
                 * Get the query response in capnp, we set responseType to arraybuffer instead of JSON
                 * in order to deserialize the query capnp object.
                 */
                const queryResponse = yield __await(queryAPI.submitQuery(namespace, arrayName, v2_1.Querytype.Read, "application/capnp", dataToQuery_1.default(body, arraySchema.attributes, arraySchema.domain.dimensions), undefined, undefined, undefined, {
                    headers: {
                        "Content-Type": "application/capnp",
                    },
                    responseType: "arraybuffer",
                }));
                /**
                 * Axios in nodeJS environments casts the response to a Buffer object
                 * we convert it back to an ArrayBuffer if needed
                 */
                const queryData = convertToArrayBufferIfNodeBuffer(queryResponse.data);
                /**
                 * First 8 bytes of the response, contain a Uint64 number
                 * which is the size of the response we skip it.
                 */
                let bufferWithoutFirstEightBytes = queryData.slice(8);
                /**
                 * Deserialize buffer to a Query object
                 */
                const queryObject = capnpQueryDeSerializer_1.default(bufferWithoutFirstEightBytes);
                const attributeHeaders = queryObject.attributeBufferHeaders;
                // Case it's incomplete query
                if (queryObject.status === v2_1.Querystatus.Incomplete) {
                    try {
                        yield yield __await(this.getResultsFromArrayBuffer(arraySchema, bufferWithoutFirstEightBytes, attributeHeaders));
                        while (true) {
                            const { results, query, queryAsArrayBuffer } = yield __await(this.ReadIncompleteQuery(arraySchema, bufferWithoutFirstEightBytes, namespace, arrayName));
                            // Override query object with the new one returned from `ReadIncompleteQuery`
                            bufferWithoutFirstEightBytes = queryAsArrayBuffer;
                            if (query.status === v2_1.Querystatus.Incomplete) {
                                yield yield __await(results);
                            }
                            else {
                                // Case query is not incomplete
                                yield yield __await(results);
                                return yield __await(void 0);
                            }
                        }
                    }
                    catch (e) {
                        this.throwError(e);
                    }
                }
                yield yield __await(this.getResultsFromArrayBuffer(arraySchema, bufferWithoutFirstEightBytes, attributeHeaders));
                return yield __await(void 0);
            }
            catch (e) {
                this.throwError(e);
            }
        });
    }
    getResultsFromArrayBuffer(arraySchema, bufferResults, attributeHeaders) {
        /**
         * Calculate the size of bytes of the attributes from the attributeBufferHeaders of the Query object.
         */
        const numberOfBytesOfResults = getSizeInBytesOfAllAttributes(attributeHeaders);
        /**
         * We get the last N bytes (N is the number of total bytes of the attributes), which contain
         * the results of all the attributes
         */
        const resultsBuffer = bufferResults.slice(-1 * numberOfBytesOfResults);
        const mergeAttributesAndDimensions = [
            ...arraySchema.domain.dimensions,
            ...arraySchema.attributes,
        ];
        // Calculate results
        const results = exports.getResults(resultsBuffer, attributeHeaders, mergeAttributesAndDimensions);
        return results;
    }
    throwError(e) {
        var _a, _b, _c, _d;
        /**
         * Since we set the responseType to "arrayBuffer", in case the
         * response error message is a buffer, we deserialize the message before throwing
         */
        const errorIsABuffer = ((_b = (_a = e === null || e === void 0 ? void 0 : e.response) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.buffer) || ((_d = (_c = e === null || e === void 0 ? void 0 : e.response) === null || _c === void 0 ? void 0 : _c.data) === null || _d === void 0 ? void 0 : _d.length);
        if (errorIsABuffer) {
            const errorArrayBuffer = convertToArrayBufferIfNodeBuffer(e.response.data);
            const decodedMessage = new TextDecoder().decode(errorArrayBuffer);
            throw new Error(decodedMessage);
        }
        else {
            throw e;
        }
    }
}
exports.TileDBQuery = TileDBQuery;
exports["default"] = TileDBQuery;
/**
 * If buffer is a NodeJS Buffer object we convert it back to an ArrayBuffer
 * @param buffer ArrayBuffer or Nodejs Buffer
 * @returns ArrayBuffer
 */
function convertToArrayBufferIfNodeBuffer(buffer) {
    if (buffer.buffer) {
        return new Uint8Array(buffer).buffer;
    }
    return buffer;
}
/**
 * Add all buffers of an attribute
 * @param attr AttributeBufferHeader
 * @returns number of the total bytes of the attribute
 */
const getAttributeSizeInBytes = (attr) => {
    return (attr.fixedLenBufferSizeInBytes +
        attr.varLenBufferSizeInBytes +
        attr.validityLenBufferSizeInBytes);
};
/**
 * Calculate the total bytes of all the attributes
 * @param attributes
 * @returns number of the total bytes of all the attributes
 */
const getSizeInBytesOfAllAttributes = (attributes) => attributes.reduce((accum, attr) => accum + getAttributeSizeInBytes(attr), 0);
/**
 * Convert an ArrayBuffer to a map of attributes with their results
 * @param arrayBuffer The slice ArrayBuffer that contains the results
 * @param attributes
 * @param attributesSchema
 * @returns A map of attribute names with the results of every attribute
 */
const getResults = (arrayBuffer, attributes, attributesSchema) => {
    const data = {};
    /**
     * We start from the last attribute which is at the end of the buffer
     */
    attributes.reverse().reduce((offset, attribute) => {
        const totalNumberOfBytesOfAttribute = getAttributeSizeInBytes(attribute);
        if (!totalNumberOfBytesOfAttribute) {
            data[attribute.name] = null;
            return offset;
        }
        // If there are validityLenBufferSizeInBytes the attribute is nullable
        const isNullable = !!attribute.validityLenBufferSizeInBytes;
        // If there are varLenBufferSizeInBytes the attribute is varLengthSized
        const isVarLengthSized = !!attribute.varLenBufferSizeInBytes;
        const selectedAttributeSchema = getAttributeSchema(attribute.name, attributesSchema);
        const negativeOffset = -1 * offset;
        /**
         * If attribute is varLengthSized, we ignore the first N bytes (where N = fixedLenBufferSizeInBytes)
         * These first N bytes contain the offsets of the attribute, which is a uint64 array.
         */
        const start = negativeOffset -
            totalNumberOfBytesOfAttribute +
            (isVarLengthSized ? attribute.fixedLenBufferSizeInBytes : 0);
        /**
         * If attribute is isNullable we ignore the last N bytes (where N = validityLenBufferSizeInBytes)
         * These last N bytes contain a uint8 array of zeros and ones, where every zero represents
         * that in that index the attribute is null.
         */
        const ending = negativeOffset -
            (isNullable ? attribute.validityLenBufferSizeInBytes : 0);
        const end = ending ? ending : undefined;
        let result = bufferToData_1.default(arrayBuffer.slice(start, end), selectedAttributeSchema.type);
        let offsets = [];
        if (isVarLengthSized) {
            const BYTE_PER_ELEMENT = getByteLengthOfDatatype_1.default(selectedAttributeSchema.type);
            const startOfBuffer = negativeOffset - totalNumberOfBytesOfAttribute;
            const offsetsBuffer = arrayBuffer.slice(startOfBuffer, startOfBuffer + attribute.fixedLenBufferSizeInBytes);
            /**
             * Offsets are Uint64 numbers, buffer contains byte offsets though,
             * e.g. if type of the attribute is an INT32 (4 bytes per number) and the offsets are [0, 3, 4]
             * the buffer contains the offsets * bytes of the element instead of just the offsets [0, 3 * 4, 4 * 4] = [0, 12, 16]
             */
            const byteOffsets = Array.from(new BigUint64Array(offsetsBuffer));
            // Convert byte offsets to offsets
            offsets = byteOffsets.map((o) => Number(o) / BYTE_PER_ELEMENT);
        }
        if (isNullable) {
            /**
             * If attribute is Nullable, we get the last N bytes, cast it to uint8 array to get
             * what is null.
             */
            const nullableArrayEnd = ending + attribute.validityLenBufferSizeInBytes;
            const nullableArrayBuffer = arrayBuffer.slice(ending, nullableArrayEnd ? nullableArrayEnd : undefined);
            const nullablesTypedArray = bufferToData_1.bufferToInt8(nullableArrayBuffer);
            /**
             * nullablesArray should be an array of zeros and ones (e.g. [0, 1, 1, 0])
             * Every zero represents that in that specific index the attribute is NULL
             */
            const nullablesArray = Array.from(nullablesTypedArray);
            result = setNullables_1.default(Array.from(result), nullablesArray, offsets);
        }
        // If result is a String slice the String by the offsets to make it an array
        if (isVarLengthSized && typeof result === "string") {
            result = groupValuesByOffsets_1.default([...result], offsets).map((s) => s.join(""));
        }
        data[attribute.name] = isArrayOfArrays_1.default(result) ? flatten_1.default(result) : result;
        return offset + totalNumberOfBytesOfAttribute;
    }, 0);
    return data;
};
exports.getResults = getResults;
/**
 * Get attribute data from attribute name, attribute data contains the type of the attribute (e.g. INT32, StringUTF8 etc)
 */
const getAttributeSchema = (attrName, attributesSchema) => {
    return attributesSchema.find((attr) => attr.name === attrName);
};
//# sourceMappingURL=TileDBQuery.js.map

/***/ }),

/***/ "./node_modules/@tiledb-inc/tiledb-cloud/lib/capnp/arrayMetadata_capnp.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@tiledb-inc/tiledb-cloud/lib/capnp/arrayMetadata_capnp.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* tslint:disable */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ArrayMetadata = exports.ArrayMetadata_MetadataEntry = exports._capnpFileId = void 0;
/**
 * This file has been automatically generated by the [capnpc-ts utility](https://github.com/jdiaz5513/capnp-ts).
 */
const capnp = __importStar(__webpack_require__(/*! capnp-ts */ "./node_modules/capnp-ts/lib/index.js"));
const capnp_ts_1 = __webpack_require__(/*! capnp-ts */ "./node_modules/capnp-ts/lib/index.js");
exports._capnpFileId = "b57d9224b587d87f";
class ArrayMetadata_MetadataEntry extends capnp_ts_1.Struct {
    getKey() { return capnp_ts_1.Struct.getText(0, this); }
    setKey(value) { capnp_ts_1.Struct.setText(0, value, this); }
    getType() { return capnp_ts_1.Struct.getText(1, this); }
    setType(value) { capnp_ts_1.Struct.setText(1, value, this); }
    getValueNum() { return capnp_ts_1.Struct.getUint32(0, this); }
    setValueNum(value) { capnp_ts_1.Struct.setUint32(0, value, this); }
    adoptValue(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(2, this)); }
    disownValue() { return capnp_ts_1.Struct.disown(this.getValue()); }
    getValue() { return capnp_ts_1.Struct.getData(2, this); }
    hasValue() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(2, this)); }
    initValue(length) { return capnp_ts_1.Struct.initData(2, length, this); }
    setValue(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(2, this)); }
    getDel() { return capnp_ts_1.Struct.getBit(32, this); }
    setDel(value) { capnp_ts_1.Struct.setBit(32, value, this); }
    toString() { return "ArrayMetadata_MetadataEntry_" + super.toString(); }
}
exports.ArrayMetadata_MetadataEntry = ArrayMetadata_MetadataEntry;
ArrayMetadata_MetadataEntry._capnp = { displayName: "MetadataEntry", id: "926fe1c3b12ed651", size: new capnp_ts_1.ObjectSize(8, 3) };
class ArrayMetadata extends capnp_ts_1.Struct {
    adoptEntries(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(0, this)); }
    disownEntries() { return capnp_ts_1.Struct.disown(this.getEntries()); }
    getEntries() { return capnp_ts_1.Struct.getList(0, ArrayMetadata._Entries, this); }
    hasEntries() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(0, this)); }
    initEntries(length) { return capnp_ts_1.Struct.initList(0, ArrayMetadata._Entries, length, this); }
    setEntries(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(0, this)); }
    toString() { return "ArrayMetadata_" + super.toString(); }
}
exports.ArrayMetadata = ArrayMetadata;
ArrayMetadata.MetadataEntry = ArrayMetadata_MetadataEntry;
ArrayMetadata._capnp = { displayName: "ArrayMetadata", id: "9737dcafdfce31bb", size: new capnp_ts_1.ObjectSize(0, 1) };
ArrayMetadata._Entries = capnp.CompositeList(ArrayMetadata_MetadataEntry);
//# sourceMappingURL=arrayMetadata_capnp.js.map

/***/ }),

/***/ "./node_modules/@tiledb-inc/tiledb-cloud/lib/capnp/query_capnp.js":
/*!************************************************************************!*\
  !*** ./node_modules/@tiledb-inc/tiledb-cloud/lib/capnp/query_capnp.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* tslint:disable */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AttributeBufferSize = exports.MapUInt64 = exports.MapUInt64_Entry = exports.MapFloat64 = exports.MapFloat64_Entry = exports.DomainArray = exports.Condition = exports.ConditionClause = exports.ReadState = exports.SubarrayPartitioner = exports.SubarrayPartitioner_State = exports.SubarrayPartitioner_PartitionInfo = exports.Subarray = exports.SubarrayRanges = exports.QueryReader = exports.Writer = exports.Stats = exports.Config = exports.KV = exports.Filter = exports.Filter_Data = exports.Filter_Data_Which = exports.FilterPipeline = exports.Array = exports.AttributeBufferHeader = exports.Query = exports._capnpFileId = void 0;
/**
 * This file has been automatically generated by the [capnpc-ts utility](https://github.com/jdiaz5513/capnp-ts).
 */
const capnp = __importStar(__webpack_require__(/*! capnp-ts */ "./node_modules/capnp-ts/lib/index.js"));
const capnp_ts_1 = __webpack_require__(/*! capnp-ts */ "./node_modules/capnp-ts/lib/index.js");
exports._capnpFileId = "b57d9224b587d87e";
class Query extends capnp_ts_1.Struct {
    adoptAttributeBufferHeaders(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(0, this)); }
    disownAttributeBufferHeaders() { return capnp_ts_1.Struct.disown(this.getAttributeBufferHeaders()); }
    getAttributeBufferHeaders() { return capnp_ts_1.Struct.getList(0, Query._AttributeBufferHeaders, this); }
    hasAttributeBufferHeaders() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(0, this)); }
    initAttributeBufferHeaders(length) { return capnp_ts_1.Struct.initList(0, Query._AttributeBufferHeaders, length, this); }
    setAttributeBufferHeaders(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(0, this)); }
    getLayout() { return capnp_ts_1.Struct.getText(1, this); }
    setLayout(value) { capnp_ts_1.Struct.setText(1, value, this); }
    getStatus() { return capnp_ts_1.Struct.getText(2, this); }
    setStatus(value) { capnp_ts_1.Struct.setText(2, value, this); }
    getType() { return capnp_ts_1.Struct.getText(3, this); }
    setType(value) { capnp_ts_1.Struct.setText(3, value, this); }
    adoptWriter(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(4, this)); }
    disownWriter() { return capnp_ts_1.Struct.disown(this.getWriter()); }
    getWriter() { return capnp_ts_1.Struct.getStruct(4, Writer, this); }
    hasWriter() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(4, this)); }
    initWriter() { return capnp_ts_1.Struct.initStructAt(4, Writer, this); }
    setWriter(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(4, this)); }
    adoptReader(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(5, this)); }
    disownReader() { return capnp_ts_1.Struct.disown(this.getReader()); }
    getReader() { return capnp_ts_1.Struct.getStruct(5, QueryReader, this); }
    hasReader() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(5, this)); }
    initReader() { return capnp_ts_1.Struct.initStructAt(5, QueryReader, this); }
    setReader(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(5, this)); }
    adoptArray(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(6, this)); }
    disownArray() { return capnp_ts_1.Struct.disown(this.getArray()); }
    getArray() { return capnp_ts_1.Struct.getStruct(6, Array, this); }
    hasArray() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(6, this)); }
    initArray() { return capnp_ts_1.Struct.initStructAt(6, Array, this); }
    setArray(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(6, this)); }
    getTotalFixedLengthBufferBytes() { return capnp_ts_1.Struct.getUint64(0, this); }
    setTotalFixedLengthBufferBytes(value) { capnp_ts_1.Struct.setUint64(0, value, this); }
    getTotalVarLenBufferBytes() { return capnp_ts_1.Struct.getUint64(8, this); }
    setTotalVarLenBufferBytes(value) { capnp_ts_1.Struct.setUint64(8, value, this); }
    getTotalValidityBufferBytes() { return capnp_ts_1.Struct.getUint64(16, this); }
    setTotalValidityBufferBytes(value) { capnp_ts_1.Struct.setUint64(16, value, this); }
    getVarOffsetsMode() { return capnp_ts_1.Struct.getText(7, this); }
    setVarOffsetsMode(value) { capnp_ts_1.Struct.setText(7, value, this); }
    getVarOffsetsAddExtraElement() { return capnp_ts_1.Struct.getBit(192, this); }
    setVarOffsetsAddExtraElement(value) { capnp_ts_1.Struct.setBit(192, value, this); }
    getVarOffsetsBitsize() { return capnp_ts_1.Struct.getInt32(28, this); }
    setVarOffsetsBitsize(value) { capnp_ts_1.Struct.setInt32(28, value, this); }
    adoptConfig(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(8, this)); }
    disownConfig() { return capnp_ts_1.Struct.disown(this.getConfig()); }
    getConfig() { return capnp_ts_1.Struct.getStruct(8, Config, this); }
    hasConfig() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(8, this)); }
    initConfig() { return capnp_ts_1.Struct.initStructAt(8, Config, this); }
    setConfig(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(8, this)); }
    adoptStats(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(9, this)); }
    disownStats() { return capnp_ts_1.Struct.disown(this.getStats()); }
    getStats() { return capnp_ts_1.Struct.getStruct(9, Stats, this); }
    hasStats() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(9, this)); }
    initStats() { return capnp_ts_1.Struct.initStructAt(9, Stats, this); }
    setStats(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(9, this)); }
    toString() { return "Query_" + super.toString(); }
}
exports.Query = Query;
Query._capnp = { displayName: "Query", id: "ea34268ae031ac7a", size: new capnp_ts_1.ObjectSize(32, 10) };
class AttributeBufferHeader extends capnp_ts_1.Struct {
    getName() { return capnp_ts_1.Struct.getText(0, this); }
    setName(value) { capnp_ts_1.Struct.setText(0, value, this); }
    getFixedLenBufferSizeInBytes() { return capnp_ts_1.Struct.getUint64(0, this); }
    setFixedLenBufferSizeInBytes(value) { capnp_ts_1.Struct.setUint64(0, value, this); }
    getVarLenBufferSizeInBytes() { return capnp_ts_1.Struct.getUint64(8, this); }
    setVarLenBufferSizeInBytes(value) { capnp_ts_1.Struct.setUint64(8, value, this); }
    getValidityLenBufferSizeInBytes() { return capnp_ts_1.Struct.getUint64(16, this); }
    setValidityLenBufferSizeInBytes(value) { capnp_ts_1.Struct.setUint64(16, value, this); }
    getOriginalFixedLenBufferSizeInBytes() { return capnp_ts_1.Struct.getUint64(24, this); }
    setOriginalFixedLenBufferSizeInBytes(value) { capnp_ts_1.Struct.setUint64(24, value, this); }
    getOriginalVarLenBufferSizeInBytes() { return capnp_ts_1.Struct.getUint64(32, this); }
    setOriginalVarLenBufferSizeInBytes(value) { capnp_ts_1.Struct.setUint64(32, value, this); }
    getOriginalValidityLenBufferSizeInBytes() { return capnp_ts_1.Struct.getUint64(40, this); }
    setOriginalValidityLenBufferSizeInBytes(value) { capnp_ts_1.Struct.setUint64(40, value, this); }
    toString() { return "AttributeBufferHeader_" + super.toString(); }
}
exports.AttributeBufferHeader = AttributeBufferHeader;
AttributeBufferHeader._capnp = { displayName: "AttributeBufferHeader", id: "9884df9a1b40f364", size: new capnp_ts_1.ObjectSize(48, 1) };
class Array extends capnp_ts_1.Struct {
    getEndTimestamp() { return capnp_ts_1.Struct.getUint64(0, this); }
    setEndTimestamp(value) { capnp_ts_1.Struct.setUint64(0, value, this); }
    getQueryType() { return capnp_ts_1.Struct.getText(0, this); }
    setQueryType(value) { capnp_ts_1.Struct.setText(0, value, this); }
    getUri() { return capnp_ts_1.Struct.getText(1, this); }
    setUri(value) { capnp_ts_1.Struct.setText(1, value, this); }
    getStartTimestamp() { return capnp_ts_1.Struct.getUint64(8, this); }
    setStartTimestamp(value) { capnp_ts_1.Struct.setUint64(8, value, this); }
    toString() { return "Array_" + super.toString(); }
}
exports.Array = Array;
Array._capnp = { displayName: "Array", id: "e8b44da5a3b284a4", size: new capnp_ts_1.ObjectSize(16, 2) };
class FilterPipeline extends capnp_ts_1.Struct {
    adoptFilters(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(0, this)); }
    disownFilters() { return capnp_ts_1.Struct.disown(this.getFilters()); }
    getFilters() { return capnp_ts_1.Struct.getList(0, FilterPipeline._Filters, this); }
    hasFilters() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(0, this)); }
    initFilters(length) { return capnp_ts_1.Struct.initList(0, FilterPipeline._Filters, length, this); }
    setFilters(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(0, this)); }
    toString() { return "FilterPipeline_" + super.toString(); }
}
exports.FilterPipeline = FilterPipeline;
FilterPipeline._capnp = { displayName: "FilterPipeline", id: "a6d903a3c84d4809", size: new capnp_ts_1.ObjectSize(0, 1) };
var Filter_Data_Which;
(function (Filter_Data_Which) {
    Filter_Data_Which[Filter_Data_Which["TEXT"] = 0] = "TEXT";
    Filter_Data_Which[Filter_Data_Which["BYTES"] = 1] = "BYTES";
    Filter_Data_Which[Filter_Data_Which["INT8"] = 2] = "INT8";
    Filter_Data_Which[Filter_Data_Which["UINT8"] = 3] = "UINT8";
    Filter_Data_Which[Filter_Data_Which["INT16"] = 4] = "INT16";
    Filter_Data_Which[Filter_Data_Which["UINT16"] = 5] = "UINT16";
    Filter_Data_Which[Filter_Data_Which["INT32"] = 6] = "INT32";
    Filter_Data_Which[Filter_Data_Which["UINT32"] = 7] = "UINT32";
    Filter_Data_Which[Filter_Data_Which["INT64"] = 8] = "INT64";
    Filter_Data_Which[Filter_Data_Which["UINT64"] = 9] = "UINT64";
    Filter_Data_Which[Filter_Data_Which["FLOAT32"] = 10] = "FLOAT32";
    Filter_Data_Which[Filter_Data_Which["FLOAT64"] = 11] = "FLOAT64";
})(Filter_Data_Which = exports.Filter_Data_Which || (exports.Filter_Data_Which = {}));
class Filter_Data extends capnp_ts_1.Struct {
    getText() {
        capnp_ts_1.Struct.testWhich("text", capnp_ts_1.Struct.getUint16(0, this), 0, this);
        return capnp_ts_1.Struct.getText(1, this);
    }
    isText() { return capnp_ts_1.Struct.getUint16(0, this) === 0; }
    setText(value) {
        capnp_ts_1.Struct.setUint16(0, 0, this);
        capnp_ts_1.Struct.setText(1, value, this);
    }
    adoptBytes(value) {
        capnp_ts_1.Struct.setUint16(0, 1, this);
        capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(1, this));
    }
    disownBytes() { return capnp_ts_1.Struct.disown(this.getBytes()); }
    getBytes() {
        capnp_ts_1.Struct.testWhich("bytes", capnp_ts_1.Struct.getUint16(0, this), 1, this);
        return capnp_ts_1.Struct.getData(1, this);
    }
    hasBytes() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(1, this)); }
    initBytes(length) {
        capnp_ts_1.Struct.setUint16(0, 1, this);
        return capnp_ts_1.Struct.initData(1, length, this);
    }
    isBytes() { return capnp_ts_1.Struct.getUint16(0, this) === 1; }
    setBytes(value) {
        capnp_ts_1.Struct.setUint16(0, 1, this);
        capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(1, this));
    }
    getInt8() {
        capnp_ts_1.Struct.testWhich("int8", capnp_ts_1.Struct.getUint16(0, this), 2, this);
        return capnp_ts_1.Struct.getInt8(2, this);
    }
    isInt8() { return capnp_ts_1.Struct.getUint16(0, this) === 2; }
    setInt8(value) {
        capnp_ts_1.Struct.setUint16(0, 2, this);
        capnp_ts_1.Struct.setInt8(2, value, this);
    }
    getUint8() {
        capnp_ts_1.Struct.testWhich("uint8", capnp_ts_1.Struct.getUint16(0, this), 3, this);
        return capnp_ts_1.Struct.getUint8(2, this);
    }
    isUint8() { return capnp_ts_1.Struct.getUint16(0, this) === 3; }
    setUint8(value) {
        capnp_ts_1.Struct.setUint16(0, 3, this);
        capnp_ts_1.Struct.setUint8(2, value, this);
    }
    getInt16() {
        capnp_ts_1.Struct.testWhich("int16", capnp_ts_1.Struct.getUint16(0, this), 4, this);
        return capnp_ts_1.Struct.getInt16(2, this);
    }
    isInt16() { return capnp_ts_1.Struct.getUint16(0, this) === 4; }
    setInt16(value) {
        capnp_ts_1.Struct.setUint16(0, 4, this);
        capnp_ts_1.Struct.setInt16(2, value, this);
    }
    getUint16() {
        capnp_ts_1.Struct.testWhich("uint16", capnp_ts_1.Struct.getUint16(0, this), 5, this);
        return capnp_ts_1.Struct.getUint16(2, this);
    }
    isUint16() { return capnp_ts_1.Struct.getUint16(0, this) === 5; }
    setUint16(value) {
        capnp_ts_1.Struct.setUint16(0, 5, this);
        capnp_ts_1.Struct.setUint16(2, value, this);
    }
    getInt32() {
        capnp_ts_1.Struct.testWhich("int32", capnp_ts_1.Struct.getUint16(0, this), 6, this);
        return capnp_ts_1.Struct.getInt32(4, this);
    }
    isInt32() { return capnp_ts_1.Struct.getUint16(0, this) === 6; }
    setInt32(value) {
        capnp_ts_1.Struct.setUint16(0, 6, this);
        capnp_ts_1.Struct.setInt32(4, value, this);
    }
    getUint32() {
        capnp_ts_1.Struct.testWhich("uint32", capnp_ts_1.Struct.getUint16(0, this), 7, this);
        return capnp_ts_1.Struct.getUint32(4, this);
    }
    isUint32() { return capnp_ts_1.Struct.getUint16(0, this) === 7; }
    setUint32(value) {
        capnp_ts_1.Struct.setUint16(0, 7, this);
        capnp_ts_1.Struct.setUint32(4, value, this);
    }
    getInt64() {
        capnp_ts_1.Struct.testWhich("int64", capnp_ts_1.Struct.getUint16(0, this), 8, this);
        return capnp_ts_1.Struct.getInt64(8, this);
    }
    isInt64() { return capnp_ts_1.Struct.getUint16(0, this) === 8; }
    setInt64(value) {
        capnp_ts_1.Struct.setUint16(0, 8, this);
        capnp_ts_1.Struct.setInt64(8, value, this);
    }
    getUint64() {
        capnp_ts_1.Struct.testWhich("uint64", capnp_ts_1.Struct.getUint16(0, this), 9, this);
        return capnp_ts_1.Struct.getUint64(8, this);
    }
    isUint64() { return capnp_ts_1.Struct.getUint16(0, this) === 9; }
    setUint64(value) {
        capnp_ts_1.Struct.setUint16(0, 9, this);
        capnp_ts_1.Struct.setUint64(8, value, this);
    }
    getFloat32() {
        capnp_ts_1.Struct.testWhich("float32", capnp_ts_1.Struct.getUint16(0, this), 10, this);
        return capnp_ts_1.Struct.getFloat32(4, this);
    }
    isFloat32() { return capnp_ts_1.Struct.getUint16(0, this) === 10; }
    setFloat32(value) {
        capnp_ts_1.Struct.setUint16(0, 10, this);
        capnp_ts_1.Struct.setFloat32(4, value, this);
    }
    getFloat64() {
        capnp_ts_1.Struct.testWhich("float64", capnp_ts_1.Struct.getUint16(0, this), 11, this);
        return capnp_ts_1.Struct.getFloat64(8, this);
    }
    isFloat64() { return capnp_ts_1.Struct.getUint16(0, this) === 11; }
    setFloat64(value) {
        capnp_ts_1.Struct.setUint16(0, 11, this);
        capnp_ts_1.Struct.setFloat64(8, value, this);
    }
    toString() { return "Filter_Data_" + super.toString(); }
    which() { return capnp_ts_1.Struct.getUint16(0, this); }
}
exports.Filter_Data = Filter_Data;
Filter_Data.TEXT = Filter_Data_Which.TEXT;
Filter_Data.BYTES = Filter_Data_Which.BYTES;
Filter_Data.INT8 = Filter_Data_Which.INT8;
Filter_Data.UINT8 = Filter_Data_Which.UINT8;
Filter_Data.INT16 = Filter_Data_Which.INT16;
Filter_Data.UINT16 = Filter_Data_Which.UINT16;
Filter_Data.INT32 = Filter_Data_Which.INT32;
Filter_Data.UINT32 = Filter_Data_Which.UINT32;
Filter_Data.INT64 = Filter_Data_Which.INT64;
Filter_Data.UINT64 = Filter_Data_Which.UINT64;
Filter_Data.FLOAT32 = Filter_Data_Which.FLOAT32;
Filter_Data.FLOAT64 = Filter_Data_Which.FLOAT64;
Filter_Data._capnp = { displayName: "data", id: "f7e88fec77255f9a", size: new capnp_ts_1.ObjectSize(16, 2) };
class Filter extends capnp_ts_1.Struct {
    getType() { return capnp_ts_1.Struct.getText(0, this); }
    setType(value) { capnp_ts_1.Struct.setText(0, value, this); }
    getData() { return capnp_ts_1.Struct.getAs(Filter_Data, this); }
    initData() { return capnp_ts_1.Struct.getAs(Filter_Data, this); }
    toString() { return "Filter_" + super.toString(); }
}
exports.Filter = Filter;
Filter._capnp = { displayName: "Filter", id: "dac88a0a3b53a50a", size: new capnp_ts_1.ObjectSize(16, 2) };
class KV extends capnp_ts_1.Struct {
    getKey() { return capnp_ts_1.Struct.getText(0, this); }
    setKey(value) { capnp_ts_1.Struct.setText(0, value, this); }
    getValue() { return capnp_ts_1.Struct.getText(1, this); }
    setValue(value) { capnp_ts_1.Struct.setText(1, value, this); }
    toString() { return "KV_" + super.toString(); }
}
exports.KV = KV;
KV._capnp = { displayName: "KV", id: "f81811af0443b7bd", size: new capnp_ts_1.ObjectSize(0, 2) };
class Config extends capnp_ts_1.Struct {
    adoptEntries(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(0, this)); }
    disownEntries() { return capnp_ts_1.Struct.disown(this.getEntries()); }
    getEntries() { return capnp_ts_1.Struct.getList(0, Config._Entries, this); }
    hasEntries() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(0, this)); }
    initEntries(length) { return capnp_ts_1.Struct.initList(0, Config._Entries, length, this); }
    setEntries(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(0, this)); }
    toString() { return "Config_" + super.toString(); }
}
exports.Config = Config;
Config._capnp = { displayName: "Config", id: "84e9e25074e7b66d", size: new capnp_ts_1.ObjectSize(0, 1) };
class Stats extends capnp_ts_1.Struct {
    adoptTimers(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(0, this)); }
    disownTimers() { return capnp_ts_1.Struct.disown(this.getTimers()); }
    getTimers() { return capnp_ts_1.Struct.getStruct(0, MapFloat64, this); }
    hasTimers() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(0, this)); }
    initTimers() { return capnp_ts_1.Struct.initStructAt(0, MapFloat64, this); }
    setTimers(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(0, this)); }
    adoptCounters(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(1, this)); }
    disownCounters() { return capnp_ts_1.Struct.disown(this.getCounters()); }
    getCounters() { return capnp_ts_1.Struct.getStruct(1, MapUInt64, this); }
    hasCounters() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(1, this)); }
    initCounters() { return capnp_ts_1.Struct.initStructAt(1, MapUInt64, this); }
    setCounters(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(1, this)); }
    toString() { return "Stats_" + super.toString(); }
}
exports.Stats = Stats;
Stats._capnp = { displayName: "Stats", id: "ef6314d713d0ab34", size: new capnp_ts_1.ObjectSize(0, 2) };
class Writer extends capnp_ts_1.Struct {
    getCheckCoordDups() { return capnp_ts_1.Struct.getBit(0, this); }
    setCheckCoordDups(value) { capnp_ts_1.Struct.setBit(0, value, this); }
    getCheckCoordOOB() { return capnp_ts_1.Struct.getBit(1, this); }
    setCheckCoordOOB(value) { capnp_ts_1.Struct.setBit(1, value, this); }
    getDedupCoords() { return capnp_ts_1.Struct.getBit(2, this); }
    setDedupCoords(value) { capnp_ts_1.Struct.setBit(2, value, this); }
    adoptSubarray(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(0, this)); }
    disownSubarray() { return capnp_ts_1.Struct.disown(this.getSubarray()); }
    getSubarray() { return capnp_ts_1.Struct.getStruct(0, DomainArray, this); }
    hasSubarray() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(0, this)); }
    initSubarray() { return capnp_ts_1.Struct.initStructAt(0, DomainArray, this); }
    setSubarray(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(0, this)); }
    adoptSubarrayRanges(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(1, this)); }
    disownSubarrayRanges() { return capnp_ts_1.Struct.disown(this.getSubarrayRanges()); }
    getSubarrayRanges() { return capnp_ts_1.Struct.getStruct(1, Subarray, this); }
    hasSubarrayRanges() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(1, this)); }
    initSubarrayRanges() { return capnp_ts_1.Struct.initStructAt(1, Subarray, this); }
    setSubarrayRanges(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(1, this)); }
    adoptStats(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(2, this)); }
    disownStats() { return capnp_ts_1.Struct.disown(this.getStats()); }
    getStats() { return capnp_ts_1.Struct.getStruct(2, Stats, this); }
    hasStats() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(2, this)); }
    initStats() { return capnp_ts_1.Struct.initStructAt(2, Stats, this); }
    setStats(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(2, this)); }
    toString() { return "Writer_" + super.toString(); }
}
exports.Writer = Writer;
Writer._capnp = { displayName: "Writer", id: "fe68eabb8ab4dcfa", size: new capnp_ts_1.ObjectSize(8, 3) };
class QueryReader extends capnp_ts_1.Struct {
    getLayout() { return capnp_ts_1.Struct.getText(0, this); }
    setLayout(value) { capnp_ts_1.Struct.setText(0, value, this); }
    adoptSubarray(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(1, this)); }
    disownSubarray() { return capnp_ts_1.Struct.disown(this.getSubarray()); }
    getSubarray() { return capnp_ts_1.Struct.getStruct(1, Subarray, this); }
    hasSubarray() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(1, this)); }
    initSubarray() { return capnp_ts_1.Struct.initStructAt(1, Subarray, this); }
    setSubarray(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(1, this)); }
    adoptReadState(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(2, this)); }
    disownReadState() { return capnp_ts_1.Struct.disown(this.getReadState()); }
    getReadState() { return capnp_ts_1.Struct.getStruct(2, ReadState, this); }
    hasReadState() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(2, this)); }
    initReadState() { return capnp_ts_1.Struct.initStructAt(2, ReadState, this); }
    setReadState(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(2, this)); }
    adoptCondition(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(3, this)); }
    disownCondition() { return capnp_ts_1.Struct.disown(this.getCondition()); }
    getCondition() { return capnp_ts_1.Struct.getStruct(3, Condition, this); }
    hasCondition() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(3, this)); }
    initCondition() { return capnp_ts_1.Struct.initStructAt(3, Condition, this); }
    setCondition(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(3, this)); }
    adoptStats(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(4, this)); }
    disownStats() { return capnp_ts_1.Struct.disown(this.getStats()); }
    getStats() { return capnp_ts_1.Struct.getStruct(4, Stats, this); }
    hasStats() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(4, this)); }
    initStats() { return capnp_ts_1.Struct.initStructAt(4, Stats, this); }
    setStats(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(4, this)); }
    toString() { return "QueryReader_" + super.toString(); }
}
exports.QueryReader = QueryReader;
QueryReader._capnp = { displayName: "QueryReader", id: "97a817df79d1095d", size: new capnp_ts_1.ObjectSize(0, 5) };
class SubarrayRanges extends capnp_ts_1.Struct {
    getType() { return capnp_ts_1.Struct.getText(0, this); }
    setType(value) { capnp_ts_1.Struct.setText(0, value, this); }
    getHasDefaultRange() { return capnp_ts_1.Struct.getBit(0, this); }
    setHasDefaultRange(value) { capnp_ts_1.Struct.setBit(0, value, this); }
    adoptBuffer(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(1, this)); }
    disownBuffer() { return capnp_ts_1.Struct.disown(this.getBuffer()); }
    getBuffer() { return capnp_ts_1.Struct.getData(1, this); }
    hasBuffer() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(1, this)); }
    initBuffer(length) { return capnp_ts_1.Struct.initData(1, length, this); }
    setBuffer(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(1, this)); }
    adoptBufferSizes(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(2, this)); }
    disownBufferSizes() { return capnp_ts_1.Struct.disown(this.getBufferSizes()); }
    getBufferSizes() { return capnp_ts_1.Struct.getList(2, capnp.Uint64List, this); }
    hasBufferSizes() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(2, this)); }
    initBufferSizes(length) { return capnp_ts_1.Struct.initList(2, capnp.Uint64List, length, this); }
    setBufferSizes(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(2, this)); }
    adoptBufferStartSizes(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(3, this)); }
    disownBufferStartSizes() { return capnp_ts_1.Struct.disown(this.getBufferStartSizes()); }
    getBufferStartSizes() { return capnp_ts_1.Struct.getList(3, capnp.Uint64List, this); }
    hasBufferStartSizes() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(3, this)); }
    initBufferStartSizes(length) { return capnp_ts_1.Struct.initList(3, capnp.Uint64List, length, this); }
    setBufferStartSizes(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(3, this)); }
    toString() { return "SubarrayRanges_" + super.toString(); }
}
exports.SubarrayRanges = SubarrayRanges;
SubarrayRanges._capnp = { displayName: "SubarrayRanges", id: "8587733f29e10a41", size: new capnp_ts_1.ObjectSize(8, 4) };
class Subarray extends capnp_ts_1.Struct {
    getLayout() { return capnp_ts_1.Struct.getText(0, this); }
    setLayout(value) { capnp_ts_1.Struct.setText(0, value, this); }
    adoptRanges(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(1, this)); }
    disownRanges() { return capnp_ts_1.Struct.disown(this.getRanges()); }
    getRanges() { return capnp_ts_1.Struct.getList(1, Subarray._Ranges, this); }
    hasRanges() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(1, this)); }
    initRanges(length) { return capnp_ts_1.Struct.initList(1, Subarray._Ranges, length, this); }
    setRanges(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(1, this)); }
    adoptStats(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(2, this)); }
    disownStats() { return capnp_ts_1.Struct.disown(this.getStats()); }
    getStats() { return capnp_ts_1.Struct.getStruct(2, Stats, this); }
    hasStats() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(2, this)); }
    initStats() { return capnp_ts_1.Struct.initStructAt(2, Stats, this); }
    setStats(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(2, this)); }
    toString() { return "Subarray_" + super.toString(); }
}
exports.Subarray = Subarray;
Subarray._capnp = { displayName: "Subarray", id: "da36de34a7124afb", size: new capnp_ts_1.ObjectSize(0, 3) };
class SubarrayPartitioner_PartitionInfo extends capnp_ts_1.Struct {
    adoptSubarray(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(0, this)); }
    disownSubarray() { return capnp_ts_1.Struct.disown(this.getSubarray()); }
    getSubarray() { return capnp_ts_1.Struct.getStruct(0, Subarray, this); }
    hasSubarray() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(0, this)); }
    initSubarray() { return capnp_ts_1.Struct.initStructAt(0, Subarray, this); }
    setSubarray(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(0, this)); }
    getStart() { return capnp_ts_1.Struct.getUint64(0, this); }
    setStart(value) { capnp_ts_1.Struct.setUint64(0, value, this); }
    getEnd() { return capnp_ts_1.Struct.getUint64(8, this); }
    setEnd(value) { capnp_ts_1.Struct.setUint64(8, value, this); }
    getSplitMultiRange() { return capnp_ts_1.Struct.getBit(128, this); }
    setSplitMultiRange(value) { capnp_ts_1.Struct.setBit(128, value, this); }
    toString() { return "SubarrayPartitioner_PartitionInfo_" + super.toString(); }
}
exports.SubarrayPartitioner_PartitionInfo = SubarrayPartitioner_PartitionInfo;
SubarrayPartitioner_PartitionInfo._capnp = { displayName: "PartitionInfo", id: "c195bcd1baa34c68", size: new capnp_ts_1.ObjectSize(24, 1) };
class SubarrayPartitioner_State extends capnp_ts_1.Struct {
    getStart() { return capnp_ts_1.Struct.getUint64(0, this); }
    setStart(value) { capnp_ts_1.Struct.setUint64(0, value, this); }
    getEnd() { return capnp_ts_1.Struct.getUint64(8, this); }
    setEnd(value) { capnp_ts_1.Struct.setUint64(8, value, this); }
    adoptSingleRange(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(0, this)); }
    disownSingleRange() { return capnp_ts_1.Struct.disown(this.getSingleRange()); }
    getSingleRange() { return capnp_ts_1.Struct.getList(0, SubarrayPartitioner_State._SingleRange, this); }
    hasSingleRange() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(0, this)); }
    initSingleRange(length) { return capnp_ts_1.Struct.initList(0, SubarrayPartitioner_State._SingleRange, length, this); }
    setSingleRange(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(0, this)); }
    adoptMultiRange(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(1, this)); }
    disownMultiRange() { return capnp_ts_1.Struct.disown(this.getMultiRange()); }
    getMultiRange() { return capnp_ts_1.Struct.getList(1, SubarrayPartitioner_State._MultiRange, this); }
    hasMultiRange() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(1, this)); }
    initMultiRange(length) { return capnp_ts_1.Struct.initList(1, SubarrayPartitioner_State._MultiRange, length, this); }
    setMultiRange(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(1, this)); }
    toString() { return "SubarrayPartitioner_State_" + super.toString(); }
}
exports.SubarrayPartitioner_State = SubarrayPartitioner_State;
SubarrayPartitioner_State._capnp = { displayName: "State", id: "cbd6edafbf7bb215", size: new capnp_ts_1.ObjectSize(16, 2) };
class SubarrayPartitioner extends capnp_ts_1.Struct {
    adoptSubarray(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(0, this)); }
    disownSubarray() { return capnp_ts_1.Struct.disown(this.getSubarray()); }
    getSubarray() { return capnp_ts_1.Struct.getStruct(0, Subarray, this); }
    hasSubarray() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(0, this)); }
    initSubarray() { return capnp_ts_1.Struct.initStructAt(0, Subarray, this); }
    setSubarray(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(0, this)); }
    adoptBudget(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(1, this)); }
    disownBudget() { return capnp_ts_1.Struct.disown(this.getBudget()); }
    getBudget() { return capnp_ts_1.Struct.getList(1, SubarrayPartitioner._Budget, this); }
    hasBudget() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(1, this)); }
    initBudget(length) { return capnp_ts_1.Struct.initList(1, SubarrayPartitioner._Budget, length, this); }
    setBudget(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(1, this)); }
    adoptCurrent(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(2, this)); }
    disownCurrent() { return capnp_ts_1.Struct.disown(this.getCurrent()); }
    getCurrent() { return capnp_ts_1.Struct.getStruct(2, SubarrayPartitioner_PartitionInfo, this); }
    hasCurrent() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(2, this)); }
    initCurrent() { return capnp_ts_1.Struct.initStructAt(2, SubarrayPartitioner_PartitionInfo, this); }
    setCurrent(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(2, this)); }
    adoptState(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(3, this)); }
    disownState() { return capnp_ts_1.Struct.disown(this.getState()); }
    getState() { return capnp_ts_1.Struct.getStruct(3, SubarrayPartitioner_State, this); }
    hasState() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(3, this)); }
    initState() { return capnp_ts_1.Struct.initStructAt(3, SubarrayPartitioner_State, this); }
    setState(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(3, this)); }
    getMemoryBudget() { return capnp_ts_1.Struct.getUint64(0, this); }
    setMemoryBudget(value) { capnp_ts_1.Struct.setUint64(0, value, this); }
    getMemoryBudgetVar() { return capnp_ts_1.Struct.getUint64(8, this); }
    setMemoryBudgetVar(value) { capnp_ts_1.Struct.setUint64(8, value, this); }
    getMemoryBudgetValidity() { return capnp_ts_1.Struct.getUint64(16, this); }
    setMemoryBudgetValidity(value) { capnp_ts_1.Struct.setUint64(16, value, this); }
    adoptStats(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(4, this)); }
    disownStats() { return capnp_ts_1.Struct.disown(this.getStats()); }
    getStats() { return capnp_ts_1.Struct.getStruct(4, Stats, this); }
    hasStats() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(4, this)); }
    initStats() { return capnp_ts_1.Struct.initStructAt(4, Stats, this); }
    setStats(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(4, this)); }
    toString() { return "SubarrayPartitioner_" + super.toString(); }
}
exports.SubarrayPartitioner = SubarrayPartitioner;
SubarrayPartitioner.PartitionInfo = SubarrayPartitioner_PartitionInfo;
SubarrayPartitioner.State = SubarrayPartitioner_State;
SubarrayPartitioner._capnp = { displayName: "SubarrayPartitioner", id: "98222aaeac2b06c0", size: new capnp_ts_1.ObjectSize(24, 5) };
class ReadState extends capnp_ts_1.Struct {
    getOverflowed() { return capnp_ts_1.Struct.getBit(0, this); }
    setOverflowed(value) { capnp_ts_1.Struct.setBit(0, value, this); }
    getUnsplittable() { return capnp_ts_1.Struct.getBit(1, this); }
    setUnsplittable(value) { capnp_ts_1.Struct.setBit(1, value, this); }
    getInitialized() { return capnp_ts_1.Struct.getBit(2, this); }
    setInitialized(value) { capnp_ts_1.Struct.setBit(2, value, this); }
    adoptSubarrayPartitioner(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(0, this)); }
    disownSubarrayPartitioner() { return capnp_ts_1.Struct.disown(this.getSubarrayPartitioner()); }
    getSubarrayPartitioner() { return capnp_ts_1.Struct.getStruct(0, SubarrayPartitioner, this); }
    hasSubarrayPartitioner() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(0, this)); }
    initSubarrayPartitioner() { return capnp_ts_1.Struct.initStructAt(0, SubarrayPartitioner, this); }
    setSubarrayPartitioner(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(0, this)); }
    toString() { return "ReadState_" + super.toString(); }
}
exports.ReadState = ReadState;
ReadState._capnp = { displayName: "ReadState", id: "910b5afbbc6a0745", size: new capnp_ts_1.ObjectSize(8, 1) };
class ConditionClause extends capnp_ts_1.Struct {
    getFieldName() { return capnp_ts_1.Struct.getText(0, this); }
    setFieldName(value) { capnp_ts_1.Struct.setText(0, value, this); }
    adoptValue(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(1, this)); }
    disownValue() { return capnp_ts_1.Struct.disown(this.getValue()); }
    getValue() { return capnp_ts_1.Struct.getData(1, this); }
    hasValue() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(1, this)); }
    initValue(length) { return capnp_ts_1.Struct.initData(1, length, this); }
    setValue(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(1, this)); }
    getOp() { return capnp_ts_1.Struct.getText(2, this); }
    setOp(value) { capnp_ts_1.Struct.setText(2, value, this); }
    toString() { return "ConditionClause_" + super.toString(); }
}
exports.ConditionClause = ConditionClause;
ConditionClause._capnp = { displayName: "ConditionClause", id: "fa99a0f16eaa03a5", size: new capnp_ts_1.ObjectSize(0, 3) };
class Condition extends capnp_ts_1.Struct {
    adoptClauses(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(0, this)); }
    disownClauses() { return capnp_ts_1.Struct.disown(this.getClauses()); }
    getClauses() { return capnp_ts_1.Struct.getList(0, Condition._Clauses, this); }
    hasClauses() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(0, this)); }
    initClauses(length) { return capnp_ts_1.Struct.initList(0, Condition._Clauses, length, this); }
    setClauses(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(0, this)); }
    adoptClauseCombinationOps(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(1, this)); }
    disownClauseCombinationOps() { return capnp_ts_1.Struct.disown(this.getClauseCombinationOps()); }
    getClauseCombinationOps() { return capnp_ts_1.Struct.getList(1, capnp.TextList, this); }
    hasClauseCombinationOps() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(1, this)); }
    initClauseCombinationOps(length) { return capnp_ts_1.Struct.initList(1, capnp.TextList, length, this); }
    setClauseCombinationOps(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(1, this)); }
    toString() { return "Condition_" + super.toString(); }
}
exports.Condition = Condition;
Condition._capnp = { displayName: "Condition", id: "fb156e2d8b8f4cf3", size: new capnp_ts_1.ObjectSize(0, 2) };
class DomainArray extends capnp_ts_1.Struct {
    adoptInt8(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(0, this)); }
    disownInt8() { return capnp_ts_1.Struct.disown(this.getInt8()); }
    getInt8() { return capnp_ts_1.Struct.getList(0, capnp.Int8List, this); }
    hasInt8() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(0, this)); }
    initInt8(length) { return capnp_ts_1.Struct.initList(0, capnp.Int8List, length, this); }
    setInt8(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(0, this)); }
    adoptUint8(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(1, this)); }
    disownUint8() { return capnp_ts_1.Struct.disown(this.getUint8()); }
    getUint8() { return capnp_ts_1.Struct.getList(1, capnp.Uint8List, this); }
    hasUint8() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(1, this)); }
    initUint8(length) { return capnp_ts_1.Struct.initList(1, capnp.Uint8List, length, this); }
    setUint8(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(1, this)); }
    adoptInt16(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(2, this)); }
    disownInt16() { return capnp_ts_1.Struct.disown(this.getInt16()); }
    getInt16() { return capnp_ts_1.Struct.getList(2, capnp.Int16List, this); }
    hasInt16() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(2, this)); }
    initInt16(length) { return capnp_ts_1.Struct.initList(2, capnp.Int16List, length, this); }
    setInt16(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(2, this)); }
    adoptUint16(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(3, this)); }
    disownUint16() { return capnp_ts_1.Struct.disown(this.getUint16()); }
    getUint16() { return capnp_ts_1.Struct.getList(3, capnp.Uint16List, this); }
    hasUint16() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(3, this)); }
    initUint16(length) { return capnp_ts_1.Struct.initList(3, capnp.Uint16List, length, this); }
    setUint16(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(3, this)); }
    adoptInt32(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(4, this)); }
    disownInt32() { return capnp_ts_1.Struct.disown(this.getInt32()); }
    getInt32() { return capnp_ts_1.Struct.getList(4, capnp.Int32List, this); }
    hasInt32() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(4, this)); }
    initInt32(length) { return capnp_ts_1.Struct.initList(4, capnp.Int32List, length, this); }
    setInt32(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(4, this)); }
    adoptUint32(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(5, this)); }
    disownUint32() { return capnp_ts_1.Struct.disown(this.getUint32()); }
    getUint32() { return capnp_ts_1.Struct.getList(5, capnp.Uint32List, this); }
    hasUint32() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(5, this)); }
    initUint32(length) { return capnp_ts_1.Struct.initList(5, capnp.Uint32List, length, this); }
    setUint32(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(5, this)); }
    adoptInt64(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(6, this)); }
    disownInt64() { return capnp_ts_1.Struct.disown(this.getInt64()); }
    getInt64() { return capnp_ts_1.Struct.getList(6, capnp.Int64List, this); }
    hasInt64() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(6, this)); }
    initInt64(length) { return capnp_ts_1.Struct.initList(6, capnp.Int64List, length, this); }
    setInt64(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(6, this)); }
    adoptUint64(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(7, this)); }
    disownUint64() { return capnp_ts_1.Struct.disown(this.getUint64()); }
    getUint64() { return capnp_ts_1.Struct.getList(7, capnp.Uint64List, this); }
    hasUint64() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(7, this)); }
    initUint64(length) { return capnp_ts_1.Struct.initList(7, capnp.Uint64List, length, this); }
    setUint64(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(7, this)); }
    adoptFloat32(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(8, this)); }
    disownFloat32() { return capnp_ts_1.Struct.disown(this.getFloat32()); }
    getFloat32() { return capnp_ts_1.Struct.getList(8, capnp.Float32List, this); }
    hasFloat32() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(8, this)); }
    initFloat32(length) { return capnp_ts_1.Struct.initList(8, capnp.Float32List, length, this); }
    setFloat32(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(8, this)); }
    adoptFloat64(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(9, this)); }
    disownFloat64() { return capnp_ts_1.Struct.disown(this.getFloat64()); }
    getFloat64() { return capnp_ts_1.Struct.getList(9, capnp.Float64List, this); }
    hasFloat64() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(9, this)); }
    initFloat64(length) { return capnp_ts_1.Struct.initList(9, capnp.Float64List, length, this); }
    setFloat64(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(9, this)); }
    toString() { return "DomainArray_" + super.toString(); }
}
exports.DomainArray = DomainArray;
DomainArray._capnp = { displayName: "DomainArray", id: "bc387f87af7fdffb", size: new capnp_ts_1.ObjectSize(0, 10) };
class MapFloat64_Entry extends capnp_ts_1.Struct {
    getKey() { return capnp_ts_1.Struct.getText(0, this); }
    setKey(value) { capnp_ts_1.Struct.setText(0, value, this); }
    getValue() { return capnp_ts_1.Struct.getFloat64(0, this); }
    setValue(value) { capnp_ts_1.Struct.setFloat64(0, value, this); }
    toString() { return "MapFloat64_Entry_" + super.toString(); }
}
exports.MapFloat64_Entry = MapFloat64_Entry;
MapFloat64_Entry._capnp = { displayName: "Entry", id: "bc6fa37d7f8e67b0", size: new capnp_ts_1.ObjectSize(8, 1) };
class MapFloat64 extends capnp_ts_1.Struct {
    adoptEntries(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(0, this)); }
    disownEntries() { return capnp_ts_1.Struct.disown(this.getEntries()); }
    getEntries() { return capnp_ts_1.Struct.getList(0, MapFloat64._Entries, this); }
    hasEntries() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(0, this)); }
    initEntries(length) { return capnp_ts_1.Struct.initList(0, MapFloat64._Entries, length, this); }
    setEntries(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(0, this)); }
    toString() { return "MapFloat64_" + super.toString(); }
}
exports.MapFloat64 = MapFloat64;
MapFloat64.Entry = MapFloat64_Entry;
MapFloat64._capnp = { displayName: "MapFloat64", id: "a240366668f18d8e", size: new capnp_ts_1.ObjectSize(0, 1) };
class MapUInt64_Entry extends capnp_ts_1.Struct {
    getKey() { return capnp_ts_1.Struct.getText(0, this); }
    setKey(value) { capnp_ts_1.Struct.setText(0, value, this); }
    getValue() { return capnp_ts_1.Struct.getUint64(0, this); }
    setValue(value) { capnp_ts_1.Struct.setUint64(0, value, this); }
    toString() { return "MapUInt64_Entry_" + super.toString(); }
}
exports.MapUInt64_Entry = MapUInt64_Entry;
MapUInt64_Entry._capnp = { displayName: "Entry", id: "977674438c18071e", size: new capnp_ts_1.ObjectSize(8, 1) };
class MapUInt64 extends capnp_ts_1.Struct {
    adoptEntries(value) { capnp_ts_1.Struct.adopt(value, capnp_ts_1.Struct.getPointer(0, this)); }
    disownEntries() { return capnp_ts_1.Struct.disown(this.getEntries()); }
    getEntries() { return capnp_ts_1.Struct.getList(0, MapUInt64._Entries, this); }
    hasEntries() { return !capnp_ts_1.Struct.isNull(capnp_ts_1.Struct.getPointer(0, this)); }
    initEntries(length) { return capnp_ts_1.Struct.initList(0, MapUInt64._Entries, length, this); }
    setEntries(value) { capnp_ts_1.Struct.copyFrom(value, capnp_ts_1.Struct.getPointer(0, this)); }
    toString() { return "MapUInt64_" + super.toString(); }
}
exports.MapUInt64 = MapUInt64;
MapUInt64.Entry = MapUInt64_Entry;
MapUInt64._capnp = { displayName: "MapUInt64", id: "de734faff53aa239", size: new capnp_ts_1.ObjectSize(0, 1) };
class AttributeBufferSize extends capnp_ts_1.Struct {
    getAttribute() { return capnp_ts_1.Struct.getText(0, this); }
    setAttribute(value) { capnp_ts_1.Struct.setText(0, value, this); }
    getOffsetBytes() { return capnp_ts_1.Struct.getUint64(0, this); }
    setOffsetBytes(value) { capnp_ts_1.Struct.setUint64(0, value, this); }
    getDataBytes() { return capnp_ts_1.Struct.getUint64(8, this); }
    setDataBytes(value) { capnp_ts_1.Struct.setUint64(8, value, this); }
    getValidityBytes() { return capnp_ts_1.Struct.getUint64(16, this); }
    setValidityBytes(value) { capnp_ts_1.Struct.setUint64(16, value, this); }
    toString() { return "AttributeBufferSize_" + super.toString(); }
}
exports.AttributeBufferSize = AttributeBufferSize;
AttributeBufferSize._capnp = { displayName: "AttributeBufferSize", id: "e8c3366db226bb6a", size: new capnp_ts_1.ObjectSize(24, 1) };
Query._AttributeBufferHeaders = capnp.CompositeList(AttributeBufferHeader);
FilterPipeline._Filters = capnp.CompositeList(Filter);
Config._Entries = capnp.CompositeList(KV);
Subarray._Ranges = capnp.CompositeList(SubarrayRanges);
SubarrayPartitioner_State._SingleRange = capnp.CompositeList(Subarray);
SubarrayPartitioner_State._MultiRange = capnp.CompositeList(Subarray);
SubarrayPartitioner._Budget = capnp.CompositeList(AttributeBufferSize);
Condition._Clauses = capnp.CompositeList(ConditionClause);
MapFloat64._Entries = capnp.CompositeList(MapFloat64_Entry);
MapUInt64._Entries = capnp.CompositeList(MapUInt64_Entry);
//# sourceMappingURL=query_capnp.js.map

/***/ }),

/***/ "./node_modules/@tiledb-inc/tiledb-cloud/lib/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@tiledb-inc/tiledb-cloud/lib/index.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* tslint:disable */
/* eslint-disable */
/**
 * TileDB Storage Platform API
 * TileDB Storage Platform REST API
 *
 * The version of the OpenAPI document: 2.2.19
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.v2 = exports.v1 = void 0;
exports.v1 = __importStar(__webpack_require__(/*! ./v1 */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/v1/index.js"));
exports.v2 = __importStar(__webpack_require__(/*! ./v2 */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/v2/index.js"));
__exportStar(__webpack_require__(/*! ./utils/capnpDeSerializer */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/capnpDeSerializer.js"), exports);
__exportStar(__webpack_require__(/*! ./TileDBQuery/TileDBQuery */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/TileDBQuery/TileDBQuery.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/attributeValuesToArrayBuffers.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/attributeValuesToArrayBuffers.js ***!
  \******************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const dataToArrayBuffer_1 = __importDefault(__webpack_require__(/*! ./dataToArrayBuffer */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/dataToArrayBuffer.js"));
const v2_1 = __webpack_require__(/*! ../v2 */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/v2/index.js");
const mapToBigIntIfNeeded_1 = __importDefault(__webpack_require__(/*! ./mapToBigIntIfNeeded */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/mapToBigIntIfNeeded.js"));
const attributeValuesToArrayBuffers = (values, dimensions, attributes) => {
    const data = {};
    const dimensionsAndAttributes = [...dimensions, ...attributes];
    for (let [attrName, attribute] of Object.entries(values)) {
        const selectedSchema = dimensionsAndAttributes.find((attr) => attr.name === attrName);
        const { type } = selectedSchema;
        const { validity = [], offsets = [], values = [] } = attribute;
        data[attrName] = {
            offsetsBuffer: dataToArrayBuffer_1.default(mapToBigIntIfNeeded_1.default(offsets, v2_1.Datatype.Uint64), v2_1.Datatype.Uint64),
            valuesBuffer: dataToArrayBuffer_1.default(mapToBigIntIfNeeded_1.default(values, type), type),
            validityBuffer: dataToArrayBuffer_1.default(validity, v2_1.Datatype.Uint8),
        };
    }
    return data;
};
exports["default"] = attributeValuesToArrayBuffers;
//# sourceMappingURL=attributeValuesToArrayBuffers.js.map

/***/ }),

/***/ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/bufferToData.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/bufferToData.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bufferToUTF32 = exports.bufferToUTF16 = exports.bufferToAscii = exports.bufferToString = exports.bufferToFloat64 = exports.bufferToFloat32 = exports.bufferToInt64 = exports.bufferToUint64 = exports.bufferToInt32 = exports.bufferToInt16 = exports.bufferToUint32 = exports.bufferToUint16 = exports.bufferToUint8 = exports.bufferToInt8 = void 0;
const v2_1 = __webpack_require__(/*! ../v2 */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/v2/index.js");
const mapToBigIntIfNeeded_1 = __webpack_require__(/*! ./mapToBigIntIfNeeded */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/mapToBigIntIfNeeded.js");
const typedArrayToArray_1 = __importDefault(__webpack_require__(/*! ./typedArrayToArray */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/typedArrayToArray.js"));
const bufferToInt8 = (arrayBuffer) => new Int8Array(arrayBuffer);
exports.bufferToInt8 = bufferToInt8;
const bufferToUint8 = (arrayBuffer) => new Uint8Array(arrayBuffer);
exports.bufferToUint8 = bufferToUint8;
const bufferToUint16 = (arrayBuffer) => new Uint16Array(arrayBuffer);
exports.bufferToUint16 = bufferToUint16;
const bufferToUint32 = (arrayBuffer) => new Uint32Array(arrayBuffer);
exports.bufferToUint32 = bufferToUint32;
const bufferToInt16 = (arrayBuffer) => new Int16Array(arrayBuffer);
exports.bufferToInt16 = bufferToInt16;
const bufferToInt32 = (arrayBuffer) => new Int32Array(arrayBuffer);
exports.bufferToInt32 = bufferToInt32;
const bufferToUint64 = (arrayBuffer) => new BigUint64Array(arrayBuffer);
exports.bufferToUint64 = bufferToUint64;
const bufferToInt64 = (arrayBuffer) => new BigInt64Array(arrayBuffer);
exports.bufferToInt64 = bufferToInt64;
const bufferToFloat32 = (arrayBuffer) => new Float32Array(arrayBuffer);
exports.bufferToFloat32 = bufferToFloat32;
const bufferToFloat64 = (arrayBuffer) => new Float64Array(arrayBuffer);
exports.bufferToFloat64 = bufferToFloat64;
const bufferToString = (arrayBuffer) => {
    const utf8decoder = new TextDecoder();
    return utf8decoder.decode(arrayBuffer);
};
exports.bufferToString = bufferToString;
const bufferToAscii = (arrayBuffer) => {
    const utf8decoder = new TextDecoder("ascii");
    return utf8decoder.decode(arrayBuffer);
};
exports.bufferToAscii = bufferToAscii;
const bufferToUTF16 = (arrayBuffer) => {
    const utf8decoder = new TextDecoder("utf-16");
    return utf8decoder.decode(arrayBuffer);
};
exports.bufferToUTF16 = bufferToUTF16;
const bufferToUTF32 = (arrayBuffer) => {
    const view = new DataView(arrayBuffer, 0, arrayBuffer.byteLength);
    let result = "";
    for (let i = 0; i < arrayBuffer.byteLength; i += 4) {
        result += String.fromCodePoint(view.getInt32(i, true));
    }
    return result;
};
exports.bufferToUTF32 = bufferToUTF32;
/**
 * Convert an ArrayBuffer to its corresponding type
 */
const bufferToData = (arrayBuffer, type) => {
    if (type === v2_1.Datatype.Int32) {
        return typedArrayToArray_1.default(exports.bufferToInt32(arrayBuffer));
    }
    else if (type === v2_1.Datatype.Uint64) {
        return typedArrayToArray_1.default(exports.bufferToUint64(arrayBuffer));
    }
    else if (type === v2_1.Datatype.Int64) {
        return typedArrayToArray_1.default(exports.bufferToInt64(arrayBuffer));
    }
    else if (type === v2_1.Datatype.Float32) {
        return typedArrayToArray_1.default(exports.bufferToFloat32(arrayBuffer));
    }
    else if (type === v2_1.Datatype.Float64) {
        return typedArrayToArray_1.default(exports.bufferToFloat64(arrayBuffer));
    }
    else if (type === v2_1.Datatype.Char) {
        const charCodes = typedArrayToArray_1.default(exports.bufferToUint8(arrayBuffer));
        return String.fromCharCode(...charCodes);
    }
    else if (type === v2_1.Datatype.Int8) {
        return typedArrayToArray_1.default(exports.bufferToInt8(arrayBuffer));
    }
    else if (type === v2_1.Datatype.Uint8) {
        return typedArrayToArray_1.default(exports.bufferToUint8(arrayBuffer));
    }
    else if (type === v2_1.Datatype.Int16) {
        return typedArrayToArray_1.default(exports.bufferToInt16(arrayBuffer));
    }
    else if (type === v2_1.Datatype.Uint16) {
        return typedArrayToArray_1.default(exports.bufferToUint16(arrayBuffer));
    }
    else if (type === v2_1.Datatype.Uint32) {
        return typedArrayToArray_1.default(exports.bufferToUint32(arrayBuffer));
    }
    else if (type === v2_1.Datatype.StringAscii) {
        return exports.bufferToAscii(arrayBuffer);
    }
    else if (type === v2_1.Datatype.StringUtf8) {
        return exports.bufferToString(arrayBuffer);
    }
    else if (type === v2_1.Datatype.StringUtf16) {
        return exports.bufferToUTF16(arrayBuffer);
    }
    else if (type === v2_1.Datatype.StringUtf32) {
        return exports.bufferToUTF32(arrayBuffer);
    }
    else if (type === v2_1.Datatype.StringUcs2) {
        return exports.bufferToUTF16(arrayBuffer);
    }
    else if (type === v2_1.Datatype.StringUcs4) {
        return exports.bufferToUTF32(arrayBuffer);
    }
    else if (mapToBigIntIfNeeded_1.int64Types.includes(type)) {
        return typedArrayToArray_1.default(exports.bufferToInt64(arrayBuffer));
    }
    return arrayBuffer;
};
exports["default"] = bufferToData;
//# sourceMappingURL=bufferToData.js.map

/***/ }),

/***/ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/capnpDeSerializer.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/capnpDeSerializer.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deserializeCapnp = exports.DeserializableType = void 0;
const capnp = __importStar(__webpack_require__(/*! capnp-ts */ "./node_modules/capnp-ts/lib/index.js"));
const arrayMetadata_capnp_1 = __webpack_require__(/*! ../capnp/arrayMetadata_capnp */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/capnp/arrayMetadata_capnp.js");
const capnpQueryDeSerializer_1 = __importDefault(__webpack_require__(/*! ./capnpQueryDeSerializer */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/capnpQueryDeSerializer.js"));
var DeserializableType;
(function (DeserializableType) {
    DeserializableType[DeserializableType["arrayMetadata"] = 0] = "arrayMetadata";
    DeserializableType[DeserializableType["query"] = 1] = "query";
})(DeserializableType = exports.DeserializableType || (exports.DeserializableType = {}));
const deserializeCapnp = (data, type) => {
    if (!isArrayBuffer(data)) {
        throw new Error(`Data is not of type ArrayBuffer`);
    }
    if (type === DeserializableType.query) {
        return capnpQueryDeSerializer_1.default(data);
    }
    if (type === DeserializableType.arrayMetadata) {
        return capnpArrayMetadaDeSerializer(data);
    }
};
exports.deserializeCapnp = deserializeCapnp;
const capnpArrayMetadaDeSerializer = (buffer) => {
    const message = new capnp.Message(buffer, false);
    const arrayMetadata = message.getRoot(arrayMetadata_capnp_1.ArrayMetadata);
    const entries = arrayMetadata.getEntries().map((entry) => {
        const value = entry.getValue().toArray();
        return {
            value,
            del: entry.getDel(),
            key: entry.getKey(),
            type: entry.getType(),
            valueNum: entry.getValueNum(),
        };
    });
    return { entries };
};
const isArrayBuffer = (data) => {
    if (data && data.byteLength && data.slice) {
        return true;
    }
    return false;
};
//# sourceMappingURL=capnpDeSerializer.js.map

/***/ }),

/***/ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/capnpQueryDeSerializer.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/capnpQueryDeSerializer.js ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deserializeMapUInt64 = exports.deserializeMapFloat64 = exports.deserializeStats = exports.deserializeSubarray = exports.deserializeDomainArray = exports.deserializeWrite = exports.deserializeQueryReader = exports.deserializeConfig = exports.deserializeArray = void 0;
const query_capnp_1 = __webpack_require__(/*! ../capnp/query_capnp */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/capnp/query_capnp.js");
const capnp = __importStar(__webpack_require__(/*! capnp-ts */ "./node_modules/capnp-ts/lib/index.js"));
/**
 * Deserializes an ArrayBuffer to a Query object
 * @param buffer ArrayBuffer of the capnp Query object
 * @returns Query object
 */
const capnpQueryDeSerializer = (buffer) => {
    const message = new capnp.Message(buffer, false);
    const query = message.getRoot(query_capnp_1.Query);
    return {
        attributeBufferHeaders: deserializeAttributeBufferHeaders(query),
        layout: query.getLayout(),
        status: query.getStatus(),
        type: query.getType(),
        writer: exports.deserializeWrite(query),
        reader: exports.deserializeQueryReader(query.getReader()),
        array: exports.deserializeArray(query.getArray()),
        totalFixedLengthBufferBytes: query
            .getTotalFixedLengthBufferBytes()
            .toNumber(),
        totalVarLenBufferBytes: query
            .getTotalVarLenBufferBytes()
            .toNumber(),
        totalValidityBufferBytes: query
            .getTotalValidityBufferBytes()
            .toNumber(),
        varOffsetsMode: query.getVarOffsetsMode(),
        varOffsetsAddExtraElement: query.getVarOffsetsAddExtraElement(),
        varOffsetsBitsize: query.getVarOffsetsBitsize(),
        config: exports.deserializeConfig(query.getConfig()),
        stats: exports.deserializeStats(query.getStats()),
    };
};
exports["default"] = capnpQueryDeSerializer;
const deserializeArray = (arr) => {
    return {
        endTimestamp: arr.getEndTimestamp().toNumber(),
        queryType: arr.getQueryType(),
        uri: arr.getUri(),
        startTimestamp: arr.getStartTimestamp().toNumber(),
    };
};
exports.deserializeArray = deserializeArray;
const deserializeConfig = (config) => {
    const entries = config.getEntries().map((entry) => ({
        key: entry.getKey(),
        value: entry.getValue(),
    }));
    return { entries };
};
exports.deserializeConfig = deserializeConfig;
const deserializeQueryReader = (reader) => {
    return {
        layout: reader.getLayout(),
        subarray: exports.deserializeSubarray(reader.getSubarray()),
        readState: deserializeReadState(reader.getReadState()),
        condition: deserializeCondition(reader.getCondition()),
        stats: exports.deserializeStats(reader.getStats()),
    };
};
exports.deserializeQueryReader = deserializeQueryReader;
const deserializeCondition = (condition) => {
    return {
        clauses: condition.getClauses().map(deserializeConditionClause),
        clauseCombinationOps: condition
            .getClauseCombinationOps()
            .map((op) => op.toString()),
    };
};
const deserializeConditionClause = (conditionClause) => {
    return {
        fieldName: conditionClause.getFieldName(),
        // TODO: What kind of Data type? Is it an array of numbers?
        value: conditionClause.getValue().toArray(),
        op: conditionClause.getOp(),
    };
};
const deserializeReadState = (readState) => {
    return {
        overflowed: readState.getOverflowed(),
        unsplittable: readState.getUnsplittable(),
        initialized: readState.getInitialized(),
        subarrayPartitioner: deserializeSubarrayPartitioner(readState.getSubarrayPartitioner()),
    };
};
const deserializeSubarrayPartitioner = (subArrayPartitioner) => {
    return {
        subarray: exports.deserializeSubarray(subArrayPartitioner.getSubarray()),
        budget: deserializeAttributeBufferSize(subArrayPartitioner.getBudget()),
        current: deserializeSubarrayPartitionerPartitionInfo(subArrayPartitioner.getCurrent()),
        state: deserializeSubarrayPartitionerState(subArrayPartitioner.getState()),
        memoryBudget: subArrayPartitioner
            .getMemoryBudget().toNumber(),
        memoryBudgetVar: subArrayPartitioner
            .getMemoryBudgetVar().toNumber(),
        memoryBudgetValidity: subArrayPartitioner
            .getMemoryBudgetValidity().toNumber(),
        stats: exports.deserializeStats(subArrayPartitioner.getStats()),
    };
};
const deserializeSubarrayPartitionerState = (partitionerState) => {
    return {
        start: partitionerState.getStart().toNumber(),
        end: partitionerState.getEnd().toNumber(),
        singleRange: partitionerState
            .getSingleRange()
            .map((singleRange) => exports.deserializeSubarray(singleRange)),
        multiRange: partitionerState
            .getMultiRange()
            .map((singleRange) => exports.deserializeSubarray(singleRange)),
    };
};
const deserializeSubarrayPartitionerPartitionInfo = (partitionInfo) => {
    return {
        subarray: exports.deserializeSubarray(partitionInfo.getSubarray()),
        start: partitionInfo.getStart().toNumber(),
        end: partitionInfo.getEnd().toNumber(),
        splitMultiRange: partitionInfo.getSplitMultiRange(),
    };
};
const deserializeAttributeBufferSize = (attrBufferSizeList) => {
    return attrBufferSizeList.map((attr) => ({
        attribute: attr.getAttribute(),
    }));
};
const deserializeAttributeBufferHeaders = (query) => {
    return query.getAttributeBufferHeaders().map((attrBufferHeader) => {
        return {
            name: attrBufferHeader.getName(),
            fixedLenBufferSizeInBytes: attrBufferHeader
                .getFixedLenBufferSizeInBytes().toNumber(),
            varLenBufferSizeInBytes: attrBufferHeader
                .getVarLenBufferSizeInBytes().toNumber(),
            validityLenBufferSizeInBytes: attrBufferHeader
                .getValidityLenBufferSizeInBytes().toNumber(),
            originalFixedLenBufferSizeInBytes: attrBufferHeader
                .getOriginalFixedLenBufferSizeInBytes().toNumber(),
            originalVarLenBufferSizeInBytes: attrBufferHeader
                .getOriginalVarLenBufferSizeInBytes().toNumber(),
            originalValidityLenBufferSizeInBytes: attrBufferHeader
                .getOriginalValidityLenBufferSizeInBytes().toNumber(),
        };
    });
};
const deserializeWrite = (query) => {
    const writer = query.getWriter();
    return {
        checkCoordDups: writer.getCheckCoordDups(),
        checkCoordOOB: writer.getCheckCoordOOB(),
        dedupCoords: writer.getDedupCoords(),
        subarray: exports.deserializeDomainArray(writer.getSubarray()),
        subarrayRanges: exports.deserializeSubarray(writer.getSubarrayRanges()),
        stats: exports.deserializeStats(writer.getStats()),
    };
};
exports.deserializeWrite = deserializeWrite;
const deserializeDomainArray = (domainArray) => {
    return {
        int8: domainArray.getInt8().toArray(),
        uint8: domainArray.getUint8().toArray(),
        int16: domainArray.getInt16().toArray(),
        uint16: domainArray.getUint16().toArray(),
        int32: domainArray.getInt32().toArray(),
        uint32: domainArray.getUint32().toArray(),
        int64: domainArray.getInt64().toArray(),
        uint64: domainArray.getUint64().toArray(),
        float32: domainArray.getFloat32().toArray(),
        float64: domainArray.getFloat64().toArray(),
    };
};
exports.deserializeDomainArray = deserializeDomainArray;
const deserializeSubarray = (subArray) => {
    return ({
        layout: subArray.getLayout(),
        stats: exports.deserializeStats(subArray.getStats()),
        ranges: subArray.getRanges().map((range) => {
            const type = range.getType();
            const bufferSizes = range
                .getBufferSizes()
                .map((uint64) => uint64.toNumber());
            return {
                type,
                hasDefaultRange: range.getHasDefaultRange(),
                buffer: range.getBuffer().toArray(),
                bufferSizes: bufferSizes,
                bufferStartSizes: range
                    .getBufferStartSizes()
                    .map((uint64) => uint64.toNumber()),
            };
        })
    });
};
exports.deserializeSubarray = deserializeSubarray;
const deserializeStats = (stats) => {
    return {
        timers: exports.deserializeMapFloat64(stats.getTimers()),
        counters: exports.deserializeMapUInt64(stats.getCounters()),
    };
};
exports.deserializeStats = deserializeStats;
const deserializeMapFloat64 = (mapFloat64) => {
    return mapFloat64.getEntries().map((entry) => {
        return {
            key: entry.getKey(),
            value: entry.getValue(),
        };
    });
};
exports.deserializeMapFloat64 = deserializeMapFloat64;
const deserializeMapUInt64 = (mapUint64) => {
    return mapUint64.getEntries().map((entry) => {
        return {
            key: entry.getKey(),
            value: entry.getValue().toNumber(),
        };
    });
};
exports.deserializeMapUInt64 = deserializeMapUInt64;
//# sourceMappingURL=capnpQueryDeSerializer.js.map

/***/ }),

/***/ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/capnpQuerySerializer.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/capnpQuerySerializer.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const query_capnp_1 = __webpack_require__(/*! ../capnp/query_capnp */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/capnp/query_capnp.js");
const capnp = __importStar(__webpack_require__(/*! capnp-ts */ "./node_modules/capnp-ts/lib/index.js"));
/**
 * Serialize the Query object to capnp
 * @param data Query javascript object
 * @returns ArrayBuffer of the capnp Query object
 */
const capnpQuerySerializer = (data) => {
    const message = new capnp.Message();
    const queryData = message.initRoot(query_capnp_1.Query);
    const { reader = {}, writer = {}, array = {}, attributeBufferHeaders = [], layout = "", status = "", type = "", } = data;
    queryData.setLayout(layout);
    queryData.setStatus(status);
    queryData.setType(type);
    queryData.setTotalFixedLengthBufferBytes(capnp.Uint64.fromNumber(data.totalFixedLengthBufferBytes));
    queryData.setTotalVarLenBufferBytes(capnp.Uint64.fromNumber(data.totalVarLenBufferBytes));
    queryData.setTotalValidityBufferBytes(capnp.Uint64.fromNumber(data.totalValidityBufferBytes));
    queryData.setVarOffsetsMode("bytes");
    queryData.setVarOffsetsAddExtraElement(false);
    queryData.setVarOffsetsBitsize(64);
    const attrBuffers = queryData.initAttributeBufferHeaders(attributeBufferHeaders.length);
    attributeBufferHeaders.forEach((attrHeader, i) => {
        const attrBufferHeader = attrBuffers.get(i);
        attrBufferHeader.setName(attrHeader.name);
        attrBufferHeader.setFixedLenBufferSizeInBytes(capnp.Uint64.fromNumber(attrHeader.fixedLenBufferSizeInBytes));
        attrBufferHeader.setValidityLenBufferSizeInBytes(capnp.Uint64.fromNumber(attrHeader.validityLenBufferSizeInBytes));
        attrBufferHeader.setVarLenBufferSizeInBytes(capnp.Uint64.fromNumber(attrHeader.varLenBufferSizeInBytes));
        const { originalFixedLenBufferSizeInBytes = 0, originalVarLenBufferSizeInBytes = 0, originalValidityLenBufferSizeInBytes = 0, } = attrHeader;
        attrBufferHeader.setOriginalFixedLenBufferSizeInBytes(capnp.Uint64.fromNumber(originalFixedLenBufferSizeInBytes));
        attrBufferHeader.setOriginalVarLenBufferSizeInBytes(capnp.Uint64.fromNumber(originalVarLenBufferSizeInBytes));
        attrBufferHeader.setOriginalValidityLenBufferSizeInBytes(capnp.Uint64.fromNumber(originalValidityLenBufferSizeInBytes));
    });
    if (writer) {
        const { subarrayRanges = {}, subarray = {} } = writer;
        const queryWriter = queryData.initWriter();
        queryWriter.setCheckCoordDups(writer.checkCoordDups);
        queryWriter.setCheckCoordOOB(writer.checkCoordOOB);
        queryWriter.setDedupCoords(writer.dedupCoords);
        const writerSubArray = queryWriter.initSubarrayRanges();
        serializeSubArray(writerSubArray, subarrayRanges);
        const writerDomain = queryWriter.initSubarray();
        serializeDomainArray(writerDomain, subarray);
    }
    if (reader) {
        const queryReader = queryData.initReader();
        const subArrayCap = queryReader.initSubarray();
        const { subarray: subarrayData = {}, readState = {}, layout = "" } = reader;
        serializeSubArray(subArrayCap, subarrayData);
        queryReader.setLayout(layout);
        const readStateData = queryReader.initReadState();
        readStateData.setOverflowed(readState.overflowed);
        readStateData.setUnsplittable(readState.unsplittable);
        readStateData.setInitialized(readState.initialized);
        // subarrayPartitioner
        const { subarrayPartitioner = {} } = readState;
        const { budget = [], subarray = {}, current = {}, state = {}, memoryBudget = 0, memoryBudgetVar = 0, } = subarrayPartitioner;
        const subPartitioner = readStateData.initSubarrayPartitioner();
        subPartitioner.setMemoryBudget(capnp.Uint64.fromNumber(memoryBudget));
        subPartitioner.setMemoryBudgetVar(capnp.Uint64.fromNumber(memoryBudgetVar));
        // TODO: fix type
        // subPartitioner.setMemoryBudgetValidity(capnp.Uint64.fromNumber(0));
        const budgetData = subPartitioner.initBudget(budget.length);
        // subarrayPartitioner.Buget
        budget.forEach((b, i) => {
            const singleBudget = budgetData.get(i);
            singleBudget.setAttribute(b.attribute);
        });
        // subarrayPartitioner.Subarray
        const subArrayData = subPartitioner.initSubarray();
        serializeSubArray(subArrayData, subarray);
        // subarrayPartitioner.Current
        const currentData = subPartitioner.initCurrent();
        currentData.setSplitMultiRange(current.splitMultiRange);
        currentData.setStart(capnp.Uint64.fromNumber(current.start || 0));
        currentData.setEnd(capnp.Uint64.fromNumber(current.end || 0));
        const currentSubarray = currentData.initSubarray();
        serializeSubArray(currentSubarray, current.subarray || {});
        // subarrayPartitioner.State
        const capSubPartitionerState = subPartitioner.initState();
        capSubPartitionerState.setStart(capnp.Uint64.fromNumber(state.start || 0));
        capSubPartitionerState.setEnd(capnp.Uint64.fromNumber(state.end || 0));
        const multiRange = state.multiRange || [];
        const singleRange = state.singleRange || [];
        const capSubPartitionerStateMultiRange = capSubPartitionerState.initMultiRange(multiRange.length);
        const capSubPartitionerStateSingleRange = capSubPartitionerState.initSingleRange(singleRange.length);
        multiRange.forEach((mRange, i) => {
            const capMultiRange = capSubPartitionerStateMultiRange.get(i);
            serializeSubArray(capMultiRange, mRange);
        });
        singleRange.forEach((sRange, i) => {
            const capSingleRange = capSubPartitionerStateSingleRange.get(i);
            serializeSubArray(capSingleRange, sRange);
        });
    }
    if (array) {
        const queryArray = queryData.initArray();
        const startTimeStamp = clamp(array.startTimestamp || 0, 0, Date.now());
        queryArray.setStartTimestamp(capnp.Uint64.fromNumber(startTimeStamp));
        const endTimeStamp = clamp(array.endTimestamp || Date.now(), 0, Date.now());
        queryArray.setEndTimestamp(capnp.Uint64.fromNumber(endTimeStamp));
        queryArray.setQueryType(array.queryType || "");
        queryArray.setUri(array.uri || "");
    }
    return message.toArrayBuffer();
};
const add = (a, b) => a + b;
exports["default"] = capnpQuerySerializer;
const serializeDomainArray = (domainArray, data) => {
    const { float32 = [], float64 = [], int8 = [], int16 = [], int32 = [], int64 = [], uint8 = [], uint16 = [], uint32 = [], uint64 = [] } = data;
    const dFloat32 = domainArray.initFloat32(float32.length);
    float32.forEach((num, i) => {
        dFloat32.set(i, num);
    });
    const dFloat64 = domainArray.initFloat64(float64.length);
    float64.forEach((num, i) => {
        dFloat64.set(i, num);
    });
    const dInt8 = domainArray.initInt8(int8.length);
    int8.forEach((num, i) => {
        dInt8.set(i, num);
    });
    const dInt16 = domainArray.initInt16(int16.length);
    int16.forEach((num, i) => {
        dInt16.set(i, num);
    });
    const dInt32 = domainArray.initInt32(int32.length);
    int32.forEach((num, i) => {
        dInt32.set(i, num);
    });
    const dInt64 = domainArray.initInt64(int64.length);
    int64.forEach((num, i) => {
        dInt64.set(i, capnp.Int64.fromNumber(num));
    });
    const dUint8 = domainArray.initUint8(uint8.length);
    uint8.forEach((num, i) => {
        dUint8.set(i, num);
    });
    const dUint16 = domainArray.initUint16(uint16.length);
    uint16.forEach((num, i) => {
        dUint16.set(i, num);
    });
    const dUint32 = domainArray.initUint32(uint32.length);
    uint32.forEach((num, i) => {
        dUint32.set(i, num);
    });
    const dUint64 = domainArray.initUint64(uint64.length);
    uint64.forEach((num, i) => {
        dUint64.set(i, capnp.Uint64.fromNumber(num));
    });
};
const serializeSubArray = (capSubArray, subArray) => {
    const { ranges = [], layout = "" } = subArray;
    capSubArray.setLayout(layout);
    const capRanges = capSubArray.initRanges(ranges.length);
    ranges.forEach((range, i) => {
        const r = capRanges.get(i);
        const bufferSizesArray = range.bufferSizes || [];
        r.setType(range.type);
        r.setHasDefaultRange(range.hasDefaultRange);
        const totalBufferSize = bufferSizesArray.reduce(add);
        const bufferData = r.initBuffer(totalBufferSize);
        const view = Uint8Array.from(range.buffer);
        bufferData.copyBuffer(view);
        r.setBuffer(bufferData);
        const bufferSizes = r.initBufferSizes(bufferSizesArray.length);
        bufferSizesArray.forEach((bsize, i) => {
            bufferSizes.set(i, capnp.Uint64.fromNumber(bsize));
        });
        r.setBufferSizes(bufferSizes);
        const bufferStartSizesArray = range.bufferStartSizes || [];
        const bufferStartSizes = r.initBufferStartSizes(bufferStartSizesArray.length);
        bufferStartSizesArray.forEach((bsize, i) => {
            bufferStartSizes.set(i, capnp.Uint64.fromNumber(bsize));
        });
        r.setBufferStartSizes(bufferStartSizes);
    });
};
const clamp = (num, min, max) => Math.min(Math.max(num, min), max);
//# sourceMappingURL=capnpQuerySerializer.js.map

/***/ }),

/***/ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/capnpSerializer.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/capnpSerializer.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const arrayMetadata_capnp_1 = __webpack_require__(/*! ../capnp/arrayMetadata_capnp */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/capnp/arrayMetadata_capnp.js");
const capnp = __importStar(__webpack_require__(/*! capnp-ts */ "./node_modules/capnp-ts/lib/index.js"));
const capnpQuerySerializer_1 = __importDefault(__webpack_require__(/*! ./capnpQuerySerializer */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/capnpQuerySerializer.js"));
const capnpSerializer = (data) => {
    if (isArrayMetadata(data)) {
        return serializeArrayMetadata(data);
    }
    else if (isQuerydata(data)) {
        return capnpQuerySerializer_1.default(data);
    }
    return data;
};
exports["default"] = capnpSerializer;
const serializeArrayMetadata = (data) => {
    const entriesLength = data.entries.length;
    const message = new capnp.Message();
    const metadata = message.initRoot(arrayMetadata_capnp_1.ArrayMetadata);
    const entries = metadata.initEntries(entriesLength);
    data.entries.forEach((entryData, i) => {
        const entry = entries.get(i);
        entry.setKey(entryData.key);
        entry.setType(entryData.type);
        entry.setValueNum(entryData.valueNum);
        const valueLength = entryData.value.length;
        const data = entry.initValue(valueLength);
        const arrBuffer = new ArrayBuffer(valueLength);
        const view = new Uint8Array(arrBuffer);
        entryData.value.forEach((num, i) => {
            view[i] = num;
        });
        data.copyBuffer(view);
        entry.setValue(data);
        entry.setDel(entryData.del);
    });
    return message.toArrayBuffer();
};
const isArrayMetadata = (data) => {
    if (data && Array.isArray(data.entries)) {
        return true;
    }
    return false;
};
const isQuerydata = (data) => {
    if (data && (data.reader || data.writer)) {
        return true;
    }
    return false;
};
//# sourceMappingURL=capnpSerializer.js.map

/***/ }),

/***/ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/concatArrayBuffers.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/concatArrayBuffers.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const concatArrayBuffers = (...buffers) => {
    const result = new Uint8Array(buffers.reduce((totalSize, buf) => totalSize + buf.byteLength, 0));
    buffers.reduce((offset, buf) => {
        result.set(new Uint8Array(buf), offset);
        return offset + buf.byteLength;
    }, 0);
    return result.buffer;
};
exports["default"] = concatArrayBuffers;
//# sourceMappingURL=concatArrayBuffers.js.map

/***/ }),

/***/ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/dataToArrayBuffer.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/dataToArrayBuffer.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const v2_1 = __webpack_require__(/*! ../v2 */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/v2/index.js");
const getTypedArrayFromDataType_1 = __importDefault(__webpack_require__(/*! ./getTypedArrayFromDataType */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/getTypedArrayFromDataType.js"));
const dataToArrayBuffer = (data = [], type) => {
    if (!data.length) {
        return new ArrayBuffer(0);
    }
    const TypedArray = getTypedArrayFromDataType_1.default(type);
    if (TypedArray) {
        const typedArray = TypedArray.from(data);
        return typedArray.buffer;
    }
    else if (type === v2_1.Datatype.StringAscii || type === v2_1.Datatype.Char) {
        // If it's an array of CHARs join them together to a single string
        const str = Array.isArray(data) ? data.join('') : data;
        const textEncoder = new TextEncoder();
        return textEncoder.encode(str).buffer;
    }
    else if (type === v2_1.Datatype.StringUtf8) {
        // If it's an array of CHARs join them together to a single string
        const str = Array.isArray(data) ? data.join('') : data;
        const textEncoder = new TextEncoder();
        return textEncoder.encode(str).buffer;
    }
    else if (type === v2_1.Datatype.StringUtf16) {
        // If it's an array of CHARs join them together to a single string
        const str = Array.isArray(data) ? data.join('') : data;
        return utf16StrToArrayBuffer(str);
    }
    else if (type === v2_1.Datatype.StringUtf32) {
        // If it's an array of CHARs join them together to a single string
        const str = Array.isArray(data) ? data.join('') : data;
        return utf32StrToArrayBuffer(str);
    }
    else if (type === v2_1.Datatype.StringUcs2) {
        // If it's an array of CHARs join them together to a single string
        const str = Array.isArray(data) ? data.join('') : data;
        return utf16StrToArrayBuffer(str);
    }
    else if (type === v2_1.Datatype.StringUcs4) {
        // If it's an array of CHARs join them together to a single string
        const str = Array.isArray(data) ? data.join('') : data;
        return utf32StrToArrayBuffer(str);
    }
};
exports["default"] = dataToArrayBuffer;
function utf16StrToArrayBuffer(str) {
    var buf = new ArrayBuffer(str.length * 2); // 2 bytes for each char
    var bufView = new Uint16Array(buf);
    for (var i = 0, strLen = str.length; i < strLen; i++) {
        bufView[i] = str.charCodeAt(i);
    }
    return buf;
}
function utf32StrToArrayBuffer(str) {
    var buf = new ArrayBuffer(str.length * 4); // 4 bytes for each char
    var bufView = new Uint32Array(buf);
    for (var i = 0, strLen = str.length; i < strLen; i++) {
        bufView[i] = str.charCodeAt(i);
    }
    return buf;
}
//# sourceMappingURL=dataToArrayBuffer.js.map

/***/ }),

/***/ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/dataToQuery.js":
/*!************************************************************************!*\
  !*** ./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/dataToQuery.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const v2_1 = __webpack_require__(/*! ../v2 */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/v2/index.js");
const getRanges_1 = __importDefault(__webpack_require__(/*! ./getRanges */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/getRanges.js"));
const getByteLengthOfDatatype_1 = __importDefault(__webpack_require__(/*! ./getByteLengthOfDatatype */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/getByteLengthOfDatatype.js"));
const emptyRangesToDomain_1 = __importDefault(__webpack_require__(/*! ./emptyRangesToDomain */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/emptyRangesToDomain.js"));
const createAttributeBufferHeaders = (attributes, bufferSize) => {
    const MAX_BYTES_PER_ELEMENT_OF_ATTRIBUTES = attributes.reduce((accum, attr) => accum + getMaxByteSizeOfAttribute(attr), 0);
    const attributeBufferHeaders = attributes.map((attr) => {
        const MAX_BYTES_FOR_ATTRIBUTE = getMaxByteSizeOfAttribute(attr);
        const WEIGHT = MAX_BYTES_FOR_ATTRIBUTE / MAX_BYTES_PER_ELEMENT_OF_ATTRIBUTES;
        const BYTES_FOR_ATTRIBUTE = bufferSize * WEIGHT;
        const isVarLength = isAttributeVarLength(attr);
        const isNullable = isAttributeNullable(attr);
        const BYTES_PER_ELEMENT = getByteLengthOfDatatype_1.default(attr.type);
        const BYTE_PER_OFFSET = getByteLengthOfDatatype_1.default(v2_1.Datatype.Uint64);
        const TOTAL_BYTES_PER_ELEMENT = BYTES_FOR_ATTRIBUTE * (BYTES_PER_ELEMENT / MAX_BYTES_FOR_ATTRIBUTE);
        const TOTAL_BYTE_PER_VALIDITY = BYTES_FOR_ATTRIBUTE / MAX_BYTES_FOR_ATTRIBUTE;
        const TOTAL_BYTE_PER_OFFSET = BYTES_FOR_ATTRIBUTE * (BYTE_PER_OFFSET / MAX_BYTES_FOR_ATTRIBUTE);
        const fixedLenBufferSizeInBytes = isVarLength
            ? TOTAL_BYTE_PER_OFFSET
            : TOTAL_BYTES_PER_ELEMENT;
        const varLenBufferSizeInBytes = isVarLength ? TOTAL_BYTES_PER_ELEMENT : 0;
        const validityLenBufferSizeInBytes = isNullable ? TOTAL_BYTE_PER_VALIDITY : 0;
        return {
            name: attr.name,
            fixedLenBufferSizeInBytes: 0,
            varLenBufferSizeInBytes: 0,
            validityLenBufferSizeInBytes: 0,
            originalFixedLenBufferSizeInBytes: Math.floor(fixedLenBufferSizeInBytes),
            originalVarLenBufferSizeInBytes: Math.floor(varLenBufferSizeInBytes),
            originalValidityLenBufferSizeInBytes: Math.floor(validityLenBufferSizeInBytes),
        };
    });
    return attributeBufferHeaders;
};
const isDimension = (data) => {
    return data.hasOwnProperty('nullTileExtent');
};
const isAttributeVarLength = (attribute) => {
    if (isDimension(attribute)) {
        // Only StringAscii is var-length dimension
        return attribute.type === v2_1.Datatype.StringAscii;
    }
    return attribute.cellValNum == 4294967295;
};
const isAttributeNullable = (attribute) => {
    if (isDimension(attribute)) {
        return false;
    }
    // TODO: How do i know if attribute is nullable?
    return true;
};
const getMaxByteSizeOfAttribute = (attribute) => {
    const isVarLength = isAttributeVarLength(attribute);
    const isNullable = isAttributeNullable(attribute);
    const BYTES_PER_ELEMENT = getByteLengthOfDatatype_1.default(attribute.type);
    const BYTE_PER_VALIDITY = getByteLengthOfDatatype_1.default(v2_1.Datatype.Uint8);
    const BYTE_PER_OFFSET = getByteLengthOfDatatype_1.default(v2_1.Datatype.Uint64);
    return (Number(isVarLength) * BYTE_PER_OFFSET +
        BYTES_PER_ELEMENT +
        Number(isNullable) * BYTE_PER_VALIDITY);
};
/**
 * Helper function that takes user data and returns a Query object.
 * Since the Query object is really big we don't expect user to manually set all the values.
 * We get the essential minimal data needed from the user (such as the layout and ranges) and
 * convert it to a Query object.
 * @param data
 * @param attributes
 * @param dimensions
 * @returns Query object
 */
const dataToQuery = (data, attributes, dimensions) => {
    if (!data.layout) {
        return data;
    }
    const { bufferSize } = data;
    // Use default dimension's Domain for ranges that are set empty []
    const rangesWithDomain = emptyRangesToDomain_1.default(data.ranges, dimensions);
    const ranges = getRanges_1.default(rangesWithDomain, dimensions);
    const attributeBufferHeaders = createAttributeBufferHeaders([...attributes, ...dimensions], bufferSize);
    return {
        attributeBufferHeaders,
        layout: data.layout,
        status: v2_1.Querystatus.Uninitialized,
        type: v2_1.Querytype.Read,
        reader: {
            layout: data.layout,
            subarray: {
                layout: data.layout,
                ranges,
            },
            readState: {
                subarrayPartitioner: {
                    subarray: {
                        layout: data.layout,
                        ranges: [],
                    },
                    budget: [],
                    current: {
                        subarray: {
                            layout: data.layout,
                            ranges: [],
                        },
                    },
                },
            },
        },
    };
};
exports["default"] = dataToQuery;
//# sourceMappingURL=dataToQuery.js.map

/***/ }),

/***/ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/dataToQueryWriter.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/dataToQueryWriter.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const v2_1 = __webpack_require__(/*! ../v2 */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/v2/index.js");
const getRanges_1 = __importDefault(__webpack_require__(/*! ./getRanges */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/getRanges.js"));
const flatten_1 = __importDefault(__webpack_require__(/*! ./flatten */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/flatten.js"));
const dataToQueryWriter = (data, dimensions, valueBuffer) => {
    const attributeBufferHeaders = Object.entries(valueBuffer).map(([key, val]) => {
        const isVarLength = val.offsetsBuffer.byteLength;
        return {
            name: key,
            fixedLenBufferSizeInBytes: val.offsetsBuffer.byteLength || val.valuesBuffer.byteLength,
            varLenBufferSizeInBytes: isVarLength ? val.valuesBuffer.byteLength : 0,
            validityLenBufferSizeInBytes: val.validityBuffer.byteLength,
            originalFixedLenBufferSizeInBytes: val.offsetsBuffer.byteLength || val.valuesBuffer.byteLength,
            originalVarLenBufferSizeInBytes: isVarLength
                ? val.valuesBuffer.byteLength
                : 0,
            originalValidityLenBufferSizeInBytes: val.validityBuffer.byteLength,
        };
    });
    const dimensionDomains = dimensions.map((dim) => {
        if (!dim.domain) {
            return [];
        }
        const [firstValue] = Object.values(dim.domain);
        return firstValue;
    });
    const { subarray: subarrayRanges } = data;
    const hasDefaultRange = subarrayRanges ? false : true;
    const ranges = getRanges_1.default(subarrayRanges || dimensionDomains, dimensions, hasDefaultRange);
    const subarray = getSubArray(subarrayRanges, dimensions);
    return {
        attributeBufferHeaders,
        layout: data.layout,
        status: v2_1.Querystatus.Uninitialized,
        type: v2_1.Querytype.Write,
        writer: {
            checkCoordDups: false,
            checkCoordOOB: false,
            dedupCoords: false,
            subarray,
            subarrayRanges: {
                layout: data.layout,
                ranges,
            },
        },
    };
};
exports["default"] = dataToQueryWriter;
const getSubArray = (ranges, dimensions) => {
    const subarray = {
        int8: [],
        uint8: [],
        int16: [],
        uint16: [],
        int32: [],
        uint32: [],
        int64: [],
        uint64: [],
        float32: [],
        float64: [],
    };
    if (!ranges) {
        return subarray;
    }
    const type = dimensions[0].type;
    subarray[type.toLocaleLowerCase()] = flatten_1.default(ranges);
    return subarray;
};
//# sourceMappingURL=dataToQueryWriter.js.map

/***/ }),

/***/ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/emptyRangesToDomain.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/emptyRangesToDomain.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const emptyRangesToDomain = (ranges, dimensions) => {
    return ranges.map((range, i) => {
        const isEmpty = !range.length;
        const domain = dimensions[i].domain;
        if (!isEmpty) {
            return range;
        }
        // If there is a Domain for the dimension we return the dimension's domain as range
        if (domain) {
            const [firstValue] = Object.values(domain);
            return firstValue;
        }
        return range;
    });
};
exports["default"] = emptyRangesToDomain;
//# sourceMappingURL=emptyRangesToDomain.js.map

/***/ }),

/***/ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/flatten.js":
/*!********************************************************************!*\
  !*** ./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/flatten.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Flatten nested arrays to a single array
 */
const flatten = (list) => list.flat();
exports["default"] = flatten;
//# sourceMappingURL=flatten.js.map

/***/ }),

/***/ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/getByteLengthOfData.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/getByteLengthOfData.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const v2_1 = __webpack_require__(/*! ../v2 */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/v2/index.js");
const getTypedArrayFromDataType_1 = __importDefault(__webpack_require__(/*! ./getTypedArrayFromDataType */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/getTypedArrayFromDataType.js"));
const mapToBigIntIfNeeded_1 = __importDefault(__webpack_require__(/*! ./mapToBigIntIfNeeded */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/mapToBigIntIfNeeded.js"));
/**
 * Calculate the number of bytes of an array of numbers or strings
 * @param data Array of numbers or strings
 * @param type Datatype (e.g. UINT64, StringUcs2 etc)
 * @returns number of total bytes
 */
const getByteLengthOfData = (data, type) => {
    if (!data.length) {
        return 0;
    }
    const TypedArray = getTypedArrayFromDataType_1.default(type);
    // case 1: it's number of arrays
    if (TypedArray) {
        const nums = mapToBigIntIfNeeded_1.default(data, type);
        return TypedArray.from(nums).byteLength;
    }
    // otherwise it's string
    if (type === v2_1.Datatype.Char || v2_1.Datatype.StringAscii) {
        return data.reduce((accum, str) => accum + (str === null || str === void 0 ? void 0 : str.length), 0);
    }
    if (type === v2_1.Datatype.StringUcs2) {
        return data.reduce((accum, str) => accum + (str === null || str === void 0 ? void 0 : str.length) * 2, 0);
    }
    if (type === v2_1.Datatype.StringUcs4) {
        return data.reduce((accum, str) => accum + (str === null || str === void 0 ? void 0 : str.length) * 4, 0);
    }
    if (type === v2_1.Datatype.StringUtf8) {
        const encoder = new TextEncoder();
        const encodedStr = data.map((str) => encoder.encode(str));
        return encodedStr.reduce((accum, encodedString) => {
            return accum + encodedString.byteLength;
        }, 0);
    }
};
exports["default"] = getByteLengthOfData;
//# sourceMappingURL=getByteLengthOfData.js.map

/***/ }),

/***/ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/getByteLengthOfDatatype.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/getByteLengthOfDatatype.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const v2_1 = __webpack_require__(/*! ../v2 */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/v2/index.js");
const getTypedArrayFromDataType_1 = __importDefault(__webpack_require__(/*! ./getTypedArrayFromDataType */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/getTypedArrayFromDataType.js"));
/**
 * Get the byte length of an individual element of every Datatype
 */
const getByteLengthOfDatatype = (type) => {
    const TypedArray = getTypedArrayFromDataType_1.default(type);
    if (TypedArray) {
        return TypedArray.BYTES_PER_ELEMENT;
    }
    else if (type === v2_1.Datatype.StringAscii || type === v2_1.Datatype.Char || type === v2_1.Datatype.StringUtf8) {
        return 1;
    }
    else if (type === v2_1.Datatype.StringUcs2 || type === v2_1.Datatype.StringUtf16) {
        return 2;
    }
    else if (type === v2_1.Datatype.StringUtf32 || type === v2_1.Datatype.StringUcs4) {
        return 4;
    }
};
exports["default"] = getByteLengthOfDatatype;
//# sourceMappingURL=getByteLengthOfDatatype.js.map

/***/ }),

/***/ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/getRanges.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/getRanges.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const rangesToBuffer_1 = __importDefault(__webpack_require__(/*! ./rangesToBuffer */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/rangesToBuffer.js"));
const flatten_1 = __importDefault(__webpack_require__(/*! ./flatten */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/flatten.js"));
const getByteLengthOfData_1 = __importDefault(__webpack_require__(/*! ./getByteLengthOfData */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/getByteLengthOfData.js"));
/**
 * Checks if data is an array of numbers
 * @param data
 * @returns Boolean if data is an array of numbers
 */
const isNumberArray = (data) => {
    return typeof data[0] === "number";
};
const getRanges = (ranges, dimensions, hasDefaultRange) => {
    return ranges.map((range, i) => {
        const [firstRange] = range;
        const type = dimensions[i].type;
        const isArrayOfArrays = Array.isArray(firstRange);
        const isArrayOfInts = isNumberArray(flatten_1.default(range));
        const isEmpty = !range.length;
        const bufferSizes = isArrayOfArrays
            ? range.map((r) => getByteLengthOfData_1.default(r, type))
            : [getByteLengthOfData_1.default(range, type)];
        const startRanges = isArrayOfArrays ? range.map((r) => r[0]) : [firstRange];
        const bufferStartSizes = startRanges.map((startingRange) => {
            if (!startingRange) {
                return 0;
            }
            return getByteLengthOfData_1.default([startingRange], type);
        });
        /**
         * bufferStartSizes is used only for var length string ascii dimensions,
         * for ints is 0
         */
        if (isArrayOfInts) {
            bufferStartSizes.fill(0);
        }
        return {
            type,
            // TODO: How do we know "hasDefaultRange" ? Is it related with the domain?
            hasDefaultRange: isEmpty || !!hasDefaultRange,
            buffer: rangesToBuffer_1.default(flatten_1.default(range), type),
            bufferSizes,
            bufferStartSizes: isEmpty ? [0] : bufferStartSizes,
        };
    });
};
exports["default"] = getRanges;
//# sourceMappingURL=getRanges.js.map

/***/ }),

/***/ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/getTypedArrayFromDataType.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/getTypedArrayFromDataType.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const v2_1 = __webpack_require__(/*! ../v2 */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/v2/index.js");
const mapToBigIntIfNeeded_1 = __webpack_require__(/*! ./mapToBigIntIfNeeded */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/mapToBigIntIfNeeded.js");
/**
 * Get the TypedArray of every type
 */
const getTypedArrayFromDataType = (type) => {
    if (type === v2_1.Datatype.Int32) {
        return Int32Array;
    }
    else if (type === v2_1.Datatype.Int16) {
        return Int16Array;
    }
    else if (type === v2_1.Datatype.Int8) {
        return Int8Array;
    }
    else if (type === v2_1.Datatype.Int64) {
        return BigInt64Array;
    }
    else if (type === v2_1.Datatype.Uint16) {
        return Uint16Array;
    }
    else if (type === v2_1.Datatype.Uint32) {
        return Uint32Array;
    }
    else if (type === v2_1.Datatype.Uint8) {
        return Uint8Array;
    }
    else if (type === v2_1.Datatype.Uint64) {
        return BigUint64Array;
    }
    else if (type === v2_1.Datatype.Float32) {
        return Float32Array;
    }
    else if (type === v2_1.Datatype.Float64) {
        return Float64Array;
    }
    else if (mapToBigIntIfNeeded_1.int64Types.includes(type)) {
        return BigInt64Array;
    }
};
exports["default"] = getTypedArrayFromDataType;
//# sourceMappingURL=getTypedArrayFromDataType.js.map

/***/ }),

/***/ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/getWriterBody.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/getWriterBody.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const dataToQueryWriter_1 = __importDefault(__webpack_require__(/*! ./dataToQueryWriter */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/dataToQueryWriter.js"));
const attributeValuesToArrayBuffers_1 = __importDefault(__webpack_require__(/*! ./attributeValuesToArrayBuffers */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/attributeValuesToArrayBuffers.js"));
const capnpQuerySerializer_1 = __importDefault(__webpack_require__(/*! ./capnpQuerySerializer */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/capnpQuerySerializer.js"));
const concatArrayBuffers_1 = __importDefault(__webpack_require__(/*! ./concatArrayBuffers */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/concatArrayBuffers.js"));
const emptyArrayBuffer = new ArrayBuffer(0);
const getWriterBody = (data, arraySchema) => {
    const dimensions = arraySchema.domain.dimensions;
    const attributes = arraySchema.attributes;
    const valueBuffers = attributeValuesToArrayBuffers_1.default(data.values, dimensions, attributes);
    const queryObject = dataToQueryWriter_1.default(data, dimensions, valueBuffers);
    const querySerialized = capnpQuerySerializer_1.default(queryObject);
    const attributeBuffersArray = Object.values(valueBuffers).reduce((accum, valueBuffer) => {
        const attributeBuffer = concatArrayBuffers_1.default(valueBuffer.offsetsBuffer, valueBuffer.valuesBuffer, valueBuffer.validityBuffer);
        return concatArrayBuffers_1.default(accum, attributeBuffer);
    }, emptyArrayBuffer);
    const body = concatArrayBuffers_1.default(querySerialized, attributeBuffersArray);
    return body;
};
exports["default"] = getWriterBody;
//# sourceMappingURL=getWriterBody.js.map

/***/ }),

/***/ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/groupValuesByOffsets.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/groupValuesByOffsets.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Group values together according to offsets
 * @param vals [1, 2, 3, 4]
 * @param offsets e.g. [0, 3, 4]
 * @returns [[1,2,3], 4]
 */
const groupValuesByOffsets = (vals, offsets) => {
    let arrWithOffsets = [];
    const valueArray = vals;
    if (offsets.length) {
        offsets.forEach((offset, i) => {
            const offsetDiffWithNext = offsets[i + 1] - offset;
            if (offsetDiffWithNext) {
                arrWithOffsets.push(valueArray.slice(0, offsetDiffWithNext));
                valueArray.splice(0, offsetDiffWithNext);
            }
            else {
                arrWithOffsets.push(valueArray);
            }
        });
    }
    return arrWithOffsets;
};
exports["default"] = groupValuesByOffsets;
//# sourceMappingURL=groupValuesByOffsets.js.map

/***/ }),

/***/ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/isArrayOfArrays.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/isArrayOfArrays.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const isArrayOfArrays = (data) => {
    if (Array.isArray(data) && Array.isArray(data[0])) {
        return true;
    }
    return false;
};
exports["default"] = isArrayOfArrays;
//# sourceMappingURL=isArrayOfArrays.js.map

/***/ }),

/***/ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/mapToBigIntIfNeeded.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/mapToBigIntIfNeeded.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.int64Types = void 0;
const v2_1 = __webpack_require__(/*! ../v2 */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/v2/index.js");
// DateTime types are Int64 numbers
exports.int64Types = [
    v2_1.Datatype.Int64,
    v2_1.Datatype.Uint64,
    v2_1.Datatype.DatetimeAs,
    v2_1.Datatype.DatetimeDay,
    v2_1.Datatype.DatetimeFs,
    v2_1.Datatype.DatetimeHr,
    v2_1.Datatype.DatetimeMin,
    v2_1.Datatype.DatetimeMonth,
    v2_1.Datatype.DatetimeMs,
    v2_1.Datatype.DatetimeNs,
    v2_1.Datatype.DatetimePs,
    v2_1.Datatype.DatetimeSec,
    v2_1.Datatype.DatetimeUs,
    v2_1.Datatype.DatetimeWeek,
    v2_1.Datatype.DatetimeYear,
];
/**
 * If the type is an INT64 (e.g. Datetimes or Uint64 or Int64)
 * we convert the number array to an array of BigInts.
 */
const mapToBigIntIfNeeded = (data, type) => {
    let nums = data;
    if (exports.int64Types.includes(type) && typeof nums[0] === "number") {
        nums = data.map(BigInt);
    }
    return nums;
};
exports["default"] = mapToBigIntIfNeeded;
//# sourceMappingURL=mapToBigIntIfNeeded.js.map

/***/ }),

/***/ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/rangesToBuffer.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/rangesToBuffer.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const v2_1 = __webpack_require__(/*! ../v2 */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/v2/index.js");
const flatten_1 = __importDefault(__webpack_require__(/*! ./flatten */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/flatten.js"));
const getTypedArrayFromDataType_1 = __importDefault(__webpack_require__(/*! ./getTypedArrayFromDataType */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/getTypedArrayFromDataType.js"));
const mapToBigIntIfNeeded_1 = __importDefault(__webpack_require__(/*! ./mapToBigIntIfNeeded */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/mapToBigIntIfNeeded.js"));
/**
 * Convert user defined ranges to a Uint8Array
 */
const rangesToBuffer = (ranges, type) => {
    const TypedArray = getTypedArrayFromDataType_1.default(type);
    if (TypedArray) {
        const nums = mapToBigIntIfNeeded_1.default(ranges, type);
        const dataview = TypedArray.from(nums);
        const uint8Array = new Uint8Array(dataview.buffer, 0, dataview.byteLength);
        return Array.from(uint8Array);
    }
    else if (type === v2_1.Datatype.StringAscii) {
        const asciiArray = ranges.reduce((arr, str) => {
            const charCodes = str.split('').map((s, i) => str.charCodeAt(i));
            return [...arr, ...charCodes];
        }, []);
        return flatten_1.default(asciiArray);
    }
};
exports["default"] = rangesToBuffer;
//# sourceMappingURL=rangesToBuffer.js.map

/***/ }),

/***/ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/setNullables.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/setNullables.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const groupValuesByOffsets_1 = __importDefault(__webpack_require__(/*! ./groupValuesByOffsets */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/groupValuesByOffsets.js"));
/**
 * Set nullables on an array
 * @param vals [12, 15, 22, 34, 8]
 * @param nullables [0, 1, 1, 0, 1]
 * @param offsets []
 * @returns [NULL, 15, 22, NULL, 8]
 */
const setNullables = (vals, nullables, offsets) => {
    // If values have offsets we group values together by offset
    const valueArray = offsets.length
        ? groupValuesByOffsets_1.default(vals, offsets)
        : vals;
    // We explicitly set as NULL index where nullable array is 0
    return valueArray.map((val, i) => (nullables[i] ? val : null));
};
exports["default"] = setNullables;
//# sourceMappingURL=setNullables.js.map

/***/ }),

/***/ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/typedArrayToArray.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/typedArrayToArray.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * Convert a TypedArray (Uint8Array, Int32Array etc) to an Array
 */
const typedArrayToArray = (typedArray) => Array.from(typedArray);
exports["default"] = typedArrayToArray;
//# sourceMappingURL=typedArrayToArray.js.map

/***/ }),

/***/ "./node_modules/@tiledb-inc/tiledb-cloud/lib/v1/api.js":
/*!*************************************************************!*\
  !*** ./node_modules/@tiledb-inc/tiledb-cloud/lib/v1/api.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* tslint:disable */
/* eslint-disable */
/**
 * TileDB Storage Platform API
 * TileDB Storage Platform REST API
 *
 * The version of the OpenAPI document: 2.2.19
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookApi = exports.NotebookApiFactory = exports.NotebookApiFp = exports.NotebookApiAxiosParamCreator = exports.InvitationApi = exports.InvitationApiFactory = exports.InvitationApiFp = exports.InvitationApiAxiosParamCreator = exports.FavoritesApi = exports.FavoritesApiFactory = exports.FavoritesApiFp = exports.FavoritesApiAxiosParamCreator = exports.ArrayTasksApi = exports.ArrayTasksApiFactory = exports.ArrayTasksApiFp = exports.ArrayTasksApiAxiosParamCreator = exports.ArrayApi = exports.ArrayApiFactory = exports.ArrayApiFp = exports.ArrayApiAxiosParamCreator = exports.UDFType = exports.UDFLanguage = exports.UDFActions = exports.TokenScope = exports.SSOProvider = exports.ResultFormat = exports.Querytype = exports.Querystatus = exports.PublicShareFilter = exports.PricingUnitLabel = exports.PricingType = exports.PricingInterval = exports.PricingCurrency = exports.PricingAggregateUsage = exports.OrganizationRoles = exports.NamespaceActions = exports.Layout = exports.InvitationType = exports.InvitationStatus = exports.FilterType = exports.FilterOption = exports.FileType = exports.FilePropertyName = exports.FavoriteType = exports.Datatype = exports.ArrayType = exports.ArrayTaskType = exports.ArrayTaskStatus = exports.ArrayActions = exports.ActivityEventType = void 0;
exports.UserApi = exports.UserApiFactory = exports.UserApiFp = exports.UserApiAxiosParamCreator = exports.UdfApi = exports.UdfApiFactory = exports.UdfApiFp = exports.UdfApiAxiosParamCreator = exports.TasksApi = exports.TasksApiFactory = exports.TasksApiFp = exports.TasksApiAxiosParamCreator = exports.StatsApi = exports.StatsApiFactory = exports.StatsApiFp = exports.StatsApiAxiosParamCreator = exports.SqlApi = exports.SqlApiFactory = exports.SqlApiFp = exports.SqlApiAxiosParamCreator = exports.QueryApi = exports.QueryApiFactory = exports.QueryApiFp = exports.QueryApiAxiosParamCreator = exports.OrganizationApi = exports.OrganizationApiFactory = exports.OrganizationApiFp = exports.OrganizationApiAxiosParamCreator = exports.NotebooksApi = exports.NotebooksApiFactory = exports.NotebooksApiFp = exports.NotebooksApiAxiosParamCreator = void 0;
const axios_1 = __importDefault(__webpack_require__(/*! axios */ "./node_modules/axios/index.js"));
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = __webpack_require__(/*! ./common */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/v1/common.js");
// @ts-ignore
const base_1 = __webpack_require__(/*! ./base */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/v1/base.js");
/**
 * Type of activity logged
 * @export
 * @enum {string}
 */
var ActivityEventType;
(function (ActivityEventType) {
    ActivityEventType["ReadSchema"] = "read_schema";
    ActivityEventType["MaxBufferSizes"] = "max_buffer_sizes";
    ActivityEventType["NonEmptyDomain"] = "non_empty_domain";
    ActivityEventType["QueryRead"] = "query_read";
    ActivityEventType["QueryWrite"] = "query_write";
    ActivityEventType["Create"] = "create";
    ActivityEventType["Delete"] = "delete";
    ActivityEventType["Register"] = "register";
    ActivityEventType["Deregister"] = "deregister";
    ActivityEventType["Udf"] = "udf";
    ActivityEventType["ArrayMetadataGet"] = "array_metadata_get";
    ActivityEventType["ArrayMetadataUpdate"] = "array_metadata_update";
    ActivityEventType["EstimatedResultSizes"] = "estimated_result_sizes";
})(ActivityEventType = exports.ActivityEventType || (exports.ActivityEventType = {}));
/**
 * actions a user can take on an array
 * @export
 * @enum {string}
 */
var ArrayActions;
(function (ArrayActions) {
    ArrayActions["Read"] = "read";
    ArrayActions["Write"] = "write";
    ArrayActions["Edit"] = "edit";
    ArrayActions["ReadArrayLogs"] = "read_array_logs";
    ArrayActions["ReadArrayInfo"] = "read_array_info";
    ArrayActions["ReadArraySchema"] = "read_array_schema";
})(ArrayActions = exports.ArrayActions || (exports.ArrayActions = {}));
/**
 * Status of array task
 * @export
 * @enum {string}
 */
var ArrayTaskStatus;
(function (ArrayTaskStatus) {
    ArrayTaskStatus["Failed"] = "FAILED";
    ArrayTaskStatus["Completed"] = "COMPLETED";
    ArrayTaskStatus["Running"] = "RUNNING";
})(ArrayTaskStatus = exports.ArrayTaskStatus || (exports.ArrayTaskStatus = {}));
/**
 * Synchronous Task Type
 * @export
 * @enum {string}
 */
var ArrayTaskType;
(function (ArrayTaskType) {
    ArrayTaskType["Sql"] = "SQL";
    ArrayTaskType["Udf"] = "UDF";
    ArrayTaskType["Query"] = "QUERY";
    ArrayTaskType["GenericUdf"] = "GENERIC_UDF";
})(ArrayTaskType = exports.ArrayTaskType || (exports.ArrayTaskType = {}));
/**
 * TileDB array type
 * @export
 * @enum {string}
 */
var ArrayType;
(function (ArrayType) {
    ArrayType["Dense"] = "dense";
    ArrayType["Sparse"] = "sparse";
})(ArrayType = exports.ArrayType || (exports.ArrayType = {}));
/**
 * TileDB data type
 * @export
 * @enum {string}
 */
var Datatype;
(function (Datatype) {
    Datatype["Int32"] = "INT32";
    Datatype["Int64"] = "INT64";
    Datatype["Float32"] = "FLOAT32";
    Datatype["Float64"] = "FLOAT64";
    Datatype["Char"] = "CHAR";
    Datatype["Int8"] = "INT8";
    Datatype["Uint8"] = "UINT8";
    Datatype["Int16"] = "INT16";
    Datatype["Uint16"] = "UINT16";
    Datatype["Uint32"] = "UINT32";
    Datatype["Uint64"] = "UINT64";
    Datatype["StringAscii"] = "STRING_ASCII";
    Datatype["StringUtf8"] = "STRING_UTF8";
    Datatype["StringUtf16"] = "STRING_UTF16";
    Datatype["StringUtf32"] = "STRING_UTF32";
    Datatype["StringUcs2"] = "STRING_UCS2";
    Datatype["StringUcs4"] = "STRING_UCS4";
    Datatype["Any"] = "ANY";
})(Datatype = exports.Datatype || (exports.Datatype = {}));
/**
 * List of values that FavoriteType can take
 * @export
 * @enum {string}
 */
var FavoriteType;
(function (FavoriteType) {
    FavoriteType["Array"] = "ARRAY";
})(FavoriteType = exports.FavoriteType || (exports.FavoriteType = {}));
/**
 * File property assigned to a specific file (array)
 * @export
 * @enum {string}
 */
var FilePropertyName;
(function (FilePropertyName) {
    FilePropertyName["Image"] = "image";
    FilePropertyName["Size"] = "size";
    FilePropertyName["CodeBlock"] = "code_block";
    FilePropertyName["UdfLanguage"] = "udf_language";
    FilePropertyName["IsDashboard"] = "is_dashboard";
})(FilePropertyName = exports.FilePropertyName || (exports.FilePropertyName = {}));
/**
 * File types represented as TileDB arrays
 * @export
 * @enum {string}
 */
var FileType;
(function (FileType) {
    FileType["Notebook"] = "notebook";
    FileType["UserDefinedFunction"] = "user_defined_function";
    FileType["MlModel"] = "ml_model";
})(FileType = exports.FileType || (exports.FileType = {}));
/**
 * TileDB filter option
 * @export
 * @enum {string}
 */
var FilterOption;
(function (FilterOption) {
    FilterOption["CompressionLevel"] = "COMPRESSION_LEVEL";
    FilterOption["BitWidthMaxWindow"] = "BIT_WIDTH_MAX_WINDOW";
    FilterOption["PositiveDeltaMaxWindow"] = "POSITIVE_DELTA_MAX_WINDOW";
})(FilterOption = exports.FilterOption || (exports.FilterOption = {}));
/**
 * TileDB filter types
 * @export
 * @enum {string}
 */
var FilterType;
(function (FilterType) {
    FilterType["None"] = "FILTER_NONE";
    FilterType["Gzip"] = "FILTER_GZIP";
    FilterType["Zstd"] = "FILTER_ZSTD";
    FilterType["Lz4"] = "FILTER_LZ4";
    FilterType["Rle"] = "FILTER_RLE";
    FilterType["Bzip2"] = "FILTER_BZIP2";
    FilterType["DoubleDelta"] = "FILTER_DOUBLE_DELTA";
    FilterType["BitWidthReduction"] = "FILTER_BIT_WIDTH_REDUCTION";
    FilterType["Bitshuffle"] = "FILTER_BITSHUFFLE";
    FilterType["Byteshuffle"] = "FILTER_BYTESHUFFLE";
    FilterType["PositiveDelta"] = "FILTER_POSITIVE_DELTA";
})(FilterType = exports.FilterType || (exports.FilterType = {}));
/**
 * List of values that InvitationStatus can take
 * @export
 * @enum {string}
 */
var InvitationStatus;
(function (InvitationStatus) {
    InvitationStatus["Pending"] = "PENDING";
    InvitationStatus["Accepted"] = "ACCEPTED";
})(InvitationStatus = exports.InvitationStatus || (exports.InvitationStatus = {}));
/**
 * List of values that InvitationType can take
 * @export
 * @enum {string}
 */
var InvitationType;
(function (InvitationType) {
    InvitationType["ArrayShare"] = "ARRAY_SHARE";
    InvitationType["JoinOrganization"] = "JOIN_ORGANIZATION";
})(InvitationType = exports.InvitationType || (exports.InvitationType = {}));
/**
 * Layout of array
 * @export
 * @enum {string}
 */
var Layout;
(function (Layout) {
    Layout["RowMajor"] = "row-major";
    Layout["ColMajor"] = "col-major";
    Layout["GlobalOrder"] = "global-order";
    Layout["Unordered"] = "unordered";
})(Layout = exports.Layout || (exports.Layout = {}));
/**
 * actions a user can take on an organization
 * @export
 * @enum {string}
 */
var NamespaceActions;
(function (NamespaceActions) {
    NamespaceActions["Read"] = "read";
    NamespaceActions["Write"] = "write";
    NamespaceActions["Create"] = "create";
    NamespaceActions["Delete"] = "delete";
    NamespaceActions["Edit"] = "edit";
    NamespaceActions["ReadArrayLogs"] = "read_array_logs";
    NamespaceActions["ReadJobLogs"] = "read_job_logs";
    NamespaceActions["ReadObjectLogs"] = "read_object_logs";
    NamespaceActions["RunJob"] = "run_job";
    NamespaceActions["DeleteOrganization"] = "delete_organization";
    NamespaceActions["EditOrganization"] = "edit_organization";
    NamespaceActions["EditBilling"] = "edit_billing";
})(NamespaceActions = exports.NamespaceActions || (exports.NamespaceActions = {}));
/**
 * role user has in organization
 * @export
 * @enum {string}
 */
var OrganizationRoles;
(function (OrganizationRoles) {
    OrganizationRoles["Owner"] = "owner";
    OrganizationRoles["Admin"] = "admin";
    OrganizationRoles["ReadWrite"] = "read_write";
    OrganizationRoles["ReadOnly"] = "read_only";
})(OrganizationRoles = exports.OrganizationRoles || (exports.OrganizationRoles = {}));
/**
 * Specifies a usage aggregation strategy for pricings of usage_type=metered
 * @export
 * @enum {string}
 */
var PricingAggregateUsage;
(function (PricingAggregateUsage) {
    PricingAggregateUsage["Sum"] = "sum";
})(PricingAggregateUsage = exports.PricingAggregateUsage || (exports.PricingAggregateUsage = {}));
/**
 * Currency of pricing
 * @export
 * @enum {string}
 */
var PricingCurrency;
(function (PricingCurrency) {
    PricingCurrency["Usd"] = "USD";
})(PricingCurrency = exports.PricingCurrency || (exports.PricingCurrency = {}));
/**
 * Interval for pricing
 * @export
 * @enum {string}
 */
var PricingInterval;
(function (PricingInterval) {
    PricingInterval["Month"] = "month";
})(PricingInterval = exports.PricingInterval || (exports.PricingInterval = {}));
/**
 * Pricing types
 * @export
 * @enum {string}
 */
var PricingType;
(function (PricingType) {
    PricingType["Egress"] = "egress";
    PricingType["Access"] = "access";
})(PricingType = exports.PricingType || (exports.PricingType = {}));
/**
 * Unit label
 * @export
 * @enum {string}
 */
var PricingUnitLabel;
(function (PricingUnitLabel) {
    PricingUnitLabel["Byte"] = "byte";
    PricingUnitLabel["Second"] = "second";
})(PricingUnitLabel = exports.PricingUnitLabel || (exports.PricingUnitLabel = {}));
/**
 * Query parameter to get array metadatas
 * @export
 * @enum {string}
 */
var PublicShareFilter;
(function (PublicShareFilter) {
    PublicShareFilter["Exclude"] = "exclude";
    PublicShareFilter["Only"] = "only";
})(PublicShareFilter = exports.PublicShareFilter || (exports.PublicShareFilter = {}));
/**
 * Status of query
 * @export
 * @enum {string}
 */
var Querystatus;
(function (Querystatus) {
    Querystatus["Failed"] = "FAILED";
    Querystatus["Completed"] = "COMPLETED";
    Querystatus["Inprogress"] = "INPROGRESS";
    Querystatus["Incomplete"] = "INCOMPLETE";
    Querystatus["Uninitialized"] = "UNINITIALIZED";
})(Querystatus = exports.Querystatus || (exports.Querystatus = {}));
/**
 * Type of query
 * @export
 * @enum {string}
 */
var Querytype;
(function (Querytype) {
    Querytype["Read"] = "READ";
    Querytype["Write"] = "WRITE";
})(Querytype = exports.Querytype || (exports.Querytype = {}));
/**
 * Results type
 * @export
 * @enum {string}
 */
var ResultFormat;
(function (ResultFormat) {
    ResultFormat["Native"] = "native";
    ResultFormat["Json"] = "json";
    ResultFormat["Arrow"] = "arrow";
})(ResultFormat = exports.ResultFormat || (exports.ResultFormat = {}));
/**
 * Single sign on provider
 * @export
 * @enum {string}
 */
var SSOProvider;
(function (SSOProvider) {
    SSOProvider["Github"] = "github";
    SSOProvider["Google"] = "google";
    SSOProvider["Stripe"] = "stripe";
})(SSOProvider = exports.SSOProvider || (exports.SSOProvider = {}));
/**
 * An api token scope available for creation
 * @export
 * @enum {string}
 */
var TokenScope;
(function (TokenScope) {
    TokenScope["PasswordReset"] = "password_reset";
    TokenScope["ConfirmEmail"] = "confirm_email";
    TokenScope["Star"] = "*";
    TokenScope["Userread"] = "user:read";
    TokenScope["UserreadWrite"] = "user:read-write";
    TokenScope["Useradmin"] = "user:admin";
    TokenScope["Arrayread"] = "array:read";
    TokenScope["ArrayreadWrite"] = "array:read-write";
    TokenScope["Arrayadmin"] = "array:admin";
})(TokenScope = exports.TokenScope || (exports.TokenScope = {}));
/**
 * actions a user can take on an udf
 * @export
 * @enum {string}
 */
var UDFActions;
(function (UDFActions) {
    UDFActions["FetchUdf"] = "fetch_udf";
    UDFActions["ShareUdf"] = "share_udf";
})(UDFActions = exports.UDFActions || (exports.UDFActions = {}));
/**
 * UDF Type
 * @export
 * @enum {string}
 */
var UDFLanguage;
(function (UDFLanguage) {
    UDFLanguage["Python"] = "python";
    UDFLanguage["R"] = "r";
})(UDFLanguage = exports.UDFLanguage || (exports.UDFLanguage = {}));
/**
 * UDF Type
 * @export
 * @enum {string}
 */
var UDFType;
(function (UDFType) {
    UDFType["SingleArray"] = "single_array";
    UDFType["Generic"] = "generic";
})(UDFType = exports.UDFType || (exports.UDFType = {}));
/**
 * ArrayApi - axios parameter creator
 * @export
 */
const ArrayApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * get array activity logs
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
         * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
         * @param {string} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
         * @param {string} [taskId] Array task id To filter activity to
         * @param {boolean} [hasTaskId] Excludes activity log results that does not contain an array task uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arrayActivityLog: (namespace, array, start, end, eventTypes, taskId, hasTaskId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('arrayActivityLog', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('arrayActivityLog', 'array', array);
            const localVarPath = `/arrays/{namespace}/{array}/activity`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }
            if (eventTypes !== undefined) {
                localVarQueryParameter['event_types'] = eventTypes;
            }
            if (taskId !== undefined) {
                localVarQueryParameter['task_id'] = taskId;
            }
            if (hasTaskId !== undefined) {
                localVarQueryParameter['has_task_id'] = hasTaskId;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch a list of all arrays that are owned directly by user or user\'s organizations
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] file_type to search for, more than one can be included
         * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserOwnedGet: (page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/arrays/browser/owned`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }
            if (orderby !== undefined) {
                localVarQueryParameter['orderby'] = orderby;
            }
            if (permissions !== undefined) {
                localVarQueryParameter['permissions'] = permissions;
            }
            if (tag) {
                localVarQueryParameter['tag'] = tag;
            }
            if (excludeTag) {
                localVarQueryParameter['exclude_tag'] = excludeTag;
            }
            if (fileType) {
                localVarQueryParameter['file_type'] = fileType;
            }
            if (excludeFileType) {
                localVarQueryParameter['exclude_file_type'] = excludeFileType;
            }
            if (fileProperty) {
                localVarQueryParameter['file_property'] = fileProperty;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch a sidebar for arrays that are owned directly by user or user\'s organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserOwnedSidebarGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/arrays/browser/owned/sidebar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch a list of all arrays that have been shared publically
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] file_type to search for, more than one can be included
         * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserPublicGet: (page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/arrays/browser/public`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }
            if (orderby !== undefined) {
                localVarQueryParameter['orderby'] = orderby;
            }
            if (permissions !== undefined) {
                localVarQueryParameter['permissions'] = permissions;
            }
            if (tag) {
                localVarQueryParameter['tag'] = tag;
            }
            if (excludeTag) {
                localVarQueryParameter['exclude_tag'] = excludeTag;
            }
            if (fileType) {
                localVarQueryParameter['file_type'] = fileType;
            }
            if (excludeFileType) {
                localVarQueryParameter['exclude_file_type'] = excludeFileType;
            }
            if (fileProperty) {
                localVarQueryParameter['file_property'] = fileProperty;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch a sidebar of all arrays that have been shared publically
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserPublicSidebarGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/arrays/browser/public/sidebar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch a list of all arrays that have been shared with the user
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] file_type to search for, more than one can be included
         * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserSharedGet: (page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/arrays/browser/shared`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }
            if (orderby !== undefined) {
                localVarQueryParameter['orderby'] = orderby;
            }
            if (permissions !== undefined) {
                localVarQueryParameter['permissions'] = permissions;
            }
            if (tag) {
                localVarQueryParameter['tag'] = tag;
            }
            if (excludeTag) {
                localVarQueryParameter['exclude_tag'] = excludeTag;
            }
            if (fileType) {
                localVarQueryParameter['file_type'] = fileType;
            }
            if (excludeFileType) {
                localVarQueryParameter['exclude_file_type'] = excludeFileType;
            }
            if (fileProperty) {
                localVarQueryParameter['file_property'] = fileProperty;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch a list of all arrays that have been shared with the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserSharedSidebarGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/arrays/browser/shared/sidebar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * consolidate an array at a specified URI
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {TileDBConfig} tiledbConfig tiledb configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consolidateArray: (namespace, array, tiledbConfig, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('consolidateArray', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('consolidateArray', 'array', array);
            // verify required parameter 'tiledbConfig' is not null or undefined
            common_1.assertParamExists('consolidateArray', 'tiledbConfig', tiledbConfig);
            const localVarPath = `/arrays/{namespace}/{array}/consolidate`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(tiledbConfig, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * create a array schema at a specified URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {ArraySchema} arraySchema ArraySchema being created
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArray: (namespace, array, contentType, arraySchema, xTILEDBCLOUDACCESSCREDENTIALSNAME, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('createArray', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('createArray', 'array', array);
            // verify required parameter 'contentType' is not null or undefined
            common_1.assertParamExists('createArray', 'contentType', contentType);
            // verify required parameter 'arraySchema' is not null or undefined
            common_1.assertParamExists('createArray', 'arraySchema', arraySchema);
            const localVarPath = `/arrays/{namespace}/{array}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (xTILEDBCLOUDACCESSCREDENTIALSNAME !== undefined && xTILEDBCLOUDACCESSCREDENTIALSNAME !== null) {
                localVarHeaderParameter['X-TILEDB-CLOUD-ACCESS-CREDENTIALS-NAME'] = String(xTILEDBCLOUDACCESSCREDENTIALSNAME);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(arraySchema, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * delete a array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArray: (namespace, array, contentType, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('deleteArray', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('deleteArray', 'array', array);
            // verify required parameter 'contentType' is not null or undefined
            common_1.assertParamExists('deleteArray', 'contentType', contentType);
            const localVarPath = `/arrays/{namespace}/{array}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * deregister a array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deregisterArray: (namespace, array, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('deregisterArray', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('deregisterArray', 'array', array);
            const localVarPath = `/arrays/{namespace}/{array}/deregister`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get activity log by id
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} id id of the activity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityLogById: (namespace, array, id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getActivityLogById', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('getActivityLogById', 'array', array);
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('getActivityLogById', 'id', id);
            const localVarPath = `/arrays/{namespace}/{array}/activity/{id}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get all array metadata user has access to
         * @param {string} [publicShare] Public share values can be one of exclude, only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllArrayMetadata: (publicShare, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/arrays`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (publicShare !== undefined) {
                localVarQueryParameter['public_share'] = publicShare;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get an ArraySchema using a url encoded uri
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArray: (namespace, array, contentType, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getArray', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('getArray', 'array', array);
            // verify required parameter 'contentType' is not null or undefined
            common_1.assertParamExists('getArray', 'contentType', contentType);
            const localVarPath = `/arrays/{namespace}/{array}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get the max buffer sizes of an array for a subarray
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} subarray CSV string of subarray to get max buffer sizes for
         * @param {string} contentType Content Type of input and return mime
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMaxBufferSizes: (namespace, array, subarray, contentType, xPayer, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getArrayMaxBufferSizes', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('getArrayMaxBufferSizes', 'array', array);
            // verify required parameter 'subarray' is not null or undefined
            common_1.assertParamExists('getArrayMaxBufferSizes', 'subarray', subarray);
            // verify required parameter 'contentType' is not null or undefined
            common_1.assertParamExists('getArrayMaxBufferSizes', 'contentType', contentType);
            const localVarPath = `/arrays/{namespace}/{array}/max_buffer_sizes`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (subarray !== undefined) {
                localVarQueryParameter['subarray'] = subarray;
            }
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (xPayer !== undefined && xPayer !== null) {
                localVarHeaderParameter['X-Payer'] = String(xPayer);
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get metadata from the array in json format
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [length] (optional) limit character length of returned values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMetaDataJson: (namespace, array, length, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getArrayMetaDataJson', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('getArrayMetaDataJson', 'array', array);
            const localVarPath = `/arrays/{namespace}/{array}/metadata_json`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (length !== undefined) {
                localVarQueryParameter['length'] = length;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMetadata: (namespace, array, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getArrayMetadata', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('getArrayMetadata', 'array', array);
            const localVarPath = `/arrays/{namespace}/{array}/metadata`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMetadataCapnp: (namespace, array, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getArrayMetadataCapnp', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('getArrayMetadataCapnp', 'array', array);
            const localVarPath = `/arrays/{namespace}/{array}/array_metadata`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get the non empty domain of an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayNonEmptyDomain: (namespace, array, contentType, xPayer, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getArrayNonEmptyDomain', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('getArrayNonEmptyDomain', 'array', array);
            // verify required parameter 'contentType' is not null or undefined
            common_1.assertParamExists('getArrayNonEmptyDomain', 'contentType', contentType);
            const localVarPath = `/arrays/{namespace}/{array}/non_empty_domain`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (xPayer !== undefined && xPayer !== null) {
                localVarHeaderParameter['X-Payer'] = String(xPayer);
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get non-empty domain from the array in json format
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayNonEmptyDomainJson: (namespace, array, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getArrayNonEmptyDomainJson', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('getArrayNonEmptyDomainJson', 'array', array);
            const localVarPath = `/arrays/{namespace}/{array}/non_empty_domain_json`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get an sample set of data from the array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [samples] Number of sample results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArraySampleData: (namespace, array, samples, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getArraySampleData', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('getArraySampleData', 'array', array);
            const localVarPath = `/arrays/{namespace}/{array}/sample`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (samples !== undefined) {
                localVarQueryParameter['samples'] = samples;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all sharing details of the array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArraySharingPolicies: (namespace, array, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getArraySharingPolicies', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('getArraySharingPolicies', 'array', array);
            const localVarPath = `/arrays/{namespace}/{array}/share`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get metadata on all arrays in a namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArraysInNamespace: (namespace, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getArraysInNamespace', 'namespace', namespace);
            const localVarPath = `/arrays/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastAccessedArrays: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/arrays/last_accessed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * register an array at a specified URI registered to the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArrayInfoUpdate} arrayMetadata metadata associated with array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerArray: (namespace, array, arrayMetadata, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('registerArray', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('registerArray', 'array', array);
            // verify required parameter 'arrayMetadata' is not null or undefined
            common_1.assertParamExists('registerArray', 'arrayMetadata', arrayMetadata);
            const localVarPath = `/arrays/{namespace}/{array}/register`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(arrayMetadata, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Share an array with a user
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArraySharing} arraySharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace, if permissions already exist they will be deleted then new ones added. In the event of a failure, the new polcies will be rolled back to prevent partial policies, and its likely the array will not be shared with the namespace at all
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareArray: (namespace, array, arraySharing, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('shareArray', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('shareArray', 'array', array);
            // verify required parameter 'arraySharing' is not null or undefined
            common_1.assertParamExists('shareArray', 'arraySharing', arraySharing);
            const localVarPath = `/arrays/{namespace}/{array}/share`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(arraySharing, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * update metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArrayInfoUpdate} arrayMetadata array metadata to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArrayMetadata: (namespace, array, arrayMetadata, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('updateArrayMetadata', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('updateArrayMetadata', 'array', array);
            // verify required parameter 'arrayMetadata' is not null or undefined
            common_1.assertParamExists('updateArrayMetadata', 'arrayMetadata', arrayMetadata);
            const localVarPath = `/arrays/{namespace}/{array}/metadata`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(arrayMetadata, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * update metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArrayMetadata} arrayMetadataEntries List of metadata entries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArrayMetadataCapnp: (namespace, array, arrayMetadataEntries, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('updateArrayMetadataCapnp', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('updateArrayMetadataCapnp', 'array', array);
            // verify required parameter 'arrayMetadataEntries' is not null or undefined
            common_1.assertParamExists('updateArrayMetadataCapnp', 'arrayMetadataEntries', arrayMetadataEntries);
            const localVarPath = `/arrays/{namespace}/{array}/array_metadata`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(arrayMetadataEntries, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * vacuum an array at a specified URI
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {TileDBConfig} tiledbConfig tiledb configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vacuumArray: (namespace, array, tiledbConfig, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('vacuumArray', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('vacuumArray', 'array', array);
            // verify required parameter 'tiledbConfig' is not null or undefined
            common_1.assertParamExists('vacuumArray', 'tiledbConfig', tiledbConfig);
            const localVarPath = `/arrays/{namespace}/{array}/vacuum`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(tiledbConfig, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.ArrayApiAxiosParamCreator = ArrayApiAxiosParamCreator;
/**
 * ArrayApi - functional programming interface
 * @export
 */
const ArrayApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.ArrayApiAxiosParamCreator(configuration);
    return {
        /**
         * get array activity logs
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
         * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
         * @param {string} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
         * @param {string} [taskId] Array task id To filter activity to
         * @param {boolean} [hasTaskId] Excludes activity log results that does not contain an array task uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch a list of all arrays that are owned directly by user or user\'s organizations
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] file_type to search for, more than one can be included
         * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserOwnedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.arraysBrowserOwnedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch a sidebar for arrays that are owned directly by user or user\'s organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserOwnedSidebarGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.arraysBrowserOwnedSidebarGet(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch a list of all arrays that have been shared publically
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] file_type to search for, more than one can be included
         * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserPublicGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.arraysBrowserPublicGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch a sidebar of all arrays that have been shared publically
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserPublicSidebarGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.arraysBrowserPublicSidebarGet(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch a list of all arrays that have been shared with the user
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] file_type to search for, more than one can be included
         * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserSharedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.arraysBrowserSharedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch a list of all arrays that have been shared with the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserSharedSidebarGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.arraysBrowserSharedSidebarGet(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * consolidate an array at a specified URI
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {TileDBConfig} tiledbConfig tiledb configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consolidateArray(namespace, array, tiledbConfig, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.consolidateArray(namespace, array, tiledbConfig, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * create a array schema at a specified URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {ArraySchema} arraySchema ArraySchema being created
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArray(namespace, array, contentType, arraySchema, xTILEDBCLOUDACCESSCREDENTIALSNAME, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createArray(namespace, array, contentType, arraySchema, xTILEDBCLOUDACCESSCREDENTIALSNAME, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * delete a array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArray(namespace, array, contentType, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteArray(namespace, array, contentType, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * deregister a array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deregisterArray(namespace, array, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deregisterArray(namespace, array, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * get activity log by id
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} id id of the activity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityLogById(namespace, array, id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getActivityLogById(namespace, array, id, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * get all array metadata user has access to
         * @param {string} [publicShare] Public share values can be one of exclude, only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllArrayMetadata(publicShare, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllArrayMetadata(publicShare, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * get an ArraySchema using a url encoded uri
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArray(namespace, array, contentType, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArray(namespace, array, contentType, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * get the max buffer sizes of an array for a subarray
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} subarray CSV string of subarray to get max buffer sizes for
         * @param {string} contentType Content Type of input and return mime
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMaxBufferSizes(namespace, array, subarray, contentType, xPayer, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArrayMaxBufferSizes(namespace, array, subarray, contentType, xPayer, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * get metadata from the array in json format
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [length] (optional) limit character length of returned values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMetaDataJson(namespace, array, length, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArrayMetaDataJson(namespace, array, length, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * get metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMetadata(namespace, array, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArrayMetadata(namespace, array, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * get metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMetadataCapnp(namespace, array, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArrayMetadataCapnp(namespace, array, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * get the non empty domain of an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayNonEmptyDomain(namespace, array, contentType, xPayer, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArrayNonEmptyDomain(namespace, array, contentType, xPayer, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * get non-empty domain from the array in json format
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayNonEmptyDomainJson(namespace, array, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArrayNonEmptyDomainJson(namespace, array, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * get an sample set of data from the array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [samples] Number of sample results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArraySampleData(namespace, array, samples, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArraySampleData(namespace, array, samples, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get all sharing details of the array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArraySharingPolicies(namespace, array, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArraySharingPolicies(namespace, array, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * get metadata on all arrays in a namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArraysInNamespace(namespace, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArraysInNamespace(namespace, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastAccessedArrays(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getLastAccessedArrays(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * register an array at a specified URI registered to the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArrayInfoUpdate} arrayMetadata metadata associated with array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerArray(namespace, array, arrayMetadata, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.registerArray(namespace, array, arrayMetadata, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Share an array with a user
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArraySharing} arraySharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace, if permissions already exist they will be deleted then new ones added. In the event of a failure, the new polcies will be rolled back to prevent partial policies, and its likely the array will not be shared with the namespace at all
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareArray(namespace, array, arraySharing, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.shareArray(namespace, array, arraySharing, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * update metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArrayInfoUpdate} arrayMetadata array metadata to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArrayMetadata(namespace, array, arrayMetadata, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateArrayMetadata(namespace, array, arrayMetadata, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * update metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArrayMetadata} arrayMetadataEntries List of metadata entries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArrayMetadataCapnp(namespace, array, arrayMetadataEntries, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateArrayMetadataCapnp(namespace, array, arrayMetadataEntries, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * vacuum an array at a specified URI
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {TileDBConfig} tiledbConfig tiledb configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vacuumArray(namespace, array, tiledbConfig, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.vacuumArray(namespace, array, tiledbConfig, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.ArrayApiFp = ArrayApiFp;
/**
 * ArrayApi - factory interface
 * @export
 */
const ArrayApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.ArrayApiFp(configuration);
    return {
        /**
         * get array activity logs
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
         * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
         * @param {string} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
         * @param {string} [taskId] Array task id To filter activity to
         * @param {boolean} [hasTaskId] Excludes activity log results that does not contain an array task uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, options) {
            return localVarFp.arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of all arrays that are owned directly by user or user\'s organizations
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] file_type to search for, more than one can be included
         * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserOwnedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options) {
            return localVarFp.arraysBrowserOwnedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a sidebar for arrays that are owned directly by user or user\'s organizations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserOwnedSidebarGet(options) {
            return localVarFp.arraysBrowserOwnedSidebarGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of all arrays that have been shared publically
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] file_type to search for, more than one can be included
         * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserPublicGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options) {
            return localVarFp.arraysBrowserPublicGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a sidebar of all arrays that have been shared publically
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserPublicSidebarGet(options) {
            return localVarFp.arraysBrowserPublicSidebarGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of all arrays that have been shared with the user
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [namespace] namespace
         * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
         * @param {string} [permissions] permissions valid values include read, read_write, write, admin
         * @param {Array<string>} [tag] tag to search for, more than one can be included
         * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] file_type to search for, more than one can be included
         * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserSharedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options) {
            return localVarFp.arraysBrowserSharedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of all arrays that have been shared with the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arraysBrowserSharedSidebarGet(options) {
            return localVarFp.arraysBrowserSharedSidebarGet(options).then((request) => request(axios, basePath));
        },
        /**
         * consolidate an array at a specified URI
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {TileDBConfig} tiledbConfig tiledb configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consolidateArray(namespace, array, tiledbConfig, options) {
            return localVarFp.consolidateArray(namespace, array, tiledbConfig, options).then((request) => request(axios, basePath));
        },
        /**
         * create a array schema at a specified URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {ArraySchema} arraySchema ArraySchema being created
         * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArray(namespace, array, contentType, arraySchema, xTILEDBCLOUDACCESSCREDENTIALSNAME, options) {
            return localVarFp.createArray(namespace, array, contentType, arraySchema, xTILEDBCLOUDACCESSCREDENTIALSNAME, options).then((request) => request(axios, basePath));
        },
        /**
         * delete a array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArray(namespace, array, contentType, options) {
            return localVarFp.deleteArray(namespace, array, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * deregister a array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deregisterArray(namespace, array, options) {
            return localVarFp.deregisterArray(namespace, array, options).then((request) => request(axios, basePath));
        },
        /**
         * get activity log by id
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} id id of the activity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityLogById(namespace, array, id, options) {
            return localVarFp.getActivityLogById(namespace, array, id, options).then((request) => request(axios, basePath));
        },
        /**
         * get all array metadata user has access to
         * @param {string} [publicShare] Public share values can be one of exclude, only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllArrayMetadata(publicShare, options) {
            return localVarFp.getAllArrayMetadata(publicShare, options).then((request) => request(axios, basePath));
        },
        /**
         * get an ArraySchema using a url encoded uri
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArray(namespace, array, contentType, options) {
            return localVarFp.getArray(namespace, array, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * get the max buffer sizes of an array for a subarray
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} subarray CSV string of subarray to get max buffer sizes for
         * @param {string} contentType Content Type of input and return mime
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMaxBufferSizes(namespace, array, subarray, contentType, xPayer, options) {
            return localVarFp.getArrayMaxBufferSizes(namespace, array, subarray, contentType, xPayer, options).then((request) => request(axios, basePath));
        },
        /**
         * get metadata from the array in json format
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [length] (optional) limit character length of returned values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMetaDataJson(namespace, array, length, options) {
            return localVarFp.getArrayMetaDataJson(namespace, array, length, options).then((request) => request(axios, basePath));
        },
        /**
         * get metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMetadata(namespace, array, options) {
            return localVarFp.getArrayMetadata(namespace, array, options).then((request) => request(axios, basePath));
        },
        /**
         * get metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayMetadataCapnp(namespace, array, options) {
            return localVarFp.getArrayMetadataCapnp(namespace, array, options).then((request) => request(axios, basePath));
        },
        /**
         * get the non empty domain of an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayNonEmptyDomain(namespace, array, contentType, xPayer, options) {
            return localVarFp.getArrayNonEmptyDomain(namespace, array, contentType, xPayer, options).then((request) => request(axios, basePath));
        },
        /**
         * get non-empty domain from the array in json format
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayNonEmptyDomainJson(namespace, array, options) {
            return localVarFp.getArrayNonEmptyDomainJson(namespace, array, options).then((request) => request(axios, basePath));
        },
        /**
         * get an sample set of data from the array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [samples] Number of sample results to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArraySampleData(namespace, array, samples, options) {
            return localVarFp.getArraySampleData(namespace, array, samples, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all sharing details of the array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArraySharingPolicies(namespace, array, options) {
            return localVarFp.getArraySharingPolicies(namespace, array, options).then((request) => request(axios, basePath));
        },
        /**
         * get metadata on all arrays in a namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArraysInNamespace(namespace, options) {
            return localVarFp.getArraysInNamespace(namespace, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLastAccessedArrays(options) {
            return localVarFp.getLastAccessedArrays(options).then((request) => request(axios, basePath));
        },
        /**
         * register an array at a specified URI registered to the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArrayInfoUpdate} arrayMetadata metadata associated with array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerArray(namespace, array, arrayMetadata, options) {
            return localVarFp.registerArray(namespace, array, arrayMetadata, options).then((request) => request(axios, basePath));
        },
        /**
         * Share an array with a user
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArraySharing} arraySharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace, if permissions already exist they will be deleted then new ones added. In the event of a failure, the new polcies will be rolled back to prevent partial policies, and its likely the array will not be shared with the namespace at all
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareArray(namespace, array, arraySharing, options) {
            return localVarFp.shareArray(namespace, array, arraySharing, options).then((request) => request(axios, basePath));
        },
        /**
         * update metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArrayInfoUpdate} arrayMetadata array metadata to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArrayMetadata(namespace, array, arrayMetadata, options) {
            return localVarFp.updateArrayMetadata(namespace, array, arrayMetadata, options).then((request) => request(axios, basePath));
        },
        /**
         * update metadata on an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {ArrayMetadata} arrayMetadataEntries List of metadata entries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArrayMetadataCapnp(namespace, array, arrayMetadataEntries, options) {
            return localVarFp.updateArrayMetadataCapnp(namespace, array, arrayMetadataEntries, options).then((request) => request(axios, basePath));
        },
        /**
         * vacuum an array at a specified URI
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {TileDBConfig} tiledbConfig tiledb configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vacuumArray(namespace, array, tiledbConfig, options) {
            return localVarFp.vacuumArray(namespace, array, tiledbConfig, options).then((request) => request(axios, basePath));
        },
    };
};
exports.ArrayApiFactory = ArrayApiFactory;
/**
 * ArrayApi - object-oriented interface
 * @export
 * @class ArrayApi
 * @extends {BaseAPI}
 */
class ArrayApi extends base_1.BaseAPI {
    /**
     * get array activity logs
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
     * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
     * @param {string} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
     * @param {string} [taskId] Array task id To filter activity to
     * @param {boolean} [hasTaskId] Excludes activity log results that does not contain an array task uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, options) {
        return exports.ArrayApiFp(this.configuration).arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a list of all arrays that are owned directly by user or user\'s organizations
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [namespace] namespace
     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
     * @param {string} [permissions] permissions valid values include read, read_write, write, admin
     * @param {Array<string>} [tag] tag to search for, more than one can be included
     * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileType] file_type to search for, more than one can be included
     * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    arraysBrowserOwnedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options) {
        return exports.ArrayApiFp(this.configuration).arraysBrowserOwnedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a sidebar for arrays that are owned directly by user or user\'s organizations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    arraysBrowserOwnedSidebarGet(options) {
        return exports.ArrayApiFp(this.configuration).arraysBrowserOwnedSidebarGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a list of all arrays that have been shared publically
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [namespace] namespace
     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
     * @param {string} [permissions] permissions valid values include read, read_write, write, admin
     * @param {Array<string>} [tag] tag to search for, more than one can be included
     * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileType] file_type to search for, more than one can be included
     * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    arraysBrowserPublicGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options) {
        return exports.ArrayApiFp(this.configuration).arraysBrowserPublicGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a sidebar of all arrays that have been shared publically
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    arraysBrowserPublicSidebarGet(options) {
        return exports.ArrayApiFp(this.configuration).arraysBrowserPublicSidebarGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a list of all arrays that have been shared with the user
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [namespace] namespace
     * @param {string} [orderby] sort by which field valid values include last_accessed, size, name
     * @param {string} [permissions] permissions valid values include read, read_write, write, admin
     * @param {Array<string>} [tag] tag to search for, more than one can be included
     * @param {Array<string>} [excludeTag] tags to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileType] file_type to search for, more than one can be included
     * @param {Array<string>} [excludeFileType] file_type to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileProperty] file_property key-value pair (comma separated, i.e. key,value) to search for, more than one can be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    arraysBrowserSharedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options) {
        return exports.ArrayApiFp(this.configuration).arraysBrowserSharedGet(page, perPage, search, namespace, orderby, permissions, tag, excludeTag, fileType, excludeFileType, fileProperty, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a list of all arrays that have been shared with the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    arraysBrowserSharedSidebarGet(options) {
        return exports.ArrayApiFp(this.configuration).arraysBrowserSharedSidebarGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * consolidate an array at a specified URI
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {TileDBConfig} tiledbConfig tiledb configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    consolidateArray(namespace, array, tiledbConfig, options) {
        return exports.ArrayApiFp(this.configuration).consolidateArray(namespace, array, tiledbConfig, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * create a array schema at a specified URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {ArraySchema} arraySchema ArraySchema being created
     * @param {string} [xTILEDBCLOUDACCESSCREDENTIALSNAME] Optional registered access credentials to use for creation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    createArray(namespace, array, contentType, arraySchema, xTILEDBCLOUDACCESSCREDENTIALSNAME, options) {
        return exports.ArrayApiFp(this.configuration).createArray(namespace, array, contentType, arraySchema, xTILEDBCLOUDACCESSCREDENTIALSNAME, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * delete a array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    deleteArray(namespace, array, contentType, options) {
        return exports.ArrayApiFp(this.configuration).deleteArray(namespace, array, contentType, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * deregister a array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    deregisterArray(namespace, array, options) {
        return exports.ArrayApiFp(this.configuration).deregisterArray(namespace, array, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get activity log by id
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} id id of the activity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getActivityLogById(namespace, array, id, options) {
        return exports.ArrayApiFp(this.configuration).getActivityLogById(namespace, array, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get all array metadata user has access to
     * @param {string} [publicShare] Public share values can be one of exclude, only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getAllArrayMetadata(publicShare, options) {
        return exports.ArrayApiFp(this.configuration).getAllArrayMetadata(publicShare, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get an ArraySchema using a url encoded uri
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArray(namespace, array, contentType, options) {
        return exports.ArrayApiFp(this.configuration).getArray(namespace, array, contentType, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get the max buffer sizes of an array for a subarray
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} subarray CSV string of subarray to get max buffer sizes for
     * @param {string} contentType Content Type of input and return mime
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArrayMaxBufferSizes(namespace, array, subarray, contentType, xPayer, options) {
        return exports.ArrayApiFp(this.configuration).getArrayMaxBufferSizes(namespace, array, subarray, contentType, xPayer, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get metadata from the array in json format
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [length] (optional) limit character length of returned values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArrayMetaDataJson(namespace, array, length, options) {
        return exports.ArrayApiFp(this.configuration).getArrayMetaDataJson(namespace, array, length, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get metadata on an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArrayMetadata(namespace, array, options) {
        return exports.ArrayApiFp(this.configuration).getArrayMetadata(namespace, array, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get metadata on an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArrayMetadataCapnp(namespace, array, options) {
        return exports.ArrayApiFp(this.configuration).getArrayMetadataCapnp(namespace, array, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get the non empty domain of an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArrayNonEmptyDomain(namespace, array, contentType, xPayer, options) {
        return exports.ArrayApiFp(this.configuration).getArrayNonEmptyDomain(namespace, array, contentType, xPayer, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get non-empty domain from the array in json format
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArrayNonEmptyDomainJson(namespace, array, options) {
        return exports.ArrayApiFp(this.configuration).getArrayNonEmptyDomainJson(namespace, array, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get an sample set of data from the array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [samples] Number of sample results to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArraySampleData(namespace, array, samples, options) {
        return exports.ArrayApiFp(this.configuration).getArraySampleData(namespace, array, samples, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all sharing details of the array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArraySharingPolicies(namespace, array, options) {
        return exports.ArrayApiFp(this.configuration).getArraySharingPolicies(namespace, array, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get metadata on all arrays in a namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getArraysInNamespace(namespace, options) {
        return exports.ArrayApiFp(this.configuration).getArraysInNamespace(namespace, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    getLastAccessedArrays(options) {
        return exports.ArrayApiFp(this.configuration).getLastAccessedArrays(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * register an array at a specified URI registered to the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {ArrayInfoUpdate} arrayMetadata metadata associated with array
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    registerArray(namespace, array, arrayMetadata, options) {
        return exports.ArrayApiFp(this.configuration).registerArray(namespace, array, arrayMetadata, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Share an array with a user
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {ArraySharing} arraySharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace, if permissions already exist they will be deleted then new ones added. In the event of a failure, the new polcies will be rolled back to prevent partial policies, and its likely the array will not be shared with the namespace at all
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    shareArray(namespace, array, arraySharing, options) {
        return exports.ArrayApiFp(this.configuration).shareArray(namespace, array, arraySharing, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * update metadata on an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {ArrayInfoUpdate} arrayMetadata array metadata to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    updateArrayMetadata(namespace, array, arrayMetadata, options) {
        return exports.ArrayApiFp(this.configuration).updateArrayMetadata(namespace, array, arrayMetadata, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * update metadata on an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {ArrayMetadata} arrayMetadataEntries List of metadata entries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    updateArrayMetadataCapnp(namespace, array, arrayMetadataEntries, options) {
        return exports.ArrayApiFp(this.configuration).updateArrayMetadataCapnp(namespace, array, arrayMetadataEntries, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * vacuum an array at a specified URI
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {TileDBConfig} tiledbConfig tiledb configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    vacuumArray(namespace, array, tiledbConfig, options) {
        return exports.ArrayApiFp(this.configuration).vacuumArray(namespace, array, tiledbConfig, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ArrayApi = ArrayApi;
/**
 * ArrayTasksApi - axios parameter creator
 * @export
 */
const ArrayTasksApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {number} [start] Fetch tasks created after this time, unix epoch in seconds, default 7 days ago
         * @param {number} [end] Fetch tasks created before this time, unix epoch in seconds, default now
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayTasksSidebar: (start, end, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/tasks/sidebar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.ArrayTasksApiAxiosParamCreator = ArrayTasksApiAxiosParamCreator;
/**
 * ArrayTasksApi - functional programming interface
 * @export
 */
const ArrayTasksApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.ArrayTasksApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @param {number} [start] Fetch tasks created after this time, unix epoch in seconds, default 7 days ago
         * @param {number} [end] Fetch tasks created before this time, unix epoch in seconds, default now
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayTasksSidebar(start, end, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getArrayTasksSidebar(start, end, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.ArrayTasksApiFp = ArrayTasksApiFp;
/**
 * ArrayTasksApi - factory interface
 * @export
 */
const ArrayTasksApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.ArrayTasksApiFp(configuration);
    return {
        /**
         *
         * @param {number} [start] Fetch tasks created after this time, unix epoch in seconds, default 7 days ago
         * @param {number} [end] Fetch tasks created before this time, unix epoch in seconds, default now
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayTasksSidebar(start, end, options) {
            return localVarFp.getArrayTasksSidebar(start, end, options).then((request) => request(axios, basePath));
        },
    };
};
exports.ArrayTasksApiFactory = ArrayTasksApiFactory;
/**
 * ArrayTasksApi - object-oriented interface
 * @export
 * @class ArrayTasksApi
 * @extends {BaseAPI}
 */
class ArrayTasksApi extends base_1.BaseAPI {
    /**
     *
     * @param {number} [start] Fetch tasks created after this time, unix epoch in seconds, default 7 days ago
     * @param {number} [end] Fetch tasks created before this time, unix epoch in seconds, default now
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayTasksApi
     */
    getArrayTasksSidebar(start, end, options) {
        return exports.ArrayTasksApiFp(this.configuration).getArrayTasksSidebar(start, end, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ArrayTasksApi = ArrayTasksApi;
/**
 * FavoritesApi - axios parameter creator
 * @export
 */
const FavoritesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Add a new favorite
         * @param {FavoriteCreate} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFavorite: (body, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/favorites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(body, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete specific favorite
         * @param {string} id The uuid of the favorite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFavorite: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('deleteFavorite', 'id', id);
            const localVarPath = `/favorites/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch specific favorite of a user
         * @param {string} id The uuid of the favorite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFavorite: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('getFavorite', 'id', id);
            const localVarPath = `/favorites/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch all favorites of connected user
         * @param {string} [type] The type of the desired favorites e.g. arrays
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFavorites: (type, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/favorites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.FavoritesApiAxiosParamCreator = FavoritesApiAxiosParamCreator;
/**
 * FavoritesApi - functional programming interface
 * @export
 */
const FavoritesApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.FavoritesApiAxiosParamCreator(configuration);
    return {
        /**
         * Add a new favorite
         * @param {FavoriteCreate} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFavorite(body, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.addFavorite(body, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Delete specific favorite
         * @param {string} id The uuid of the favorite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFavorite(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteFavorite(id, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch specific favorite of a user
         * @param {string} id The uuid of the favorite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFavorite(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getFavorite(id, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch all favorites of connected user
         * @param {string} [type] The type of the desired favorites e.g. arrays
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFavorites(type, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listFavorites(type, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.FavoritesApiFp = FavoritesApiFp;
/**
 * FavoritesApi - factory interface
 * @export
 */
const FavoritesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.FavoritesApiFp(configuration);
    return {
        /**
         * Add a new favorite
         * @param {FavoriteCreate} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFavorite(body, options) {
            return localVarFp.addFavorite(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete specific favorite
         * @param {string} id The uuid of the favorite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFavorite(id, options) {
            return localVarFp.deleteFavorite(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch specific favorite of a user
         * @param {string} id The uuid of the favorite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFavorite(id, options) {
            return localVarFp.getFavorite(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch all favorites of connected user
         * @param {string} [type] The type of the desired favorites e.g. arrays
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFavorites(type, options) {
            return localVarFp.listFavorites(type, options).then((request) => request(axios, basePath));
        },
    };
};
exports.FavoritesApiFactory = FavoritesApiFactory;
/**
 * FavoritesApi - object-oriented interface
 * @export
 * @class FavoritesApi
 * @extends {BaseAPI}
 */
class FavoritesApi extends base_1.BaseAPI {
    /**
     * Add a new favorite
     * @param {FavoriteCreate} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    addFavorite(body, options) {
        return exports.FavoritesApiFp(this.configuration).addFavorite(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete specific favorite
     * @param {string} id The uuid of the favorite
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    deleteFavorite(id, options) {
        return exports.FavoritesApiFp(this.configuration).deleteFavorite(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch specific favorite of a user
     * @param {string} id The uuid of the favorite
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    getFavorite(id, options) {
        return exports.FavoritesApiFp(this.configuration).getFavorite(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch all favorites of connected user
     * @param {string} [type] The type of the desired favorites e.g. arrays
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    listFavorites(type, options) {
        return exports.FavoritesApiFp(this.configuration).listFavorites(type, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.FavoritesApi = FavoritesApi;
/**
 * InvitationApi - axios parameter creator
 * @export
 */
const InvitationApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Accepts invitation
         * @param {string} invitation the id of invitation about to be accepted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvitation: (invitation, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'invitation' is not null or undefined
            common_1.assertParamExists('acceptInvitation', 'invitation', invitation);
            const localVarPath = `/invitations/{invitation}`
                .replace(`{${"invitation"}}`, encodeURIComponent(String(invitation)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Cancels join organization invitation
         * @param {string} invitation the id of invitation about to be cancelled
         * @param {string} organization name or uuid of organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelJoinOrganization: (invitation, organization, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'invitation' is not null or undefined
            common_1.assertParamExists('cancelJoinOrganization', 'invitation', invitation);
            // verify required parameter 'organization' is not null or undefined
            common_1.assertParamExists('cancelJoinOrganization', 'organization', organization);
            const localVarPath = `/invitations/{invitation}/{organization}/join`
                .replace(`{${"invitation"}}`, encodeURIComponent(String(invitation)))
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Cancels array sharing invitation
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} invitation the id of invitation about to be cancelled
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelShareArrayByInvite: (namespace, invitation, array, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('cancelShareArrayByInvite', 'namespace', namespace);
            // verify required parameter 'invitation' is not null or undefined
            common_1.assertParamExists('cancelShareArrayByInvite', 'invitation', invitation);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('cancelShareArrayByInvite', 'array', array);
            const localVarPath = `/invitations/{invitation}/{namespace}/{array}/share`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"invitation"}}`, encodeURIComponent(String(invitation)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch a list of invitations
         * @param {string} [organization] name or id of organization to filter
         * @param {string} [array] name/uri of array that is url-encoded to filter
         * @param {number} [start] start time for tasks to filter by
         * @param {number} [end] end time for tasks to filter by
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [type] invitation type, \&quot;ARRAY_SHARE\&quot;, \&quot;JOIN_ORGANIZATION\&quot;
         * @param {string} [status] Filter to only return \&quot;PENDING\&quot;, \&quot;ACCEPTED\&quot;
         * @param {string} [orderby] sort by which field valid values include timestamp, array_name, organization_name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchInvitations: (organization, array, start, end, page, perPage, type, status, orderby, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/invitations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (organization !== undefined) {
                localVarQueryParameter['organization'] = organization;
            }
            if (array !== undefined) {
                localVarQueryParameter['array'] = array;
            }
            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (orderby !== undefined) {
                localVarQueryParameter['orderby'] = orderby;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Sends email to multiple recipients with joining information regarding an organization
         * @param {string} organization name or uuid of organization
         * @param {InvitationOrganizationJoinEmail} emailInvite list of email recipients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinOrganization: (organization, emailInvite, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organization' is not null or undefined
            common_1.assertParamExists('joinOrganization', 'organization', organization);
            // verify required parameter 'emailInvite' is not null or undefined
            common_1.assertParamExists('joinOrganization', 'emailInvite', emailInvite);
            const localVarPath = `/invitations/{organization}/join`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(emailInvite, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Sends email to multiple recipients with sharing information regarding an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {InvitationArrayShareEmail} emailInvite list of email recipients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareArrayByInvite: (namespace, array, emailInvite, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('shareArrayByInvite', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('shareArrayByInvite', 'array', array);
            // verify required parameter 'emailInvite' is not null or undefined
            common_1.assertParamExists('shareArrayByInvite', 'emailInvite', emailInvite);
            const localVarPath = `/invitations/{namespace}/{array}/share`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(emailInvite, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.InvitationApiAxiosParamCreator = InvitationApiAxiosParamCreator;
/**
 * InvitationApi - functional programming interface
 * @export
 */
const InvitationApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.InvitationApiAxiosParamCreator(configuration);
    return {
        /**
         * Accepts invitation
         * @param {string} invitation the id of invitation about to be accepted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvitation(invitation, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.acceptInvitation(invitation, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Cancels join organization invitation
         * @param {string} invitation the id of invitation about to be cancelled
         * @param {string} organization name or uuid of organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelJoinOrganization(invitation, organization, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.cancelJoinOrganization(invitation, organization, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Cancels array sharing invitation
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} invitation the id of invitation about to be cancelled
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelShareArrayByInvite(namespace, invitation, array, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.cancelShareArrayByInvite(namespace, invitation, array, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch a list of invitations
         * @param {string} [organization] name or id of organization to filter
         * @param {string} [array] name/uri of array that is url-encoded to filter
         * @param {number} [start] start time for tasks to filter by
         * @param {number} [end] end time for tasks to filter by
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [type] invitation type, \&quot;ARRAY_SHARE\&quot;, \&quot;JOIN_ORGANIZATION\&quot;
         * @param {string} [status] Filter to only return \&quot;PENDING\&quot;, \&quot;ACCEPTED\&quot;
         * @param {string} [orderby] sort by which field valid values include timestamp, array_name, organization_name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchInvitations(organization, array, start, end, page, perPage, type, status, orderby, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.fetchInvitations(organization, array, start, end, page, perPage, type, status, orderby, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Sends email to multiple recipients with joining information regarding an organization
         * @param {string} organization name or uuid of organization
         * @param {InvitationOrganizationJoinEmail} emailInvite list of email recipients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinOrganization(organization, emailInvite, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.joinOrganization(organization, emailInvite, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Sends email to multiple recipients with sharing information regarding an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {InvitationArrayShareEmail} emailInvite list of email recipients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareArrayByInvite(namespace, array, emailInvite, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.shareArrayByInvite(namespace, array, emailInvite, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.InvitationApiFp = InvitationApiFp;
/**
 * InvitationApi - factory interface
 * @export
 */
const InvitationApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.InvitationApiFp(configuration);
    return {
        /**
         * Accepts invitation
         * @param {string} invitation the id of invitation about to be accepted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvitation(invitation, options) {
            return localVarFp.acceptInvitation(invitation, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancels join organization invitation
         * @param {string} invitation the id of invitation about to be cancelled
         * @param {string} organization name or uuid of organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelJoinOrganization(invitation, organization, options) {
            return localVarFp.cancelJoinOrganization(invitation, organization, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancels array sharing invitation
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} invitation the id of invitation about to be cancelled
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelShareArrayByInvite(namespace, invitation, array, options) {
            return localVarFp.cancelShareArrayByInvite(namespace, invitation, array, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of invitations
         * @param {string} [organization] name or id of organization to filter
         * @param {string} [array] name/uri of array that is url-encoded to filter
         * @param {number} [start] start time for tasks to filter by
         * @param {number} [end] end time for tasks to filter by
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [type] invitation type, \&quot;ARRAY_SHARE\&quot;, \&quot;JOIN_ORGANIZATION\&quot;
         * @param {string} [status] Filter to only return \&quot;PENDING\&quot;, \&quot;ACCEPTED\&quot;
         * @param {string} [orderby] sort by which field valid values include timestamp, array_name, organization_name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchInvitations(organization, array, start, end, page, perPage, type, status, orderby, options) {
            return localVarFp.fetchInvitations(organization, array, start, end, page, perPage, type, status, orderby, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends email to multiple recipients with joining information regarding an organization
         * @param {string} organization name or uuid of organization
         * @param {InvitationOrganizationJoinEmail} emailInvite list of email recipients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinOrganization(organization, emailInvite, options) {
            return localVarFp.joinOrganization(organization, emailInvite, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends email to multiple recipients with sharing information regarding an array
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {InvitationArrayShareEmail} emailInvite list of email recipients
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareArrayByInvite(namespace, array, emailInvite, options) {
            return localVarFp.shareArrayByInvite(namespace, array, emailInvite, options).then((request) => request(axios, basePath));
        },
    };
};
exports.InvitationApiFactory = InvitationApiFactory;
/**
 * InvitationApi - object-oriented interface
 * @export
 * @class InvitationApi
 * @extends {BaseAPI}
 */
class InvitationApi extends base_1.BaseAPI {
    /**
     * Accepts invitation
     * @param {string} invitation the id of invitation about to be accepted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    acceptInvitation(invitation, options) {
        return exports.InvitationApiFp(this.configuration).acceptInvitation(invitation, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Cancels join organization invitation
     * @param {string} invitation the id of invitation about to be cancelled
     * @param {string} organization name or uuid of organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    cancelJoinOrganization(invitation, organization, options) {
        return exports.InvitationApiFp(this.configuration).cancelJoinOrganization(invitation, organization, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Cancels array sharing invitation
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} invitation the id of invitation about to be cancelled
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    cancelShareArrayByInvite(namespace, invitation, array, options) {
        return exports.InvitationApiFp(this.configuration).cancelShareArrayByInvite(namespace, invitation, array, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a list of invitations
     * @param {string} [organization] name or id of organization to filter
     * @param {string} [array] name/uri of array that is url-encoded to filter
     * @param {number} [start] start time for tasks to filter by
     * @param {number} [end] end time for tasks to filter by
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [type] invitation type, \&quot;ARRAY_SHARE\&quot;, \&quot;JOIN_ORGANIZATION\&quot;
     * @param {string} [status] Filter to only return \&quot;PENDING\&quot;, \&quot;ACCEPTED\&quot;
     * @param {string} [orderby] sort by which field valid values include timestamp, array_name, organization_name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    fetchInvitations(organization, array, start, end, page, perPage, type, status, orderby, options) {
        return exports.InvitationApiFp(this.configuration).fetchInvitations(organization, array, start, end, page, perPage, type, status, orderby, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sends email to multiple recipients with joining information regarding an organization
     * @param {string} organization name or uuid of organization
     * @param {InvitationOrganizationJoinEmail} emailInvite list of email recipients
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    joinOrganization(organization, emailInvite, options) {
        return exports.InvitationApiFp(this.configuration).joinOrganization(organization, emailInvite, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sends email to multiple recipients with sharing information regarding an array
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {InvitationArrayShareEmail} emailInvite list of email recipients
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    shareArrayByInvite(namespace, array, emailInvite, options) {
        return exports.InvitationApiFp(this.configuration).shareArrayByInvite(namespace, array, emailInvite, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.InvitationApi = InvitationApi;
/**
 * NotebookApi - axios parameter creator
 * @export
 */
const NotebookApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get status of the notebook server
         * @param {string} namespace namespace notebook is in (an organization name or user\&#39;s username)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotebookServerStatus: (namespace, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getNotebookServerStatus', 'namespace', namespace);
            const localVarPath = `/notebooks/server/{namespace}/status`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Shutdown a notebook server
         * @param {string} namespace namespace notebook is in (an organization name or user\&#39;s username)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shutdownNotebookServer: (namespace, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('shutdownNotebookServer', 'namespace', namespace);
            const localVarPath = `/notebooks/server/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * update name on a notebok, moving related s3 object to new location
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of notebook (array) that is url-encoded
         * @param {ArrayInfoUpdate} notebookMetadata notebook (array) metadata to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotebookName: (namespace, array, notebookMetadata, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('updateNotebookName', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('updateNotebookName', 'array', array);
            // verify required parameter 'notebookMetadata' is not null or undefined
            common_1.assertParamExists('updateNotebookName', 'notebookMetadata', notebookMetadata);
            const localVarPath = `/notebooks/{namespace}/{array}/rename`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(notebookMetadata, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.NotebookApiAxiosParamCreator = NotebookApiAxiosParamCreator;
/**
 * NotebookApi - functional programming interface
 * @export
 */
const NotebookApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.NotebookApiAxiosParamCreator(configuration);
    return {
        /**
         * Get status of the notebook server
         * @param {string} namespace namespace notebook is in (an organization name or user\&#39;s username)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotebookServerStatus(namespace, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getNotebookServerStatus(namespace, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Shutdown a notebook server
         * @param {string} namespace namespace notebook is in (an organization name or user\&#39;s username)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shutdownNotebookServer(namespace, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.shutdownNotebookServer(namespace, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * update name on a notebok, moving related s3 object to new location
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of notebook (array) that is url-encoded
         * @param {ArrayInfoUpdate} notebookMetadata notebook (array) metadata to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotebookName(namespace, array, notebookMetadata, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateNotebookName(namespace, array, notebookMetadata, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.NotebookApiFp = NotebookApiFp;
/**
 * NotebookApi - factory interface
 * @export
 */
const NotebookApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.NotebookApiFp(configuration);
    return {
        /**
         * Get status of the notebook server
         * @param {string} namespace namespace notebook is in (an organization name or user\&#39;s username)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotebookServerStatus(namespace, options) {
            return localVarFp.getNotebookServerStatus(namespace, options).then((request) => request(axios, basePath));
        },
        /**
         * Shutdown a notebook server
         * @param {string} namespace namespace notebook is in (an organization name or user\&#39;s username)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shutdownNotebookServer(namespace, options) {
            return localVarFp.shutdownNotebookServer(namespace, options).then((request) => request(axios, basePath));
        },
        /**
         * update name on a notebok, moving related s3 object to new location
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of notebook (array) that is url-encoded
         * @param {ArrayInfoUpdate} notebookMetadata notebook (array) metadata to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotebookName(namespace, array, notebookMetadata, options) {
            return localVarFp.updateNotebookName(namespace, array, notebookMetadata, options).then((request) => request(axios, basePath));
        },
    };
};
exports.NotebookApiFactory = NotebookApiFactory;
/**
 * NotebookApi - object-oriented interface
 * @export
 * @class NotebookApi
 * @extends {BaseAPI}
 */
class NotebookApi extends base_1.BaseAPI {
    /**
     * Get status of the notebook server
     * @param {string} namespace namespace notebook is in (an organization name or user\&#39;s username)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotebookApi
     */
    getNotebookServerStatus(namespace, options) {
        return exports.NotebookApiFp(this.configuration).getNotebookServerStatus(namespace, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Shutdown a notebook server
     * @param {string} namespace namespace notebook is in (an organization name or user\&#39;s username)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotebookApi
     */
    shutdownNotebookServer(namespace, options) {
        return exports.NotebookApiFp(this.configuration).shutdownNotebookServer(namespace, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * update name on a notebok, moving related s3 object to new location
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of notebook (array) that is url-encoded
     * @param {ArrayInfoUpdate} notebookMetadata notebook (array) metadata to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotebookApi
     */
    updateNotebookName(namespace, array, notebookMetadata, options) {
        return exports.NotebookApiFp(this.configuration).updateNotebookName(namespace, array, notebookMetadata, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.NotebookApi = NotebookApi;
/**
 * NotebooksApi - axios parameter creator
 * @export
 */
const NotebooksApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * retrieve a list of timestamps from the array fragment info listing in milliseconds
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notebooksNamespaceArrayVersionsGet: (namespace, array, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('notebooksNamespaceArrayVersionsGet', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('notebooksNamespaceArrayVersionsGet', 'array', array);
            const localVarPath = `/notebooks/{namespace}/{array}/versions`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.NotebooksApiAxiosParamCreator = NotebooksApiAxiosParamCreator;
/**
 * NotebooksApi - functional programming interface
 * @export
 */
const NotebooksApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.NotebooksApiAxiosParamCreator(configuration);
    return {
        /**
         * retrieve a list of timestamps from the array fragment info listing in milliseconds
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notebooksNamespaceArrayVersionsGet(namespace, array, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.notebooksNamespaceArrayVersionsGet(namespace, array, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.NotebooksApiFp = NotebooksApiFp;
/**
 * NotebooksApi - factory interface
 * @export
 */
const NotebooksApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.NotebooksApiFp(configuration);
    return {
        /**
         * retrieve a list of timestamps from the array fragment info listing in milliseconds
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notebooksNamespaceArrayVersionsGet(namespace, array, options) {
            return localVarFp.notebooksNamespaceArrayVersionsGet(namespace, array, options).then((request) => request(axios, basePath));
        },
    };
};
exports.NotebooksApiFactory = NotebooksApiFactory;
/**
 * NotebooksApi - object-oriented interface
 * @export
 * @class NotebooksApi
 * @extends {BaseAPI}
 */
class NotebooksApi extends base_1.BaseAPI {
    /**
     * retrieve a list of timestamps from the array fragment info listing in milliseconds
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotebooksApi
     */
    notebooksNamespaceArrayVersionsGet(namespace, array, options) {
        return exports.NotebooksApiFp(this.configuration).notebooksNamespaceArrayVersionsGet(namespace, array, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.NotebooksApi = NotebooksApi;
/**
 * OrganizationApi - axios parameter creator
 * @export
 */
const OrganizationApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Add aws keys
         * @param {string} namespace namespace
         * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAWSAccessCredentials: (namespace, awsAccessCredentials, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('addAWSAccessCredentials', 'namespace', namespace);
            // verify required parameter 'awsAccessCredentials' is not null or undefined
            common_1.assertParamExists('addAWSAccessCredentials', 'awsAccessCredentials', awsAccessCredentials);
            const localVarPath = `/credentials/{namespace}/aws`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(awsAccessCredentials, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * add a user to an organization
         * @param {string} organization organization name
         * @param {OrganizationUser} user user to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToOrganization: (organization, user, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organization' is not null or undefined
            common_1.assertParamExists('addUserToOrganization', 'organization', organization);
            // verify required parameter 'user' is not null or undefined
            common_1.assertParamExists('addUserToOrganization', 'user', user);
            const localVarPath = `/organizations/{organization}/user`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(user, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Check if aws keys are set
         * @param {string} namespace namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentials: (namespace, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('checkAWSAccessCredentials', 'namespace', namespace);
            const localVarPath = `/credentials/{namespace}/aws`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Check if aws keys are set by name
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentialsByName: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('checkAWSAccessCredentialsByName', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('checkAWSAccessCredentialsByName', 'name', name);
            const localVarPath = `/credentials/{namespace}/aws/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * create a organization, the user creating will be listed as owner
         * @param {Organization} organization organization to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization: (organization, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organization' is not null or undefined
            common_1.assertParamExists('createOrganization', 'organization', organization);
            const localVarPath = `/organization`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(organization, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAWSAccessCredentials: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('deleteAWSAccessCredentials', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('deleteAWSAccessCredentials', 'name', name);
            const localVarPath = `/credentials/{namespace}/aws/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * delete a organization
         * @param {string} organization organization name or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganization: (organization, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organization' is not null or undefined
            common_1.assertParamExists('deleteOrganization', 'organization', organization);
            const localVarPath = `/organizations/{organization}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * delete a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFromOrganization: (organization, username, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organization' is not null or undefined
            common_1.assertParamExists('deleteUserFromOrganization', 'organization', organization);
            // verify required parameter 'username' is not null or undefined
            common_1.assertParamExists('deleteUserFromOrganization', 'username', username);
            const localVarPath = `/organizations/{organization}/{username}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get all organizations that the user is member of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOrganizations: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get a organization
         * @param {string} organization organization name or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization: (organization, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organization' is not null or undefined
            common_1.assertParamExists('getOrganization', 'organization', organization);
            const localVarPath = `/organizations/{organization}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUser: (organization, username, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organization' is not null or undefined
            common_1.assertParamExists('getOrganizationUser', 'organization', organization);
            // verify required parameter 'username' is not null or undefined
            common_1.assertParamExists('getOrganizationUser', 'username', username);
            const localVarPath = `/organizations/{organization}/{username}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAWSAccessCredentials: (namespace, name, awsAccessCredentials, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('updateAWSAccessCredentials', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('updateAWSAccessCredentials', 'name', name);
            // verify required parameter 'awsAccessCredentials' is not null or undefined
            common_1.assertParamExists('updateAWSAccessCredentials', 'awsAccessCredentials', awsAccessCredentials);
            const localVarPath = `/credentials/{namespace}/aws/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(awsAccessCredentials, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * update a organization
         * @param {string} organization organization name or id
         * @param {Organization} organizationDetails organization details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization: (organization, organizationDetails, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organization' is not null or undefined
            common_1.assertParamExists('updateOrganization', 'organization', organization);
            // verify required parameter 'organizationDetails' is not null or undefined
            common_1.assertParamExists('updateOrganization', 'organizationDetails', organizationDetails);
            const localVarPath = `/organizations/{organization}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(organizationDetails, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * update a user in an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {OrganizationUser} user user details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserInOrganization: (organization, username, user, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organization' is not null or undefined
            common_1.assertParamExists('updateUserInOrganization', 'organization', organization);
            // verify required parameter 'username' is not null or undefined
            common_1.assertParamExists('updateUserInOrganization', 'username', username);
            // verify required parameter 'user' is not null or undefined
            common_1.assertParamExists('updateUserInOrganization', 'user', user);
            const localVarPath = `/organizations/{organization}/{username}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(user, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.OrganizationApiAxiosParamCreator = OrganizationApiAxiosParamCreator;
/**
 * OrganizationApi - functional programming interface
 * @export
 */
const OrganizationApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.OrganizationApiAxiosParamCreator(configuration);
    return {
        /**
         * Add aws keys
         * @param {string} namespace namespace
         * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAWSAccessCredentials(namespace, awsAccessCredentials, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.addAWSAccessCredentials(namespace, awsAccessCredentials, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * add a user to an organization
         * @param {string} organization organization name
         * @param {OrganizationUser} user user to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToOrganization(organization, user, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.addUserToOrganization(organization, user, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Check if aws keys are set
         * @param {string} namespace namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentials(namespace, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.checkAWSAccessCredentials(namespace, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Check if aws keys are set by name
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentialsByName(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.checkAWSAccessCredentialsByName(namespace, name, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * create a organization, the user creating will be listed as owner
         * @param {Organization} organization organization to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization(organization, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createOrganization(organization, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAWSAccessCredentials(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteAWSAccessCredentials(namespace, name, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * delete a organization
         * @param {string} organization organization name or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganization(organization, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteOrganization(organization, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * delete a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFromOrganization(organization, username, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteUserFromOrganization(organization, username, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * get all organizations that the user is member of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOrganizations(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllOrganizations(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * get a organization
         * @param {string} organization organization name or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization(organization, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getOrganization(organization, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * get a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUser(organization, username, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getOrganizationUser(organization, username, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * update a organization
         * @param {string} organization organization name or id
         * @param {Organization} organizationDetails organization details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization(organization, organizationDetails, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateOrganization(organization, organizationDetails, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * update a user in an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {OrganizationUser} user user details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserInOrganization(organization, username, user, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateUserInOrganization(organization, username, user, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.OrganizationApiFp = OrganizationApiFp;
/**
 * OrganizationApi - factory interface
 * @export
 */
const OrganizationApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.OrganizationApiFp(configuration);
    return {
        /**
         * Add aws keys
         * @param {string} namespace namespace
         * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAWSAccessCredentials(namespace, awsAccessCredentials, options) {
            return localVarFp.addAWSAccessCredentials(namespace, awsAccessCredentials, options).then((request) => request(axios, basePath));
        },
        /**
         * add a user to an organization
         * @param {string} organization organization name
         * @param {OrganizationUser} user user to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToOrganization(organization, user, options) {
            return localVarFp.addUserToOrganization(organization, user, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if aws keys are set
         * @param {string} namespace namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentials(namespace, options) {
            return localVarFp.checkAWSAccessCredentials(namespace, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if aws keys are set by name
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentialsByName(namespace, name, options) {
            return localVarFp.checkAWSAccessCredentialsByName(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * create a organization, the user creating will be listed as owner
         * @param {Organization} organization organization to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization(organization, options) {
            return localVarFp.createOrganization(organization, options).then((request) => request(axios, basePath));
        },
        /**
         * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAWSAccessCredentials(namespace, name, options) {
            return localVarFp.deleteAWSAccessCredentials(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * delete a organization
         * @param {string} organization organization name or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrganization(organization, options) {
            return localVarFp.deleteOrganization(organization, options).then((request) => request(axios, basePath));
        },
        /**
         * delete a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFromOrganization(organization, username, options) {
            return localVarFp.deleteUserFromOrganization(organization, username, options).then((request) => request(axios, basePath));
        },
        /**
         * get all organizations that the user is member of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOrganizations(options) {
            return localVarFp.getAllOrganizations(options).then((request) => request(axios, basePath));
        },
        /**
         * get a organization
         * @param {string} organization organization name or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganization(organization, options) {
            return localVarFp.getOrganization(organization, options).then((request) => request(axios, basePath));
        },
        /**
         * get a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUser(organization, username, options) {
            return localVarFp.getOrganizationUser(organization, username, options).then((request) => request(axios, basePath));
        },
        /**
         * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options) {
            return localVarFp.updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options).then((request) => request(axios, basePath));
        },
        /**
         * update a organization
         * @param {string} organization organization name or id
         * @param {Organization} organizationDetails organization details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrganization(organization, organizationDetails, options) {
            return localVarFp.updateOrganization(organization, organizationDetails, options).then((request) => request(axios, basePath));
        },
        /**
         * update a user in an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {OrganizationUser} user user details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserInOrganization(organization, username, user, options) {
            return localVarFp.updateUserInOrganization(organization, username, user, options).then((request) => request(axios, basePath));
        },
    };
};
exports.OrganizationApiFactory = OrganizationApiFactory;
/**
 * OrganizationApi - object-oriented interface
 * @export
 * @class OrganizationApi
 * @extends {BaseAPI}
 */
class OrganizationApi extends base_1.BaseAPI {
    /**
     * Add aws keys
     * @param {string} namespace namespace
     * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    addAWSAccessCredentials(namespace, awsAccessCredentials, options) {
        return exports.OrganizationApiFp(this.configuration).addAWSAccessCredentials(namespace, awsAccessCredentials, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * add a user to an organization
     * @param {string} organization organization name
     * @param {OrganizationUser} user user to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    addUserToOrganization(organization, user, options) {
        return exports.OrganizationApiFp(this.configuration).addUserToOrganization(organization, user, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Check if aws keys are set
     * @param {string} namespace namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    checkAWSAccessCredentials(namespace, options) {
        return exports.OrganizationApiFp(this.configuration).checkAWSAccessCredentials(namespace, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Check if aws keys are set by name
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    checkAWSAccessCredentialsByName(namespace, name, options) {
        return exports.OrganizationApiFp(this.configuration).checkAWSAccessCredentialsByName(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * create a organization, the user creating will be listed as owner
     * @param {Organization} organization organization to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    createOrganization(organization, options) {
        return exports.OrganizationApiFp(this.configuration).createOrganization(organization, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    deleteAWSAccessCredentials(namespace, name, options) {
        return exports.OrganizationApiFp(this.configuration).deleteAWSAccessCredentials(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * delete a organization
     * @param {string} organization organization name or id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    deleteOrganization(organization, options) {
        return exports.OrganizationApiFp(this.configuration).deleteOrganization(organization, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * delete a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    deleteUserFromOrganization(organization, username, options) {
        return exports.OrganizationApiFp(this.configuration).deleteUserFromOrganization(organization, username, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get all organizations that the user is member of
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    getAllOrganizations(options) {
        return exports.OrganizationApiFp(this.configuration).getAllOrganizations(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get a organization
     * @param {string} organization organization name or id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    getOrganization(organization, options) {
        return exports.OrganizationApiFp(this.configuration).getOrganization(organization, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    getOrganizationUser(organization, username, options) {
        return exports.OrganizationApiFp(this.configuration).getOrganizationUser(organization, username, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options) {
        return exports.OrganizationApiFp(this.configuration).updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * update a organization
     * @param {string} organization organization name or id
     * @param {Organization} organizationDetails organization details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    updateOrganization(organization, organizationDetails, options) {
        return exports.OrganizationApiFp(this.configuration).updateOrganization(organization, organizationDetails, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * update a user in an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {OrganizationUser} user user details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    updateUserInOrganization(organization, username, user, options) {
        return exports.OrganizationApiFp(this.configuration).updateUserInOrganization(organization, username, user, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.OrganizationApi = OrganizationApi;
/**
 * QueryApi - axios parameter creator
 * @export
 */
const QueryApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finalizeQuery: (namespace, array, type, contentType, query, xPayer, openAt, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('finalizeQuery', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('finalizeQuery', 'array', array);
            // verify required parameter 'type' is not null or undefined
            common_1.assertParamExists('finalizeQuery', 'type', type);
            // verify required parameter 'contentType' is not null or undefined
            common_1.assertParamExists('finalizeQuery', 'contentType', contentType);
            // verify required parameter 'query' is not null or undefined
            common_1.assertParamExists('finalizeQuery', 'query', query);
            const localVarPath = `/arrays/{namespace}/{array}/query/finalize`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (openAt !== undefined) {
                localVarQueryParameter['open_at'] = openAt;
            }
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (xPayer !== undefined && xPayer !== null) {
                localVarHeaderParameter['X-Payer'] = String(xPayer);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(query, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEstResultSizes: (namespace, array, type, contentType, query, xPayer, openAt, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getEstResultSizes', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('getEstResultSizes', 'array', array);
            // verify required parameter 'type' is not null or undefined
            common_1.assertParamExists('getEstResultSizes', 'type', type);
            // verify required parameter 'contentType' is not null or undefined
            common_1.assertParamExists('getEstResultSizes', 'contentType', contentType);
            // verify required parameter 'query' is not null or undefined
            common_1.assertParamExists('getEstResultSizes', 'query', query);
            const localVarPath = `/arrays/{namespace}/{array}/query/est_result_sizes`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (openAt !== undefined) {
                localVarQueryParameter['open_at'] = openAt;
            }
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (xPayer !== undefined && xPayer !== null) {
                localVarHeaderParameter['X-Payer'] = String(xPayer);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(query, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * send a query to run against a specified array/URI registered to a group/project, returns file bytes
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile: (namespace, array, contentType, xPayer, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getFile', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('getFile', 'array', array);
            // verify required parameter 'contentType' is not null or undefined
            common_1.assertParamExists('getFile', 'contentType', contentType);
            const localVarPath = `/arrays/{namespace}/{array}/query/get_file`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (xPayer !== undefined && xPayer !== null) {
                localVarHeaderParameter['X-Payer'] = String(xPayer);
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitQuery: (namespace, array, type, contentType, query, xPayer, openAt, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('submitQuery', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('submitQuery', 'array', array);
            // verify required parameter 'type' is not null or undefined
            common_1.assertParamExists('submitQuery', 'type', type);
            // verify required parameter 'contentType' is not null or undefined
            common_1.assertParamExists('submitQuery', 'contentType', contentType);
            // verify required parameter 'query' is not null or undefined
            common_1.assertParamExists('submitQuery', 'query', query);
            const localVarPath = `/arrays/{namespace}/{array}/query/submit`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (openAt !== undefined) {
                localVarQueryParameter['open_at'] = openAt;
            }
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (xPayer !== undefined && xPayer !== null) {
                localVarHeaderParameter['X-Payer'] = String(xPayer);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(query, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * send a query to run against a specified array/URI registered to a group/project, returns json results
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {QueryJson} queryJson query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitQueryJson: (namespace, array, contentType, queryJson, xPayer, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('submitQueryJson', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('submitQueryJson', 'array', array);
            // verify required parameter 'contentType' is not null or undefined
            common_1.assertParamExists('submitQueryJson', 'contentType', contentType);
            // verify required parameter 'queryJson' is not null or undefined
            common_1.assertParamExists('submitQueryJson', 'queryJson', queryJson);
            const localVarPath = `/arrays/{namespace}/{array}/query/submit_query_json`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (xPayer !== undefined && xPayer !== null) {
                localVarHeaderParameter['X-Payer'] = String(xPayer);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(queryJson, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.QueryApiAxiosParamCreator = QueryApiAxiosParamCreator;
/**
 * QueryApi - functional programming interface
 * @export
 */
const QueryApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.QueryApiAxiosParamCreator(configuration);
    return {
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finalizeQuery(namespace, array, type, contentType, query, xPayer, openAt, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.finalizeQuery(namespace, array, type, contentType, query, xPayer, openAt, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEstResultSizes(namespace, array, type, contentType, query, xPayer, openAt, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getEstResultSizes(namespace, array, type, contentType, query, xPayer, openAt, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * send a query to run against a specified array/URI registered to a group/project, returns file bytes
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile(namespace, array, contentType, xPayer, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getFile(namespace, array, contentType, xPayer, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitQuery(namespace, array, type, contentType, query, xPayer, openAt, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.submitQuery(namespace, array, type, contentType, query, xPayer, openAt, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * send a query to run against a specified array/URI registered to a group/project, returns json results
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {QueryJson} queryJson query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitQueryJson(namespace, array, contentType, queryJson, xPayer, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.submitQueryJson(namespace, array, contentType, queryJson, xPayer, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.QueryApiFp = QueryApiFp;
/**
 * QueryApi - factory interface
 * @export
 */
const QueryApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.QueryApiFp(configuration);
    return {
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        finalizeQuery(namespace, array, type, contentType, query, xPayer, openAt, options) {
            return localVarFp.finalizeQuery(namespace, array, type, contentType, query, xPayer, openAt, options).then((request) => request(axios, basePath));
        },
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEstResultSizes(namespace, array, type, contentType, query, xPayer, openAt, options) {
            return localVarFp.getEstResultSizes(namespace, array, type, contentType, query, xPayer, openAt, options).then((request) => request(axios, basePath));
        },
        /**
         * send a query to run against a specified array/URI registered to a group/project, returns file bytes
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile(namespace, array, contentType, xPayer, options) {
            return localVarFp.getFile(namespace, array, contentType, xPayer, options).then((request) => request(axios, basePath));
        },
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitQuery(namespace, array, type, contentType, query, xPayer, openAt, options) {
            return localVarFp.submitQuery(namespace, array, type, contentType, query, xPayer, openAt, options).then((request) => request(axios, basePath));
        },
        /**
         * send a query to run against a specified array/URI registered to a group/project, returns json results
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} contentType Content Type of input and return mime
         * @param {QueryJson} queryJson query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitQueryJson(namespace, array, contentType, queryJson, xPayer, options) {
            return localVarFp.submitQueryJson(namespace, array, contentType, queryJson, xPayer, options).then((request) => request(axios, basePath));
        },
    };
};
exports.QueryApiFactory = QueryApiFactory;
/**
 * QueryApi - object-oriented interface
 * @export
 * @class QueryApi
 * @extends {BaseAPI}
 */
class QueryApi extends base_1.BaseAPI {
    /**
     * send a query to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} type type of query
     * @param {string} contentType Content Type of input and return mime
     * @param {Query} query query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {number} [openAt] open_at for array in unix epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    finalizeQuery(namespace, array, type, contentType, query, xPayer, openAt, options) {
        return exports.QueryApiFp(this.configuration).finalizeQuery(namespace, array, type, contentType, query, xPayer, openAt, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * send a query to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} type type of query
     * @param {string} contentType Content Type of input and return mime
     * @param {Query} query query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {number} [openAt] open_at for array in unix epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    getEstResultSizes(namespace, array, type, contentType, query, xPayer, openAt, options) {
        return exports.QueryApiFp(this.configuration).getEstResultSizes(namespace, array, type, contentType, query, xPayer, openAt, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * send a query to run against a specified array/URI registered to a group/project, returns file bytes
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    getFile(namespace, array, contentType, xPayer, options) {
        return exports.QueryApiFp(this.configuration).getFile(namespace, array, contentType, xPayer, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * send a query to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} type type of query
     * @param {string} contentType Content Type of input and return mime
     * @param {Query} query query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {number} [openAt] open_at for array in unix epoch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    submitQuery(namespace, array, type, contentType, query, xPayer, openAt, options) {
        return exports.QueryApiFp(this.configuration).submitQuery(namespace, array, type, contentType, query, xPayer, openAt, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * send a query to run against a specified array/URI registered to a group/project, returns json results
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} contentType Content Type of input and return mime
     * @param {QueryJson} queryJson query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    submitQueryJson(namespace, array, contentType, queryJson, xPayer, options) {
        return exports.QueryApiFp(this.configuration).submitQueryJson(namespace, array, contentType, queryJson, xPayer, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.QueryApi = QueryApi;
/**
 * SqlApi - axios parameter creator
 * @export
 */
const SqlApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Run a sql query
         * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
         * @param {SQLParameters} sql sql being submitted
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runSQL: (namespace, sql, acceptEncoding, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('runSQL', 'namespace', namespace);
            // verify required parameter 'sql' is not null or undefined
            common_1.assertParamExists('runSQL', 'sql', sql);
            const localVarPath = `/sql/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(sql, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.SqlApiAxiosParamCreator = SqlApiAxiosParamCreator;
/**
 * SqlApi - functional programming interface
 * @export
 */
const SqlApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.SqlApiAxiosParamCreator(configuration);
    return {
        /**
         * Run a sql query
         * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
         * @param {SQLParameters} sql sql being submitted
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runSQL(namespace, sql, acceptEncoding, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.runSQL(namespace, sql, acceptEncoding, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.SqlApiFp = SqlApiFp;
/**
 * SqlApi - factory interface
 * @export
 */
const SqlApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.SqlApiFp(configuration);
    return {
        /**
         * Run a sql query
         * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
         * @param {SQLParameters} sql sql being submitted
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runSQL(namespace, sql, acceptEncoding, options) {
            return localVarFp.runSQL(namespace, sql, acceptEncoding, options).then((request) => request(axios, basePath));
        },
    };
};
exports.SqlApiFactory = SqlApiFactory;
/**
 * SqlApi - object-oriented interface
 * @export
 * @class SqlApi
 * @extends {BaseAPI}
 */
class SqlApi extends base_1.BaseAPI {
    /**
     * Run a sql query
     * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
     * @param {SQLParameters} sql sql being submitted
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SqlApi
     */
    runSQL(namespace, sql, acceptEncoding, options) {
        return exports.SqlApiFp(this.configuration).runSQL(namespace, sql, acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.SqlApi = SqlApi;
/**
 * StatsApi - axios parameter creator
 * @export
 */
const StatsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Fetch libtiledb stat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTiledbStats: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/.stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.StatsApiAxiosParamCreator = StatsApiAxiosParamCreator;
/**
 * StatsApi - functional programming interface
 * @export
 */
const StatsApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.StatsApiAxiosParamCreator(configuration);
    return {
        /**
         * Fetch libtiledb stat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTiledbStats(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getTiledbStats(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.StatsApiFp = StatsApiFp;
/**
 * StatsApi - factory interface
 * @export
 */
const StatsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.StatsApiFp(configuration);
    return {
        /**
         * Fetch libtiledb stat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTiledbStats(options) {
            return localVarFp.getTiledbStats(options).then((request) => request(axios, basePath));
        },
    };
};
exports.StatsApiFactory = StatsApiFactory;
/**
 * StatsApi - object-oriented interface
 * @export
 * @class StatsApi
 * @extends {BaseAPI}
 */
class StatsApi extends base_1.BaseAPI {
    /**
     * Fetch libtiledb stat
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    getTiledbStats(options) {
        return exports.StatsApiFp(this.configuration).getTiledbStats(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.StatsApi = StatsApi;
/**
 * TasksApi - axios parameter creator
 * @export
 */
const TasksApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Run a sql query
         * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
         * @param {SQLParameters} sql sql being submitted
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runSQL: (namespace, sql, acceptEncoding, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('runSQL', 'namespace', namespace);
            // verify required parameter 'sql' is not null or undefined
            common_1.assertParamExists('runSQL', 'sql', sql);
            const localVarPath = `/sql/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(sql, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch an array task
         * @param {string} id task id to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskIdGet: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('taskIdGet', 'id', id);
            const localVarPath = `/task/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve results of an array task
         * @param {string} id task id to retrieve stored results
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskIdResultGet: (id, acceptEncoding, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            common_1.assertParamExists('taskIdResultGet', 'id', id);
            const localVarPath = `/task/{id}/result`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch a list of all array tasks a user has access to
         * @param {string} [namespace] namespace to filter
         * @param {string} [createdBy] username to filter
         * @param {string} [array] name/uri of array that is url-encoded to filter
         * @param {number} [start] start time for tasks to filter by
         * @param {number} [end] end time for tasks to filter by
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [type] task type, \&quot;QUERY\&quot;, \&quot;SQL\&quot;, \&quot;UDF\&quot;, \&quot;GENERIC_UDF\&quot;
         * @param {Array<string>} [excludeType] task_type to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] match file_type of task array, more than one can be included
         * @param {Array<string>} [excludeFileType] exclude file_type of task arrays, more than one can be included
         * @param {string} [status] Filter to only return these statuses
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [orderby] sort by which field valid values include start_time, name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksGet: (namespace, createdBy, array, start, end, page, perPage, type, excludeType, fileType, excludeFileType, status, search, orderby, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }
            if (createdBy !== undefined) {
                localVarQueryParameter['created_by'] = createdBy;
            }
            if (array !== undefined) {
                localVarQueryParameter['array'] = array;
            }
            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (excludeType) {
                localVarQueryParameter['exclude_type'] = excludeType.join(base_1.COLLECTION_FORMATS.csv);
            }
            if (fileType) {
                localVarQueryParameter['file_type'] = fileType;
            }
            if (excludeFileType) {
                localVarQueryParameter['exclude_file_type'] = excludeFileType;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (orderby !== undefined) {
                localVarQueryParameter['orderby'] = orderby;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.TasksApiAxiosParamCreator = TasksApiAxiosParamCreator;
/**
 * TasksApi - functional programming interface
 * @export
 */
const TasksApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.TasksApiAxiosParamCreator(configuration);
    return {
        /**
         * Run a sql query
         * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
         * @param {SQLParameters} sql sql being submitted
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runSQL(namespace, sql, acceptEncoding, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.runSQL(namespace, sql, acceptEncoding, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch an array task
         * @param {string} id task id to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskIdGet(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.taskIdGet(id, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Retrieve results of an array task
         * @param {string} id task id to retrieve stored results
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskIdResultGet(id, acceptEncoding, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.taskIdResultGet(id, acceptEncoding, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch a list of all array tasks a user has access to
         * @param {string} [namespace] namespace to filter
         * @param {string} [createdBy] username to filter
         * @param {string} [array] name/uri of array that is url-encoded to filter
         * @param {number} [start] start time for tasks to filter by
         * @param {number} [end] end time for tasks to filter by
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [type] task type, \&quot;QUERY\&quot;, \&quot;SQL\&quot;, \&quot;UDF\&quot;, \&quot;GENERIC_UDF\&quot;
         * @param {Array<string>} [excludeType] task_type to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] match file_type of task array, more than one can be included
         * @param {Array<string>} [excludeFileType] exclude file_type of task arrays, more than one can be included
         * @param {string} [status] Filter to only return these statuses
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [orderby] sort by which field valid values include start_time, name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksGet(namespace, createdBy, array, start, end, page, perPage, type, excludeType, fileType, excludeFileType, status, search, orderby, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.tasksGet(namespace, createdBy, array, start, end, page, perPage, type, excludeType, fileType, excludeFileType, status, search, orderby, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.TasksApiFp = TasksApiFp;
/**
 * TasksApi - factory interface
 * @export
 */
const TasksApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.TasksApiFp(configuration);
    return {
        /**
         * Run a sql query
         * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
         * @param {SQLParameters} sql sql being submitted
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runSQL(namespace, sql, acceptEncoding, options) {
            return localVarFp.runSQL(namespace, sql, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch an array task
         * @param {string} id task id to fetch
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskIdGet(id, options) {
            return localVarFp.taskIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve results of an array task
         * @param {string} id task id to retrieve stored results
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        taskIdResultGet(id, acceptEncoding, options) {
            return localVarFp.taskIdResultGet(id, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of all array tasks a user has access to
         * @param {string} [namespace] namespace to filter
         * @param {string} [createdBy] username to filter
         * @param {string} [array] name/uri of array that is url-encoded to filter
         * @param {number} [start] start time for tasks to filter by
         * @param {number} [end] end time for tasks to filter by
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {string} [type] task type, \&quot;QUERY\&quot;, \&quot;SQL\&quot;, \&quot;UDF\&quot;, \&quot;GENERIC_UDF\&quot;
         * @param {Array<string>} [excludeType] task_type to exclude matching array in results, more than one can be included
         * @param {Array<string>} [fileType] match file_type of task array, more than one can be included
         * @param {Array<string>} [excludeFileType] exclude file_type of task arrays, more than one can be included
         * @param {string} [status] Filter to only return these statuses
         * @param {string} [search] search string that will look at name, namespace or description fields
         * @param {string} [orderby] sort by which field valid values include start_time, name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksGet(namespace, createdBy, array, start, end, page, perPage, type, excludeType, fileType, excludeFileType, status, search, orderby, options) {
            return localVarFp.tasksGet(namespace, createdBy, array, start, end, page, perPage, type, excludeType, fileType, excludeFileType, status, search, orderby, options).then((request) => request(axios, basePath));
        },
    };
};
exports.TasksApiFactory = TasksApiFactory;
/**
 * TasksApi - object-oriented interface
 * @export
 * @class TasksApi
 * @extends {BaseAPI}
 */
class TasksApi extends base_1.BaseAPI {
    /**
     * Run a sql query
     * @param {string} namespace namespace to run task under is in (an organization name or user\&#39;s username)
     * @param {SQLParameters} sql sql being submitted
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    runSQL(namespace, sql, acceptEncoding, options) {
        return exports.TasksApiFp(this.configuration).runSQL(namespace, sql, acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch an array task
     * @param {string} id task id to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    taskIdGet(id, options) {
        return exports.TasksApiFp(this.configuration).taskIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve results of an array task
     * @param {string} id task id to retrieve stored results
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    taskIdResultGet(id, acceptEncoding, options) {
        return exports.TasksApiFp(this.configuration).taskIdResultGet(id, acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a list of all array tasks a user has access to
     * @param {string} [namespace] namespace to filter
     * @param {string} [createdBy] username to filter
     * @param {string} [array] name/uri of array that is url-encoded to filter
     * @param {number} [start] start time for tasks to filter by
     * @param {number} [end] end time for tasks to filter by
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {string} [type] task type, \&quot;QUERY\&quot;, \&quot;SQL\&quot;, \&quot;UDF\&quot;, \&quot;GENERIC_UDF\&quot;
     * @param {Array<string>} [excludeType] task_type to exclude matching array in results, more than one can be included
     * @param {Array<string>} [fileType] match file_type of task array, more than one can be included
     * @param {Array<string>} [excludeFileType] exclude file_type of task arrays, more than one can be included
     * @param {string} [status] Filter to only return these statuses
     * @param {string} [search] search string that will look at name, namespace or description fields
     * @param {string} [orderby] sort by which field valid values include start_time, name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    tasksGet(namespace, createdBy, array, start, end, page, perPage, type, excludeType, fileType, excludeFileType, status, search, orderby, options) {
        return exports.TasksApiFp(this.configuration).tasksGet(namespace, createdBy, array, start, end, page, perPage, type, excludeType, fileType, excludeFileType, status, search, orderby, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TasksApi = TasksApi;
/**
 * UdfApi - axios parameter creator
 * @export
 */
const UdfApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * delete a registerd UDF, this will remove all sharing and can not be undone
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register udf under
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUDFInfo: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('deleteUDFInfo', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('deleteUDFInfo', 'name', name);
            const localVarPath = `/udf/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get a specific UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register udf under
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUDFInfo: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getUDFInfo', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('getUDFInfo', 'name', name);
            const localVarPath = `/udf/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all sharing details of the udf
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name of UDFInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUDFInfoSharingPolicies: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getUDFInfoSharingPolicies', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('getUDFInfoSharingPolicies', 'name', name);
            const localVarPath = `/udf/{namespace}/{name}/share`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * register a UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register udf under
         * @param {UDFInfoUpdate} udf udf to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUDFInfo: (namespace, name, udf, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('registerUDFInfo', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('registerUDFInfo', 'name', name);
            // verify required parameter 'udf' is not null or undefined
            common_1.assertParamExists('registerUDFInfo', 'udf', udf);
            const localVarPath = `/udf/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(udf, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Share a UDF with a user
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name of UDFInfo
         * @param {UDFSharing} udfSharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace, if permissions already exist they will be deleted then new ones added. In the event of a failure, the new polcies will be rolled back to prevent partial policies, and its likely the udf will not be shared with the namespace at all
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareUDFInfo: (namespace, name, udfSharing, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('shareUDFInfo', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('shareUDFInfo', 'name', name);
            // verify required parameter 'udfSharing' is not null or undefined
            common_1.assertParamExists('shareUDFInfo', 'udfSharing', udfSharing);
            const localVarPath = `/udf/{namespace}/{name}/share`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(udfSharing, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * submit a generic UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {GenericUDF} udf udf to run
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitGenericUDF: (namespace, udf, acceptEncoding, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('submitGenericUDF', 'namespace', namespace);
            // verify required parameter 'udf' is not null or undefined
            common_1.assertParamExists('submitGenericUDF', 'udf', udf);
            const localVarPath = `/udfs/generic/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(udf, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * submit a multi-array UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {MultiArrayUDF} udf udf to run
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitMultiArrayUDF: (namespace, udf, acceptEncoding, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('submitMultiArrayUDF', 'namespace', namespace);
            // verify required parameter 'udf' is not null or undefined
            common_1.assertParamExists('submitMultiArrayUDF', 'udf', udf);
            const localVarPath = `/udfs/arrays/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(udf, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * send a UDF to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {MultiArrayUDF} udf udf to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {string} [acceptEncoding] Encoding to use
         * @param {string} [v2] flag to indicate if v2 array udfs should be used, currently in beta testing. Setting any value will enable v2 array udfs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitUDF: (namespace, array, udf, xPayer, acceptEncoding, v2, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('submitUDF', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('submitUDF', 'array', array);
            // verify required parameter 'udf' is not null or undefined
            common_1.assertParamExists('submitUDF', 'udf', udf);
            const localVarPath = `/arrays/{namespace}/{array}/udf/submit`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (v2 !== undefined) {
                localVarQueryParameter['v2'] = v2;
            }
            if (xPayer !== undefined && xPayer !== null) {
                localVarHeaderParameter['X-Payer'] = String(xPayer);
            }
            if (acceptEncoding !== undefined && acceptEncoding !== null) {
                localVarHeaderParameter['Accept-Encoding'] = String(acceptEncoding);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(udf, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * retrieve a list of timestamps from the array fragment info listing in milliseconds
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        udfNamespaceArrayVersionsGet: (namespace, array, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('udfNamespaceArrayVersionsGet', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('udfNamespaceArrayVersionsGet', 'array', array);
            const localVarPath = `/udf/{namespace}/{array}/versions`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * updated an existing registerd UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register udf under
         * @param {UDFInfoUpdate} udf udf to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUDFInfo: (namespace, name, udf, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('updateUDFInfo', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('updateUDFInfo', 'name', name);
            // verify required parameter 'udf' is not null or undefined
            common_1.assertParamExists('updateUDFInfo', 'udf', udf);
            const localVarPath = `/udf/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(udf, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.UdfApiAxiosParamCreator = UdfApiAxiosParamCreator;
/**
 * UdfApi - functional programming interface
 * @export
 */
const UdfApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.UdfApiAxiosParamCreator(configuration);
    return {
        /**
         * delete a registerd UDF, this will remove all sharing and can not be undone
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register udf under
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUDFInfo(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteUDFInfo(namespace, name, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * get a specific UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register udf under
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUDFInfo(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUDFInfo(namespace, name, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get all sharing details of the udf
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name of UDFInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUDFInfoSharingPolicies(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUDFInfoSharingPolicies(namespace, name, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * register a UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register udf under
         * @param {UDFInfoUpdate} udf udf to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUDFInfo(namespace, name, udf, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.registerUDFInfo(namespace, name, udf, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Share a UDF with a user
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name of UDFInfo
         * @param {UDFSharing} udfSharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace, if permissions already exist they will be deleted then new ones added. In the event of a failure, the new polcies will be rolled back to prevent partial policies, and its likely the udf will not be shared with the namespace at all
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareUDFInfo(namespace, name, udfSharing, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.shareUDFInfo(namespace, name, udfSharing, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * submit a generic UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {GenericUDF} udf udf to run
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitGenericUDF(namespace, udf, acceptEncoding, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.submitGenericUDF(namespace, udf, acceptEncoding, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * submit a multi-array UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {MultiArrayUDF} udf udf to run
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitMultiArrayUDF(namespace, udf, acceptEncoding, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.submitMultiArrayUDF(namespace, udf, acceptEncoding, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * send a UDF to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {MultiArrayUDF} udf udf to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {string} [acceptEncoding] Encoding to use
         * @param {string} [v2] flag to indicate if v2 array udfs should be used, currently in beta testing. Setting any value will enable v2 array udfs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitUDF(namespace, array, udf, xPayer, acceptEncoding, v2, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.submitUDF(namespace, array, udf, xPayer, acceptEncoding, v2, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * retrieve a list of timestamps from the array fragment info listing in milliseconds
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        udfNamespaceArrayVersionsGet(namespace, array, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.udfNamespaceArrayVersionsGet(namespace, array, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * updated an existing registerd UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register udf under
         * @param {UDFInfoUpdate} udf udf to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUDFInfo(namespace, name, udf, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateUDFInfo(namespace, name, udf, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.UdfApiFp = UdfApiFp;
/**
 * UdfApi - factory interface
 * @export
 */
const UdfApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.UdfApiFp(configuration);
    return {
        /**
         * delete a registerd UDF, this will remove all sharing and can not be undone
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register udf under
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUDFInfo(namespace, name, options) {
            return localVarFp.deleteUDFInfo(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * get a specific UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register udf under
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUDFInfo(namespace, name, options) {
            return localVarFp.getUDFInfo(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all sharing details of the udf
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name of UDFInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUDFInfoSharingPolicies(namespace, name, options) {
            return localVarFp.getUDFInfoSharingPolicies(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * register a UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register udf under
         * @param {UDFInfoUpdate} udf udf to register
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUDFInfo(namespace, name, udf, options) {
            return localVarFp.registerUDFInfo(namespace, name, udf, options).then((request) => request(axios, basePath));
        },
        /**
         * Share a UDF with a user
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name of UDFInfo
         * @param {UDFSharing} udfSharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace, if permissions already exist they will be deleted then new ones added. In the event of a failure, the new polcies will be rolled back to prevent partial policies, and its likely the udf will not be shared with the namespace at all
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shareUDFInfo(namespace, name, udfSharing, options) {
            return localVarFp.shareUDFInfo(namespace, name, udfSharing, options).then((request) => request(axios, basePath));
        },
        /**
         * submit a generic UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {GenericUDF} udf udf to run
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitGenericUDF(namespace, udf, acceptEncoding, options) {
            return localVarFp.submitGenericUDF(namespace, udf, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * submit a multi-array UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {MultiArrayUDF} udf udf to run
         * @param {string} [acceptEncoding] Encoding to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitMultiArrayUDF(namespace, udf, acceptEncoding, options) {
            return localVarFp.submitMultiArrayUDF(namespace, udf, acceptEncoding, options).then((request) => request(axios, basePath));
        },
        /**
         * send a UDF to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {MultiArrayUDF} udf udf to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {string} [acceptEncoding] Encoding to use
         * @param {string} [v2] flag to indicate if v2 array udfs should be used, currently in beta testing. Setting any value will enable v2 array udfs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitUDF(namespace, array, udf, xPayer, acceptEncoding, v2, options) {
            return localVarFp.submitUDF(namespace, array, udf, xPayer, acceptEncoding, v2, options).then((request) => request(axios, basePath));
        },
        /**
         * retrieve a list of timestamps from the array fragment info listing in milliseconds
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        udfNamespaceArrayVersionsGet(namespace, array, options) {
            return localVarFp.udfNamespaceArrayVersionsGet(namespace, array, options).then((request) => request(axios, basePath));
        },
        /**
         * updated an existing registerd UDF in the given namespace
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} name name to register udf under
         * @param {UDFInfoUpdate} udf udf to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUDFInfo(namespace, name, udf, options) {
            return localVarFp.updateUDFInfo(namespace, name, udf, options).then((request) => request(axios, basePath));
        },
    };
};
exports.UdfApiFactory = UdfApiFactory;
/**
 * UdfApi - object-oriented interface
 * @export
 * @class UdfApi
 * @extends {BaseAPI}
 */
class UdfApi extends base_1.BaseAPI {
    /**
     * delete a registerd UDF, this will remove all sharing and can not be undone
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name to register udf under
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    deleteUDFInfo(namespace, name, options) {
        return exports.UdfApiFp(this.configuration).deleteUDFInfo(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get a specific UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name to register udf under
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    getUDFInfo(namespace, name, options) {
        return exports.UdfApiFp(this.configuration).getUDFInfo(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all sharing details of the udf
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name of UDFInfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    getUDFInfoSharingPolicies(namespace, name, options) {
        return exports.UdfApiFp(this.configuration).getUDFInfoSharingPolicies(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * register a UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name to register udf under
     * @param {UDFInfoUpdate} udf udf to register
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    registerUDFInfo(namespace, name, udf, options) {
        return exports.UdfApiFp(this.configuration).registerUDFInfo(namespace, name, udf, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Share a UDF with a user
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name of UDFInfo
     * @param {UDFSharing} udfSharing Namespace and list of permissions to share with. An empty list of permissions will remove the namespace, if permissions already exist they will be deleted then new ones added. In the event of a failure, the new polcies will be rolled back to prevent partial policies, and its likely the udf will not be shared with the namespace at all
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    shareUDFInfo(namespace, name, udfSharing, options) {
        return exports.UdfApiFp(this.configuration).shareUDFInfo(namespace, name, udfSharing, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * submit a generic UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {GenericUDF} udf udf to run
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    submitGenericUDF(namespace, udf, acceptEncoding, options) {
        return exports.UdfApiFp(this.configuration).submitGenericUDF(namespace, udf, acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * submit a multi-array UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {MultiArrayUDF} udf udf to run
     * @param {string} [acceptEncoding] Encoding to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    submitMultiArrayUDF(namespace, udf, acceptEncoding, options) {
        return exports.UdfApiFp(this.configuration).submitMultiArrayUDF(namespace, udf, acceptEncoding, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * send a UDF to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {MultiArrayUDF} udf udf to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {string} [acceptEncoding] Encoding to use
     * @param {string} [v2] flag to indicate if v2 array udfs should be used, currently in beta testing. Setting any value will enable v2 array udfs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    submitUDF(namespace, array, udf, xPayer, acceptEncoding, v2, options) {
        return exports.UdfApiFp(this.configuration).submitUDF(namespace, array, udf, xPayer, acceptEncoding, v2, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * retrieve a list of timestamps from the array fragment info listing in milliseconds
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    udfNamespaceArrayVersionsGet(namespace, array, options) {
        return exports.UdfApiFp(this.configuration).udfNamespaceArrayVersionsGet(namespace, array, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * updated an existing registerd UDF in the given namespace
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} name name to register udf under
     * @param {UDFInfoUpdate} udf udf to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UdfApi
     */
    updateUDFInfo(namespace, name, udf, options) {
        return exports.UdfApiFp(this.configuration).updateUDFInfo(namespace, name, udf, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.UdfApi = UdfApi;
/**
 * UserApi - axios parameter creator
 * @export
 */
const UserApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Add aws keys
         * @param {string} namespace namespace
         * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAWSAccessCredentials: (namespace, awsAccessCredentials, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('addAWSAccessCredentials', 'namespace', namespace);
            // verify required parameter 'awsAccessCredentials' is not null or undefined
            common_1.assertParamExists('addAWSAccessCredentials', 'awsAccessCredentials', awsAccessCredentials);
            const localVarPath = `/credentials/{namespace}/aws`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(awsAccessCredentials, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * add a user to an organization
         * @param {string} organization organization name
         * @param {OrganizationUser} user user to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToOrganization: (organization, user, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organization' is not null or undefined
            common_1.assertParamExists('addUserToOrganization', 'organization', organization);
            // verify required parameter 'user' is not null or undefined
            common_1.assertParamExists('addUserToOrganization', 'user', user);
            const localVarPath = `/organizations/{organization}/user`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(user, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Check if aws keys are set
         * @param {string} namespace namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentials: (namespace, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('checkAWSAccessCredentials', 'namespace', namespace);
            const localVarPath = `/credentials/{namespace}/aws`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Check if aws keys are set by name
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentialsByName: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('checkAWSAccessCredentialsByName', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('checkAWSAccessCredentialsByName', 'name', name);
            const localVarPath = `/credentials/{namespace}/aws/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * confirm user email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmEmail: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/user/confirm_email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * create a user
         * @param {User} user user to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: (user, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'user' is not null or undefined
            common_1.assertParamExists('createUser', 'user', user);
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(user, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAWSAccessCredentials: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('deleteAWSAccessCredentials', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('deleteAWSAccessCredentials', 'name', name);
            const localVarPath = `/credentials/{namespace}/aws/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * delete a user
         * @param {string} username username or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: (username, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'username' is not null or undefined
            common_1.assertParamExists('deleteUser', 'username', username);
            const localVarPath = `/users/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * delete a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFromOrganization: (organization, username, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organization' is not null or undefined
            common_1.assertParamExists('deleteUserFromOrganization', 'organization', organization);
            // verify required parameter 'username' is not null or undefined
            common_1.assertParamExists('deleteUserFromOrganization', 'username', username);
            const localVarPath = `/organizations/{organization}/{username}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUser: (organization, username, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organization' is not null or undefined
            common_1.assertParamExists('getOrganizationUser', 'organization', organization);
            // verify required parameter 'username' is not null or undefined
            common_1.assertParamExists('getOrganizationUser', 'username', username);
            const localVarPath = `/organizations/{organization}/{username}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get session token for user
         * @param {string} [rememberMe] flag to create a token with expiration of 30 days, default is false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSession: (rememberMe, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (rememberMe !== undefined) {
                localVarQueryParameter['remember_me'] = rememberMe;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * retrieves available token scopes for a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenScopes: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/tokens/scopes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * get a user
         * @param {string} username username or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWithUsername: (username, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'username' is not null or undefined
            common_1.assertParamExists('getUserWithUsername', 'username', username);
            const localVarPath = `/users/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Request an authorization token, optionally taken a TokenRequest object to set parameters on the token
         * @param {TokenRequest} [tokenRequest] token request object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestToken: (tokenRequest, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(tokenRequest, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * reset user password
         * @param {InlineObject} user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetUserPassword: (user, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'user' is not null or undefined
            common_1.assertParamExists('resetUserPassword', 'user', user);
            const localVarPath = `/user/password_reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(user, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * revoke an authorization token
         * @param {string} token token name or token itself
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeToken: (token, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'token' is not null or undefined
            common_1.assertParamExists('revokeToken', 'token', token);
            const localVarPath = `/tokens/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch a list of user tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Fetch a list of user session tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensSessionGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/tokens/session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAWSAccessCredentials: (namespace, name, awsAccessCredentials, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('updateAWSAccessCredentials', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('updateAWSAccessCredentials', 'name', name);
            // verify required parameter 'awsAccessCredentials' is not null or undefined
            common_1.assertParamExists('updateAWSAccessCredentials', 'awsAccessCredentials', awsAccessCredentials);
            const localVarPath = `/credentials/{namespace}/aws/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(awsAccessCredentials, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * update a user
         * @param {string} username username or id
         * @param {User} user user details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: (username, user, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'username' is not null or undefined
            common_1.assertParamExists('updateUser', 'username', username);
            // verify required parameter 'user' is not null or undefined
            common_1.assertParamExists('updateUser', 'user', user);
            const localVarPath = `/users/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(user, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * update a user in an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {OrganizationUser} user user details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserInOrganization: (organization, username, user, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'organization' is not null or undefined
            common_1.assertParamExists('updateUserInOrganization', 'organization', organization);
            // verify required parameter 'username' is not null or undefined
            common_1.assertParamExists('updateUserInOrganization', 'username', username);
            // verify required parameter 'user' is not null or undefined
            common_1.assertParamExists('updateUserInOrganization', 'user', user);
            const localVarPath = `/organizations/{organization}/{username}`
                .replace(`{${"organization"}}`, encodeURIComponent(String(organization)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(user, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.UserApiAxiosParamCreator = UserApiAxiosParamCreator;
/**
 * UserApi - functional programming interface
 * @export
 */
const UserApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.UserApiAxiosParamCreator(configuration);
    return {
        /**
         * Add aws keys
         * @param {string} namespace namespace
         * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAWSAccessCredentials(namespace, awsAccessCredentials, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.addAWSAccessCredentials(namespace, awsAccessCredentials, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * add a user to an organization
         * @param {string} organization organization name
         * @param {OrganizationUser} user user to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToOrganization(organization, user, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.addUserToOrganization(organization, user, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Check if aws keys are set
         * @param {string} namespace namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentials(namespace, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.checkAWSAccessCredentials(namespace, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Check if aws keys are set by name
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentialsByName(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.checkAWSAccessCredentialsByName(namespace, name, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * confirm user email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmEmail(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.confirmEmail(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * create a user
         * @param {User} user user to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(user, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createUser(user, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAWSAccessCredentials(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteAWSAccessCredentials(namespace, name, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * delete a user
         * @param {string} username username or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(username, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteUser(username, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * delete a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFromOrganization(organization, username, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteUserFromOrganization(organization, username, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * get a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUser(organization, username, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getOrganizationUser(organization, username, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get session token for user
         * @param {string} [rememberMe] flag to create a token with expiration of 30 days, default is false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSession(rememberMe, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSession(rememberMe, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * retrieves available token scopes for a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenScopes(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getTokenScopes(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * get a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUser(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * get a user
         * @param {string} username username or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWithUsername(username, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserWithUsername(username, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Request an authorization token, optionally taken a TokenRequest object to set parameters on the token
         * @param {TokenRequest} [tokenRequest] token request object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestToken(tokenRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.requestToken(tokenRequest, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * reset user password
         * @param {InlineObject} user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetUserPassword(user, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.resetUserPassword(user, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * revoke an authorization token
         * @param {string} token token name or token itself
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeToken(token, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.revokeToken(token, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch a list of user tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.tokensGet(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Fetch a list of user session tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensSessionGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.tokensSessionGet(options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * update a user
         * @param {string} username username or id
         * @param {User} user user details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(username, user, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateUser(username, user, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * update a user in an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {OrganizationUser} user user details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserInOrganization(organization, username, user, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateUserInOrganization(organization, username, user, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.UserApiFp = UserApiFp;
/**
 * UserApi - factory interface
 * @export
 */
const UserApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.UserApiFp(configuration);
    return {
        /**
         * Add aws keys
         * @param {string} namespace namespace
         * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAWSAccessCredentials(namespace, awsAccessCredentials, options) {
            return localVarFp.addAWSAccessCredentials(namespace, awsAccessCredentials, options).then((request) => request(axios, basePath));
        },
        /**
         * add a user to an organization
         * @param {string} organization organization name
         * @param {OrganizationUser} user user to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToOrganization(organization, user, options) {
            return localVarFp.addUserToOrganization(organization, user, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if aws keys are set
         * @param {string} namespace namespace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentials(namespace, options) {
            return localVarFp.checkAWSAccessCredentials(namespace, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if aws keys are set by name
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAWSAccessCredentialsByName(namespace, name, options) {
            return localVarFp.checkAWSAccessCredentialsByName(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * confirm user email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmEmail(options) {
            return localVarFp.confirmEmail(options).then((request) => request(axios, basePath));
        },
        /**
         * create a user
         * @param {User} user user to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(user, options) {
            return localVarFp.createUser(user, options).then((request) => request(axios, basePath));
        },
        /**
         * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAWSAccessCredentials(namespace, name, options) {
            return localVarFp.deleteAWSAccessCredentials(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * delete a user
         * @param {string} username username or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(username, options) {
            return localVarFp.deleteUser(username, options).then((request) => request(axios, basePath));
        },
        /**
         * delete a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserFromOrganization(organization, username, options) {
            return localVarFp.deleteUserFromOrganization(organization, username, options).then((request) => request(axios, basePath));
        },
        /**
         * get a user from an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUser(organization, username, options) {
            return localVarFp.getOrganizationUser(organization, username, options).then((request) => request(axios, basePath));
        },
        /**
         * Get session token for user
         * @param {string} [rememberMe] flag to create a token with expiration of 30 days, default is false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSession(rememberMe, options) {
            return localVarFp.getSession(rememberMe, options).then((request) => request(axios, basePath));
        },
        /**
         * retrieves available token scopes for a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenScopes(options) {
            return localVarFp.getTokenScopes(options).then((request) => request(axios, basePath));
        },
        /**
         * get a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options) {
            return localVarFp.getUser(options).then((request) => request(axios, basePath));
        },
        /**
         * get a user
         * @param {string} username username or id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWithUsername(username, options) {
            return localVarFp.getUserWithUsername(username, options).then((request) => request(axios, basePath));
        },
        /**
         * Request an authorization token, optionally taken a TokenRequest object to set parameters on the token
         * @param {TokenRequest} [tokenRequest] token request object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestToken(tokenRequest, options) {
            return localVarFp.requestToken(tokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * reset user password
         * @param {InlineObject} user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetUserPassword(user, options) {
            return localVarFp.resetUserPassword(user, options).then((request) => request(axios, basePath));
        },
        /**
         * revoke an authorization token
         * @param {string} token token name or token itself
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeToken(token, options) {
            return localVarFp.revokeToken(token, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of user tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensGet(options) {
            return localVarFp.tokensGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of user session tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokensSessionGet(options) {
            return localVarFp.tokensSessionGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
         * @param {string} namespace namespace
         * @param {string} name name
         * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options) {
            return localVarFp.updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options).then((request) => request(axios, basePath));
        },
        /**
         * update a user
         * @param {string} username username or id
         * @param {User} user user details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(username, user, options) {
            return localVarFp.updateUser(username, user, options).then((request) => request(axios, basePath));
        },
        /**
         * update a user in an organization
         * @param {string} organization organization name
         * @param {string} username username to manipulate
         * @param {OrganizationUser} user user details to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserInOrganization(organization, username, user, options) {
            return localVarFp.updateUserInOrganization(organization, username, user, options).then((request) => request(axios, basePath));
        },
    };
};
exports.UserApiFactory = UserApiFactory;
/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
class UserApi extends base_1.BaseAPI {
    /**
     * Add aws keys
     * @param {string} namespace namespace
     * @param {AWSAccessCredentials} awsAccessCredentials aws access credentials to store for a namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    addAWSAccessCredentials(namespace, awsAccessCredentials, options) {
        return exports.UserApiFp(this.configuration).addAWSAccessCredentials(namespace, awsAccessCredentials, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * add a user to an organization
     * @param {string} organization organization name
     * @param {OrganizationUser} user user to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    addUserToOrganization(organization, user, options) {
        return exports.UserApiFp(this.configuration).addUserToOrganization(organization, user, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Check if aws keys are set
     * @param {string} namespace namespace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    checkAWSAccessCredentials(namespace, options) {
        return exports.UserApiFp(this.configuration).checkAWSAccessCredentials(namespace, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Check if aws keys are set by name
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    checkAWSAccessCredentialsByName(namespace, name, options) {
        return exports.UserApiFp(this.configuration).checkAWSAccessCredentialsByName(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * confirm user email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    confirmEmail(options) {
        return exports.UserApiFp(this.configuration).confirmEmail(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * create a user
     * @param {User} user user to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    createUser(user, options) {
        return exports.UserApiFp(this.configuration).createUser(user, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * delete a AWS Access credentials in a namespace. This will likely cause arrays to become unreachable
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    deleteAWSAccessCredentials(namespace, name, options) {
        return exports.UserApiFp(this.configuration).deleteAWSAccessCredentials(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * delete a user
     * @param {string} username username or id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    deleteUser(username, options) {
        return exports.UserApiFp(this.configuration).deleteUser(username, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * delete a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    deleteUserFromOrganization(organization, username, options) {
        return exports.UserApiFp(this.configuration).deleteUserFromOrganization(organization, username, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get a user from an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getOrganizationUser(organization, username, options) {
        return exports.UserApiFp(this.configuration).getOrganizationUser(organization, username, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get session token for user
     * @param {string} [rememberMe] flag to create a token with expiration of 30 days, default is false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getSession(rememberMe, options) {
        return exports.UserApiFp(this.configuration).getSession(rememberMe, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * retrieves available token scopes for a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getTokenScopes(options) {
        return exports.UserApiFp(this.configuration).getTokenScopes(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUser(options) {
        return exports.UserApiFp(this.configuration).getUser(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * get a user
     * @param {string} username username or id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUserWithUsername(username, options) {
        return exports.UserApiFp(this.configuration).getUserWithUsername(username, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Request an authorization token, optionally taken a TokenRequest object to set parameters on the token
     * @param {TokenRequest} [tokenRequest] token request object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    requestToken(tokenRequest, options) {
        return exports.UserApiFp(this.configuration).requestToken(tokenRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * reset user password
     * @param {InlineObject} user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    resetUserPassword(user, options) {
        return exports.UserApiFp(this.configuration).resetUserPassword(user, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * revoke an authorization token
     * @param {string} token token name or token itself
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    revokeToken(token, options) {
        return exports.UserApiFp(this.configuration).revokeToken(token, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a list of user tokens
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    tokensGet(options) {
        return exports.UserApiFp(this.configuration).tokensGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch a list of user session tokens
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    tokensSessionGet(options) {
        return exports.UserApiFp(this.configuration).tokensSessionGet(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update aws keys or associated buckets. This will update the key associations for each array in the namespace
     * @param {string} namespace namespace
     * @param {string} name name
     * @param {AWSAccessCredentials} awsAccessCredentials aws credentials to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options) {
        return exports.UserApiFp(this.configuration).updateAWSAccessCredentials(namespace, name, awsAccessCredentials, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * update a user
     * @param {string} username username or id
     * @param {User} user user details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    updateUser(username, user, options) {
        return exports.UserApiFp(this.configuration).updateUser(username, user, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * update a user in an organization
     * @param {string} organization organization name
     * @param {string} username username to manipulate
     * @param {OrganizationUser} user user details to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    updateUserInOrganization(organization, username, user, options) {
        return exports.UserApiFp(this.configuration).updateUserInOrganization(organization, username, user, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.UserApi = UserApi;
//# sourceMappingURL=api.js.map

/***/ }),

/***/ "./node_modules/@tiledb-inc/tiledb-cloud/lib/v1/base.js":
/*!**************************************************************!*\
  !*** ./node_modules/@tiledb-inc/tiledb-cloud/lib/v1/base.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* tslint:disable */
/* eslint-disable */
/**
 * TileDB Storage Platform API
 * TileDB Storage Platform REST API
 *
 * The version of the OpenAPI document: 2.2.19
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RequiredError = exports.BaseAPI = exports.COLLECTION_FORMATS = exports.BASE_PATH = void 0;
// Some imports not used depending on template conditions
// @ts-ignore
const axios_1 = __importDefault(__webpack_require__(/*! axios */ "./node_modules/axios/index.js"));
exports.BASE_PATH = "https://api.tiledb.com/v1".replace(/\/+$/, "");
/**
 *
 * @export
 */
exports.COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};
/**
 *
 * @export
 * @class BaseAPI
 */
class BaseAPI {
    constructor(configuration, basePath = exports.BASE_PATH, axios = axios_1.default) {
        this.basePath = basePath;
        this.axios = axios;
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
}
exports.BaseAPI = BaseAPI;
;
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
class RequiredError extends Error {
    constructor(field, msg) {
        super(msg);
        this.field = field;
        this.name = "RequiredError";
    }
}
exports.RequiredError = RequiredError;
//# sourceMappingURL=base.js.map

/***/ }),

/***/ "./node_modules/@tiledb-inc/tiledb-cloud/lib/v1/common.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tiledb-inc/tiledb-cloud/lib/v1/common.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* tslint:disable */
/* eslint-disable */
/**
 * TileDB Storage Platform API
 * TileDB Storage Platform REST API
 *
 * The version of the OpenAPI document: 2.2.19
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createRequestFunction = exports.toPathString = exports.serializeDataIfNeeded = exports.setSearchParams = exports.setOAuthToObject = exports.setBearerAuthToObject = exports.setBasicAuthToObject = exports.setApiKeyToObject = exports.assertParamExists = exports.DUMMY_BASE_URL = void 0;
const base_1 = __webpack_require__(/*! ./base */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/v1/base.js");
const capnpSerializer_1 = __importDefault(__webpack_require__(/*! ../utils/capnpSerializer */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/capnpSerializer.js"));
/**
 *
 * @export
 */
exports.DUMMY_BASE_URL = 'https://example.com';
/**
 *
 * @throws {RequiredError}
 * @export
 */
const assertParamExists = function (functionName, paramName, paramValue) {
    if (paramValue === null || paramValue === undefined) {
        throw new base_1.RequiredError(paramName, `Required parameter ${paramName} was null or undefined when calling ${functionName}.`);
    }
};
exports.assertParamExists = assertParamExists;
/**
 *
 * @export
 */
const setApiKeyToObject = function (object, keyParamName, configuration) {
    return __awaiter(this, void 0, void 0, function* () {
        if (configuration && configuration.apiKey) {
            const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                ? yield configuration.apiKey(keyParamName)
                : yield configuration.apiKey;
            object[keyParamName] = localVarApiKeyValue;
        }
    });
};
exports.setApiKeyToObject = setApiKeyToObject;
/**
 *
 * @export
 */
const setBasicAuthToObject = function (object, configuration) {
    if (configuration && (configuration.username || configuration.password)) {
        object["auth"] = { username: configuration.username, password: configuration.password };
    }
};
exports.setBasicAuthToObject = setBasicAuthToObject;
/**
 *
 * @export
 */
const setBearerAuthToObject = function (object, configuration) {
    return __awaiter(this, void 0, void 0, function* () {
        if (configuration && configuration.accessToken) {
            const accessToken = typeof configuration.accessToken === 'function'
                ? yield configuration.accessToken()
                : yield configuration.accessToken;
            object["Authorization"] = "Bearer " + accessToken;
        }
    });
};
exports.setBearerAuthToObject = setBearerAuthToObject;
/**
 *
 * @export
 */
const setOAuthToObject = function (object, name, scopes, configuration) {
    return __awaiter(this, void 0, void 0, function* () {
        if (configuration && configuration.accessToken) {
            const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                ? yield configuration.accessToken(name, scopes)
                : yield configuration.accessToken;
            object["Authorization"] = "Bearer " + localVarAccessTokenValue;
        }
    });
};
exports.setOAuthToObject = setOAuthToObject;
/**
 *
 * @export
 */
const setSearchParams = function (url, ...objects) {
    const searchParams = new URLSearchParams(url.search);
    for (const object of objects) {
        for (const key in object) {
            if (Array.isArray(object[key])) {
                searchParams.delete(key);
                for (const item of object[key]) {
                    searchParams.append(key, item);
                }
            }
            else {
                searchParams.set(key, object[key]);
            }
        }
    }
    url.search = searchParams.toString();
};
exports.setSearchParams = setSearchParams;
/**
 *
 * @export
 */
const serializeDataIfNeeded = function (value, requestOptions, configuration) {
    const nonString = typeof value !== 'string';
    const needsJSONSerialization = nonString && configuration && configuration.isJsonMime
        ? configuration.isJsonMime(requestOptions.headers['Content-Type'])
        : nonString;
    if (needsJSONSerialization) {
        return JSON.stringify(value !== undefined ? value : {});
    }
    const needsCapnpSerialization = nonString && configuration && configuration.isJsonMime
        ? configuration.isCapnpMime(requestOptions.headers['Content-Type'])
        : nonString;
    if (needsCapnpSerialization) {
        return value !== undefined ? capnpSerializer_1.default(value) : '';
    }
    return value || "";
};
exports.serializeDataIfNeeded = serializeDataIfNeeded;
/**
 *
 * @export
 */
const toPathString = function (url) {
    return url.pathname + url.search + url.hash;
};
exports.toPathString = toPathString;
/**
 *
 * @export
 */
const createRequestFunction = function (axiosArgs, globalAxios, BASE_PATH, configuration) {
    return (axios = globalAxios, basePath = BASE_PATH) => {
        const axiosRequestArgs = Object.assign(Object.assign({}, axiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + axiosArgs.url });
        return axios.request(axiosRequestArgs);
    };
};
exports.createRequestFunction = createRequestFunction;
//# sourceMappingURL=common.js.map

/***/ }),

/***/ "./node_modules/@tiledb-inc/tiledb-cloud/lib/v1/configuration.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@tiledb-inc/tiledb-cloud/lib/v1/configuration.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/* tslint:disable */
/* eslint-disable */
/**
 * TileDB Storage Platform API
 * TileDB Storage Platform REST API
 *
 * The version of the OpenAPI document: 2.2.19
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Configuration = void 0;
class Configuration {
    constructor(param = {}) {
        this.apiKey = param.apiKey;
        this.username = param.username;
        this.password = param.password;
        this.accessToken = param.accessToken;
        this.basePath = param.basePath;
        this.baseOptions = param.baseOptions;
        this.formDataCtor = param.formDataCtor;
    }
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    isJsonMime(mime) {
        const jsonMime = new RegExp('^(application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(;.*)?$', 'i');
        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');
    }
    /**
     * Check if the given MIME is a capnp MIME.
     * JSON MIME examples:
     *   application/capnp
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is capnp, false otherwise.
     */
    isCapnpMime(mime) {
        return mime === 'application/capnp';
    }
}
exports.Configuration = Configuration;
//# sourceMappingURL=configuration.js.map

/***/ }),

/***/ "./node_modules/@tiledb-inc/tiledb-cloud/lib/v1/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@tiledb-inc/tiledb-cloud/lib/v1/index.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* tslint:disable */
/* eslint-disable */
/**
 * TileDB Storage Platform API
 * TileDB Storage Platform REST API
 *
 * The version of the OpenAPI document: 2.2.19
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./api */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/v1/api.js"), exports);
__exportStar(__webpack_require__(/*! ./configuration */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/v1/configuration.js"), exports);
__exportStar(__webpack_require__(/*! ./configuration */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/v1/configuration.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@tiledb-inc/tiledb-cloud/lib/v2/api.js":
/*!*************************************************************!*\
  !*** ./node_modules/@tiledb-inc/tiledb-cloud/lib/v2/api.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* tslint:disable */
/* eslint-disable */
/**
 * Tiledb Storage Platform API
 * TileDB Storage Platform REST API
 *
 * The version of the OpenAPI document: 1.4.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UserApi = exports.UserApiFactory = exports.UserApiFp = exports.UserApiAxiosParamCreator = exports.QueryApi = exports.QueryApiFactory = exports.QueryApiFp = exports.QueryApiAxiosParamCreator = exports.OrganizationApi = exports.OrganizationApiFactory = exports.OrganizationApiFp = exports.OrganizationApiAxiosParamCreator = exports.ArrayApi = exports.ArrayApiFactory = exports.ArrayApiFp = exports.ArrayApiAxiosParamCreator = exports.Querytype = exports.Querystatus = exports.Layout = exports.Datatype = exports.CloudProvider = exports.ActivityEventType = void 0;
const axios_1 = __importDefault(__webpack_require__(/*! axios */ "./node_modules/axios/index.js"));
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = __webpack_require__(/*! ./common */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/v2/common.js");
// @ts-ignore
const base_1 = __webpack_require__(/*! ./base */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/v2/base.js");
/**
 * Type of activity logged
 * @export
 * @enum {string}
 */
var ActivityEventType;
(function (ActivityEventType) {
    ActivityEventType["ReadSchema"] = "read_schema";
    ActivityEventType["MaxBufferSizes"] = "max_buffer_sizes";
    ActivityEventType["NonEmptyDomain"] = "non_empty_domain";
    ActivityEventType["QueryRead"] = "query_read";
    ActivityEventType["QueryWrite"] = "query_write";
    ActivityEventType["Create"] = "create";
    ActivityEventType["Delete"] = "delete";
    ActivityEventType["Register"] = "register";
    ActivityEventType["Deregister"] = "deregister";
    ActivityEventType["Udf"] = "udf";
    ActivityEventType["ArrayMetadataGet"] = "array_metadata_get";
    ActivityEventType["ArrayMetadataUpdate"] = "array_metadata_update";
    ActivityEventType["EstimatedResultSizes"] = "estimated_result_sizes";
    ActivityEventType["Update"] = "update";
    ActivityEventType["Info"] = "info";
    ActivityEventType["Run"] = "run";
})(ActivityEventType = exports.ActivityEventType || (exports.ActivityEventType = {}));
/**
 * A service where data is stored or computations take place.
 * @export
 * @enum {string}
 */
var CloudProvider;
(function (CloudProvider) {
    CloudProvider["Aws"] = "AWS";
    CloudProvider["Azure"] = "AZURE";
})(CloudProvider = exports.CloudProvider || (exports.CloudProvider = {}));
/**
 * TileDB data type
 * @export
 * @enum {string}
 */
var Datatype;
(function (Datatype) {
    Datatype["Int32"] = "INT32";
    Datatype["Int64"] = "INT64";
    Datatype["Float32"] = "FLOAT32";
    Datatype["Float64"] = "FLOAT64";
    Datatype["Char"] = "CHAR";
    Datatype["Int8"] = "INT8";
    Datatype["Uint8"] = "UINT8";
    Datatype["Int16"] = "INT16";
    Datatype["Uint16"] = "UINT16";
    Datatype["Uint32"] = "UINT32";
    Datatype["Uint64"] = "UINT64";
    Datatype["StringAscii"] = "STRING_ASCII";
    Datatype["StringUtf8"] = "STRING_UTF8";
    Datatype["StringUtf16"] = "STRING_UTF16";
    Datatype["StringUtf32"] = "STRING_UTF32";
    Datatype["StringUcs2"] = "STRING_UCS2";
    Datatype["StringUcs4"] = "STRING_UCS4";
    Datatype["DatetimeYear"] = "DATETIME_YEAR";
    Datatype["DatetimeMonth"] = "DATETIME_MONTH";
    Datatype["DatetimeWeek"] = "DATETIME_WEEK";
    Datatype["DatetimeDay"] = "DATETIME_DAY";
    Datatype["DatetimeHr"] = "DATETIME_HR";
    Datatype["DatetimeMin"] = "DATETIME_MIN";
    Datatype["DatetimeSec"] = "DATETIME_SEC";
    Datatype["DatetimeMs"] = "DATETIME_MS";
    Datatype["DatetimeUs"] = "DATETIME_US";
    Datatype["DatetimeNs"] = "DATETIME_NS";
    Datatype["DatetimePs"] = "DATETIME_PS";
    Datatype["DatetimeFs"] = "DATETIME_FS";
    Datatype["DatetimeAs"] = "DATETIME_AS";
    Datatype["Any"] = "ANY";
})(Datatype = exports.Datatype || (exports.Datatype = {}));
/**
 * Layout of array
 * @export
 * @enum {string}
 */
var Layout;
(function (Layout) {
    Layout["RowMajor"] = "row-major";
    Layout["ColMajor"] = "col-major";
    Layout["GlobalOrder"] = "global-order";
    Layout["Unordered"] = "unordered";
})(Layout = exports.Layout || (exports.Layout = {}));
/**
 * Status of query
 * @export
 * @enum {string}
 */
var Querystatus;
(function (Querystatus) {
    Querystatus["Failed"] = "FAILED";
    Querystatus["Completed"] = "COMPLETED";
    Querystatus["Inprogress"] = "INPROGRESS";
    Querystatus["Incomplete"] = "INCOMPLETE";
    Querystatus["Uninitialized"] = "UNINITIALIZED";
})(Querystatus = exports.Querystatus || (exports.Querystatus = {}));
/**
 * Type of query
 * @export
 * @enum {string}
 */
var Querytype;
(function (Querytype) {
    Querytype["Read"] = "READ";
    Querytype["Write"] = "WRITE";
})(Querytype = exports.Querytype || (exports.Querytype = {}));
/**
 * ArrayApi - axios parameter creator
 * @export
 */
const ArrayApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * get array activity logs
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
         * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
         * @param {Array<string>} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
         * @param {string} [taskId] Array task id To filter activity to
         * @param {boolean} [hasTaskId] Excludes activity log results that does not contain an array task uuid
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arrayActivityLog: (namespace, array, start, end, eventTypes, taskId, hasTaskId, page, perPage, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('arrayActivityLog', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('arrayActivityLog', 'array', array);
            const localVarPath = `/arrays/{namespace}/{array}/activity`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }
            if (eventTypes) {
                localVarQueryParameter['event_types'] = eventTypes;
            }
            if (taskId !== undefined) {
                localVarQueryParameter['task_id'] = taskId;
            }
            if (hasTaskId !== undefined) {
                localVarQueryParameter['has_task_id'] = hasTaskId;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.ArrayApiAxiosParamCreator = ArrayApiAxiosParamCreator;
/**
 * ArrayApi - functional programming interface
 * @export
 */
const ArrayApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.ArrayApiAxiosParamCreator(configuration);
    return {
        /**
         * get array activity logs
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
         * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
         * @param {Array<string>} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
         * @param {string} [taskId] Array task id To filter activity to
         * @param {boolean} [hasTaskId] Excludes activity log results that does not contain an array task uuid
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, page, perPage, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, page, perPage, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.ArrayApiFp = ArrayApiFp;
/**
 * ArrayApi - factory interface
 * @export
 */
const ArrayApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.ArrayApiFp(configuration);
    return {
        /**
         * get array activity logs
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
         * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
         * @param {Array<string>} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
         * @param {string} [taskId] Array task id To filter activity to
         * @param {boolean} [hasTaskId] Excludes activity log results that does not contain an array task uuid
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, page, perPage, options) {
            return localVarFp.arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, page, perPage, options).then((request) => request(axios, basePath));
        },
    };
};
exports.ArrayApiFactory = ArrayApiFactory;
/**
 * ArrayApi - object-oriented interface
 * @export
 * @class ArrayApi
 * @extends {BaseAPI}
 */
class ArrayApi extends base_1.BaseAPI {
    /**
     * get array activity logs
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {number} [start] Start time of window of fetch logs, unix epoch in seconds (default: seven days ago)
     * @param {number} [end] End time of window of fetch logs, unix epoch in seconds (default: current utc timestamp)
     * @param {Array<string>} [eventTypes] Event values can be one or more of the following read, write, create, delete, register, deregister, comma separated
     * @param {string} [taskId] Array task id To filter activity to
     * @param {boolean} [hasTaskId] Excludes activity log results that does not contain an array task uuid
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArrayApi
     */
    arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, page, perPage, options) {
        return exports.ArrayApiFp(this.configuration).arrayActivityLog(namespace, array, start, end, eventTypes, taskId, hasTaskId, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ArrayApi = ArrayApi;
/**
 * OrganizationApi - axios parameter creator
 * @export
 */
const OrganizationApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a new credential for the namespace
         * @param {string} namespace namespace
         * @param {AccessCredential} accessCredential The new credentials to be created.
         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCredential: (namespace, accessCredential, provider, page, perPage, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('addCredential', 'namespace', namespace);
            // verify required parameter 'accessCredential' is not null or undefined
            common_1.assertParamExists('addCredential', 'accessCredential', accessCredential);
            const localVarPath = `/credentials/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(accessCredential, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete the named access credential. Any arrays still set to use this credential will use the namespace\'s default and may become unreachable.
         * @param {string} namespace namespace
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCredential: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('deleteCredential', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('deleteCredential', 'name', name);
            const localVarPath = `/credentials/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve an access credential by name
         * @param {string} namespace namespace
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCredential: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getCredential', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('getCredential', 'name', name);
            const localVarPath = `/credentials/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List the credentials available in the namespace
         * @param {string} namespace namespace
         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCredentials: (namespace, provider, page, perPage, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('listCredentials', 'namespace', namespace);
            const localVarPath = `/credentials/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update the named access credential. This will also update the information used to access arrays set to use this credential.
         * @param {string} namespace namespace
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {AccessCredential} accessCredential Changes to make to this credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCredential: (namespace, name, accessCredential, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('updateCredential', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('updateCredential', 'name', name);
            // verify required parameter 'accessCredential' is not null or undefined
            common_1.assertParamExists('updateCredential', 'accessCredential', accessCredential);
            const localVarPath = `/credentials/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(accessCredential, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.OrganizationApiAxiosParamCreator = OrganizationApiAxiosParamCreator;
/**
 * OrganizationApi - functional programming interface
 * @export
 */
const OrganizationApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.OrganizationApiAxiosParamCreator(configuration);
    return {
        /**
         * Create a new credential for the namespace
         * @param {string} namespace namespace
         * @param {AccessCredential} accessCredential The new credentials to be created.
         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCredential(namespace, accessCredential, provider, page, perPage, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.addCredential(namespace, accessCredential, provider, page, perPage, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Delete the named access credential. Any arrays still set to use this credential will use the namespace\'s default and may become unreachable.
         * @param {string} namespace namespace
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCredential(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteCredential(namespace, name, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Retrieve an access credential by name
         * @param {string} namespace namespace
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCredential(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getCredential(namespace, name, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * List the credentials available in the namespace
         * @param {string} namespace namespace
         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCredentials(namespace, provider, page, perPage, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listCredentials(namespace, provider, page, perPage, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Update the named access credential. This will also update the information used to access arrays set to use this credential.
         * @param {string} namespace namespace
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {AccessCredential} accessCredential Changes to make to this credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCredential(namespace, name, accessCredential, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateCredential(namespace, name, accessCredential, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.OrganizationApiFp = OrganizationApiFp;
/**
 * OrganizationApi - factory interface
 * @export
 */
const OrganizationApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.OrganizationApiFp(configuration);
    return {
        /**
         * Create a new credential for the namespace
         * @param {string} namespace namespace
         * @param {AccessCredential} accessCredential The new credentials to be created.
         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCredential(namespace, accessCredential, provider, page, perPage, options) {
            return localVarFp.addCredential(namespace, accessCredential, provider, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the named access credential. Any arrays still set to use this credential will use the namespace\'s default and may become unreachable.
         * @param {string} namespace namespace
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCredential(namespace, name, options) {
            return localVarFp.deleteCredential(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an access credential by name
         * @param {string} namespace namespace
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCredential(namespace, name, options) {
            return localVarFp.getCredential(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * List the credentials available in the namespace
         * @param {string} namespace namespace
         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCredentials(namespace, provider, page, perPage, options) {
            return localVarFp.listCredentials(namespace, provider, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the named access credential. This will also update the information used to access arrays set to use this credential.
         * @param {string} namespace namespace
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {AccessCredential} accessCredential Changes to make to this credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCredential(namespace, name, accessCredential, options) {
            return localVarFp.updateCredential(namespace, name, accessCredential, options).then((request) => request(axios, basePath));
        },
    };
};
exports.OrganizationApiFactory = OrganizationApiFactory;
/**
 * OrganizationApi - object-oriented interface
 * @export
 * @class OrganizationApi
 * @extends {BaseAPI}
 */
class OrganizationApi extends base_1.BaseAPI {
    /**
     * Create a new credential for the namespace
     * @param {string} namespace namespace
     * @param {AccessCredential} accessCredential The new credentials to be created.
     * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    addCredential(namespace, accessCredential, provider, page, perPage, options) {
        return exports.OrganizationApiFp(this.configuration).addCredential(namespace, accessCredential, provider, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete the named access credential. Any arrays still set to use this credential will use the namespace\'s default and may become unreachable.
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    deleteCredential(namespace, name, options) {
        return exports.OrganizationApiFp(this.configuration).deleteCredential(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve an access credential by name
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    getCredential(namespace, name, options) {
        return exports.OrganizationApiFp(this.configuration).getCredential(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List the credentials available in the namespace
     * @param {string} namespace namespace
     * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    listCredentials(namespace, provider, page, perPage, options) {
        return exports.OrganizationApiFp(this.configuration).listCredentials(namespace, provider, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update the named access credential. This will also update the information used to access arrays set to use this credential.
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {AccessCredential} accessCredential Changes to make to this credential
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    updateCredential(namespace, name, accessCredential, options) {
        return exports.OrganizationApiFp(this.configuration).updateCredential(namespace, name, accessCredential, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.OrganizationApi = OrganizationApi;
/**
 * QueryApi - axios parameter creator
 * @export
 */
const QueryApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {string} [readAll] If \&quot;true\&quot;, resubmits incomplete queries until the query has completed. Defaults to \&quot;false\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitQuery: (namespace, array, type, contentType, query, xPayer, openAt, readAll, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('submitQuery', 'namespace', namespace);
            // verify required parameter 'array' is not null or undefined
            common_1.assertParamExists('submitQuery', 'array', array);
            // verify required parameter 'type' is not null or undefined
            common_1.assertParamExists('submitQuery', 'type', type);
            // verify required parameter 'contentType' is not null or undefined
            common_1.assertParamExists('submitQuery', 'contentType', contentType);
            // verify required parameter 'query' is not null or undefined
            common_1.assertParamExists('submitQuery', 'query', query);
            const localVarPath = `/arrays/{namespace}/{array}/query/submit`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"array"}}`, encodeURIComponent(String(array)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            if (openAt !== undefined) {
                localVarQueryParameter['open_at'] = openAt;
            }
            if (readAll !== undefined) {
                localVarQueryParameter['read_all'] = readAll;
            }
            if (contentType !== undefined && contentType !== null) {
                localVarHeaderParameter['Content-Type'] = String(contentType);
            }
            if (xPayer !== undefined && xPayer !== null) {
                localVarHeaderParameter['X-Payer'] = String(xPayer);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(query, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.QueryApiAxiosParamCreator = QueryApiAxiosParamCreator;
/**
 * QueryApi - functional programming interface
 * @export
 */
const QueryApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.QueryApiAxiosParamCreator(configuration);
    return {
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {string} [readAll] If \&quot;true\&quot;, resubmits incomplete queries until the query has completed. Defaults to \&quot;false\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitQuery(namespace, array, type, contentType, query, xPayer, openAt, readAll, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.submitQuery(namespace, array, type, contentType, query, xPayer, openAt, readAll, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.QueryApiFp = QueryApiFp;
/**
 * QueryApi - factory interface
 * @export
 */
const QueryApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.QueryApiFp(configuration);
    return {
        /**
         * send a query to run against a specified array/URI registered to a group/project
         * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
         * @param {string} array name/uri of array that is url-encoded
         * @param {string} type type of query
         * @param {string} contentType Content Type of input and return mime
         * @param {Query} query query to run
         * @param {string} [xPayer] Name of organization or user who should be charged for this request
         * @param {number} [openAt] open_at for array in unix epoch
         * @param {string} [readAll] If \&quot;true\&quot;, resubmits incomplete queries until the query has completed. Defaults to \&quot;false\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitQuery(namespace, array, type, contentType, query, xPayer, openAt, readAll, options) {
            return localVarFp.submitQuery(namespace, array, type, contentType, query, xPayer, openAt, readAll, options).then((request) => request(axios, basePath));
        },
    };
};
exports.QueryApiFactory = QueryApiFactory;
/**
 * QueryApi - object-oriented interface
 * @export
 * @class QueryApi
 * @extends {BaseAPI}
 */
class QueryApi extends base_1.BaseAPI {
    /**
     * send a query to run against a specified array/URI registered to a group/project
     * @param {string} namespace namespace array is in (an organization name or user\&#39;s username)
     * @param {string} array name/uri of array that is url-encoded
     * @param {string} type type of query
     * @param {string} contentType Content Type of input and return mime
     * @param {Query} query query to run
     * @param {string} [xPayer] Name of organization or user who should be charged for this request
     * @param {number} [openAt] open_at for array in unix epoch
     * @param {string} [readAll] If \&quot;true\&quot;, resubmits incomplete queries until the query has completed. Defaults to \&quot;false\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    submitQuery(namespace, array, type, contentType, query, xPayer, openAt, readAll, options) {
        return exports.QueryApiFp(this.configuration).submitQuery(namespace, array, type, contentType, query, xPayer, openAt, readAll, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.QueryApi = QueryApi;
/**
 * UserApi - axios parameter creator
 * @export
 */
const UserApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a new credential for the namespace
         * @param {string} namespace namespace
         * @param {AccessCredential} accessCredential The new credentials to be created.
         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCredential: (namespace, accessCredential, provider, page, perPage, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('addCredential', 'namespace', namespace);
            // verify required parameter 'accessCredential' is not null or undefined
            common_1.assertParamExists('addCredential', 'accessCredential', accessCredential);
            const localVarPath = `/credentials/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(accessCredential, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete the named access credential. Any arrays still set to use this credential will use the namespace\'s default and may become unreachable.
         * @param {string} namespace namespace
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCredential: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('deleteCredential', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('deleteCredential', 'name', name);
            const localVarPath = `/credentials/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve an access credential by name
         * @param {string} namespace namespace
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCredential: (namespace, name, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('getCredential', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('getCredential', 'name', name);
            const localVarPath = `/credentials/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List the credentials available in the namespace
         * @param {string} namespace namespace
         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCredentials: (namespace, provider, page, perPage, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('listCredentials', 'namespace', namespace);
            const localVarPath = `/credentials/{namespace}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update the named access credential. This will also update the information used to access arrays set to use this credential.
         * @param {string} namespace namespace
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {AccessCredential} accessCredential Changes to make to this credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCredential: (namespace, name, accessCredential, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'namespace' is not null or undefined
            common_1.assertParamExists('updateCredential', 'namespace', namespace);
            // verify required parameter 'name' is not null or undefined
            common_1.assertParamExists('updateCredential', 'name', name);
            // verify required parameter 'accessCredential' is not null or undefined
            common_1.assertParamExists('updateCredential', 'accessCredential', accessCredential);
            const localVarPath = `/credentials/{namespace}/{name}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication ApiKeyAuth required
            yield common_1.setApiKeyToObject(localVarHeaderParameter, "X-TILEDB-REST-API-KEY", configuration);
            // authentication BasicAuth required
            // http basic authentication required
            common_1.setBasicAuthToObject(localVarRequestOptions, configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            if (localVarRequestOptions.method === 'GET' && localVarRequestOptions.headers.Accept === 'application/capnp') {
                // for application/capnp mime type requests default responseType to 'arraybuffer'
                localVarRequestOptions.responseType = options.responseType || 'arraybuffer';
            }
            localVarRequestOptions.data = common_1.serializeDataIfNeeded(accessCredential, localVarRequestOptions, configuration);
            return {
                url: common_1.toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.UserApiAxiosParamCreator = UserApiAxiosParamCreator;
/**
 * UserApi - functional programming interface
 * @export
 */
const UserApiFp = function (configuration) {
    const localVarAxiosParamCreator = exports.UserApiAxiosParamCreator(configuration);
    return {
        /**
         * Create a new credential for the namespace
         * @param {string} namespace namespace
         * @param {AccessCredential} accessCredential The new credentials to be created.
         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCredential(namespace, accessCredential, provider, page, perPage, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.addCredential(namespace, accessCredential, provider, page, perPage, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Delete the named access credential. Any arrays still set to use this credential will use the namespace\'s default and may become unreachable.
         * @param {string} namespace namespace
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCredential(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteCredential(namespace, name, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Retrieve an access credential by name
         * @param {string} namespace namespace
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCredential(namespace, name, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getCredential(namespace, name, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * List the credentials available in the namespace
         * @param {string} namespace namespace
         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCredentials(namespace, provider, page, perPage, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.listCredentials(namespace, provider, page, perPage, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Update the named access credential. This will also update the information used to access arrays set to use this credential.
         * @param {string} namespace namespace
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {AccessCredential} accessCredential Changes to make to this credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCredential(namespace, name, accessCredential, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateCredential(namespace, name, accessCredential, options);
                return common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.UserApiFp = UserApiFp;
/**
 * UserApi - factory interface
 * @export
 */
const UserApiFactory = function (configuration, basePath, axios) {
    const localVarFp = exports.UserApiFp(configuration);
    return {
        /**
         * Create a new credential for the namespace
         * @param {string} namespace namespace
         * @param {AccessCredential} accessCredential The new credentials to be created.
         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCredential(namespace, accessCredential, provider, page, perPage, options) {
            return localVarFp.addCredential(namespace, accessCredential, provider, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the named access credential. Any arrays still set to use this credential will use the namespace\'s default and may become unreachable.
         * @param {string} namespace namespace
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCredential(namespace, name, options) {
            return localVarFp.deleteCredential(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an access credential by name
         * @param {string} namespace namespace
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCredential(namespace, name, options) {
            return localVarFp.getCredential(namespace, name, options).then((request) => request(axios, basePath));
        },
        /**
         * List the credentials available in the namespace
         * @param {string} namespace namespace
         * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
         * @param {number} [page] pagination offset
         * @param {number} [perPage] pagination limit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCredentials(namespace, provider, page, perPage, options) {
            return localVarFp.listCredentials(namespace, provider, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the named access credential. This will also update the information used to access arrays set to use this credential.
         * @param {string} namespace namespace
         * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
         * @param {AccessCredential} accessCredential Changes to make to this credential
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCredential(namespace, name, accessCredential, options) {
            return localVarFp.updateCredential(namespace, name, accessCredential, options).then((request) => request(axios, basePath));
        },
    };
};
exports.UserApiFactory = UserApiFactory;
/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
class UserApi extends base_1.BaseAPI {
    /**
     * Create a new credential for the namespace
     * @param {string} namespace namespace
     * @param {AccessCredential} accessCredential The new credentials to be created.
     * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    addCredential(namespace, accessCredential, provider, page, perPage, options) {
        return exports.UserApiFp(this.configuration).addCredential(namespace, accessCredential, provider, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete the named access credential. Any arrays still set to use this credential will use the namespace\'s default and may become unreachable.
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    deleteCredential(namespace, name, options) {
        return exports.UserApiFp(this.configuration).deleteCredential(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve an access credential by name
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getCredential(namespace, name, options) {
        return exports.UserApiFp(this.configuration).getCredential(namespace, name, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List the credentials available in the namespace
     * @param {string} namespace namespace
     * @param {string} [provider] Show only the credentials from this provider. This should be one of the CloudProvider enum values.
     * @param {number} [page] pagination offset
     * @param {number} [perPage] pagination limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    listCredentials(namespace, provider, page, perPage, options) {
        return exports.UserApiFp(this.configuration).listCredentials(namespace, provider, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update the named access credential. This will also update the information used to access arrays set to use this credential.
     * @param {string} namespace namespace
     * @param {string} name A URL-safe version of the credential\&#39;s user-provided name
     * @param {AccessCredential} accessCredential Changes to make to this credential
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    updateCredential(namespace, name, accessCredential, options) {
        return exports.UserApiFp(this.configuration).updateCredential(namespace, name, accessCredential, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.UserApi = UserApi;
//# sourceMappingURL=api.js.map

/***/ }),

/***/ "./node_modules/@tiledb-inc/tiledb-cloud/lib/v2/base.js":
/*!**************************************************************!*\
  !*** ./node_modules/@tiledb-inc/tiledb-cloud/lib/v2/base.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* tslint:disable */
/* eslint-disable */
/**
 * Tiledb Storage Platform API
 * TileDB Storage Platform REST API
 *
 * The version of the OpenAPI document: 1.4.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RequiredError = exports.BaseAPI = exports.COLLECTION_FORMATS = exports.BASE_PATH = void 0;
// Some imports not used depending on template conditions
// @ts-ignore
const axios_1 = __importDefault(__webpack_require__(/*! axios */ "./node_modules/axios/index.js"));
exports.BASE_PATH = "https://api.tiledb.com/v2".replace(/\/+$/, "");
/**
 *
 * @export
 */
exports.COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};
/**
 *
 * @export
 * @class BaseAPI
 */
class BaseAPI {
    constructor(configuration, basePath = exports.BASE_PATH, axios = axios_1.default) {
        this.basePath = basePath;
        this.axios = axios;
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
}
exports.BaseAPI = BaseAPI;
;
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
class RequiredError extends Error {
    constructor(field, msg) {
        super(msg);
        this.field = field;
        this.name = "RequiredError";
    }
}
exports.RequiredError = RequiredError;
//# sourceMappingURL=base.js.map

/***/ }),

/***/ "./node_modules/@tiledb-inc/tiledb-cloud/lib/v2/common.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tiledb-inc/tiledb-cloud/lib/v2/common.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* tslint:disable */
/* eslint-disable */
/**
 * Tiledb Storage Platform API
 * TileDB Storage Platform REST API
 *
 * The version of the OpenAPI document: 1.4.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createRequestFunction = exports.toPathString = exports.serializeDataIfNeeded = exports.setSearchParams = exports.setOAuthToObject = exports.setBearerAuthToObject = exports.setBasicAuthToObject = exports.setApiKeyToObject = exports.assertParamExists = exports.DUMMY_BASE_URL = void 0;
const base_1 = __webpack_require__(/*! ./base */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/v2/base.js");
const capnpSerializer_1 = __importDefault(__webpack_require__(/*! ../utils/capnpSerializer */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/utils/capnpSerializer.js"));
/**
 *
 * @export
 */
exports.DUMMY_BASE_URL = 'https://example.com';
/**
 *
 * @throws {RequiredError}
 * @export
 */
const assertParamExists = function (functionName, paramName, paramValue) {
    if (paramValue === null || paramValue === undefined) {
        throw new base_1.RequiredError(paramName, `Required parameter ${paramName} was null or undefined when calling ${functionName}.`);
    }
};
exports.assertParamExists = assertParamExists;
/**
 *
 * @export
 */
const setApiKeyToObject = function (object, keyParamName, configuration) {
    return __awaiter(this, void 0, void 0, function* () {
        if (configuration && configuration.apiKey) {
            const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                ? yield configuration.apiKey(keyParamName)
                : yield configuration.apiKey;
            object[keyParamName] = localVarApiKeyValue;
        }
    });
};
exports.setApiKeyToObject = setApiKeyToObject;
/**
 *
 * @export
 */
const setBasicAuthToObject = function (object, configuration) {
    if (configuration && (configuration.username || configuration.password)) {
        object["auth"] = { username: configuration.username, password: configuration.password };
    }
};
exports.setBasicAuthToObject = setBasicAuthToObject;
/**
 *
 * @export
 */
const setBearerAuthToObject = function (object, configuration) {
    return __awaiter(this, void 0, void 0, function* () {
        if (configuration && configuration.accessToken) {
            const accessToken = typeof configuration.accessToken === 'function'
                ? yield configuration.accessToken()
                : yield configuration.accessToken;
            object["Authorization"] = "Bearer " + accessToken;
        }
    });
};
exports.setBearerAuthToObject = setBearerAuthToObject;
/**
 *
 * @export
 */
const setOAuthToObject = function (object, name, scopes, configuration) {
    return __awaiter(this, void 0, void 0, function* () {
        if (configuration && configuration.accessToken) {
            const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                ? yield configuration.accessToken(name, scopes)
                : yield configuration.accessToken;
            object["Authorization"] = "Bearer " + localVarAccessTokenValue;
        }
    });
};
exports.setOAuthToObject = setOAuthToObject;
/**
 *
 * @export
 */
const setSearchParams = function (url, ...objects) {
    const searchParams = new URLSearchParams(url.search);
    for (const object of objects) {
        for (const key in object) {
            if (Array.isArray(object[key])) {
                searchParams.delete(key);
                for (const item of object[key]) {
                    searchParams.append(key, item);
                }
            }
            else {
                searchParams.set(key, object[key]);
            }
        }
    }
    url.search = searchParams.toString();
};
exports.setSearchParams = setSearchParams;
/**
 *
 * @export
 */
const serializeDataIfNeeded = function (value, requestOptions, configuration) {
    const nonString = typeof value !== 'string';
    const needsJSONSerialization = nonString && configuration && configuration.isJsonMime
        ? configuration.isJsonMime(requestOptions.headers['Content-Type'])
        : nonString;
    if (needsJSONSerialization) {
        return JSON.stringify(value !== undefined ? value : {});
    }
    const needsCapnpSerialization = nonString && configuration && configuration.isJsonMime
        ? configuration.isCapnpMime(requestOptions.headers['Content-Type'])
        : nonString;
    if (needsCapnpSerialization) {
        return value !== undefined ? capnpSerializer_1.default(value) : '';
    }
    return value || "";
};
exports.serializeDataIfNeeded = serializeDataIfNeeded;
/**
 *
 * @export
 */
const toPathString = function (url) {
    return url.pathname + url.search + url.hash;
};
exports.toPathString = toPathString;
/**
 *
 * @export
 */
const createRequestFunction = function (axiosArgs, globalAxios, BASE_PATH, configuration) {
    return (axios = globalAxios, basePath = BASE_PATH) => {
        const axiosRequestArgs = Object.assign(Object.assign({}, axiosArgs.options), { url: ((configuration === null || configuration === void 0 ? void 0 : configuration.basePath) || basePath) + axiosArgs.url });
        return axios.request(axiosRequestArgs);
    };
};
exports.createRequestFunction = createRequestFunction;
//# sourceMappingURL=common.js.map

/***/ }),

/***/ "./node_modules/@tiledb-inc/tiledb-cloud/lib/v2/configuration.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@tiledb-inc/tiledb-cloud/lib/v2/configuration.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/* tslint:disable */
/* eslint-disable */
/**
 * Tiledb Storage Platform API
 * TileDB Storage Platform REST API
 *
 * The version of the OpenAPI document: 1.4.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Configuration = void 0;
class Configuration {
    constructor(param = {}) {
        this.apiKey = param.apiKey;
        this.username = param.username;
        this.password = param.password;
        this.accessToken = param.accessToken;
        this.basePath = param.basePath;
        this.baseOptions = param.baseOptions;
        this.formDataCtor = param.formDataCtor;
    }
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    isJsonMime(mime) {
        const jsonMime = new RegExp('^(application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(;.*)?$', 'i');
        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');
    }
    /**
     * Check if the given MIME is a capnp MIME.
     * JSON MIME examples:
     *   application/capnp
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is capnp, false otherwise.
     */
    isCapnpMime(mime) {
        return mime === 'application/capnp';
    }
}
exports.Configuration = Configuration;
//# sourceMappingURL=configuration.js.map

/***/ }),

/***/ "./node_modules/@tiledb-inc/tiledb-cloud/lib/v2/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@tiledb-inc/tiledb-cloud/lib/v2/index.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* tslint:disable */
/* eslint-disable */
/**
 * Tiledb Storage Platform API
 * TileDB Storage Platform REST API
 *
 * The version of the OpenAPI document: 1.4.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./api */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/v2/api.js"), exports);
__exportStar(__webpack_require__(/*! ./configuration */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/v2/configuration.js"), exports);
__exportStar(__webpack_require__(/*! ./configuration */ "./node_modules/@tiledb-inc/tiledb-cloud/lib/v2/configuration.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/axios/index.js":
/*!*************************************!*\
  !*** ./node_modules/axios/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./lib/axios */ "./node_modules/axios/lib/axios.js");

/***/ }),

/***/ "./node_modules/axios/lib/adapters/xhr.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/adapters/xhr.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var settle = __webpack_require__(/*! ./../core/settle */ "./node_modules/axios/lib/core/settle.js");
var cookies = __webpack_require__(/*! ./../helpers/cookies */ "./node_modules/axios/lib/helpers/cookies.js");
var buildURL = __webpack_require__(/*! ./../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");
var buildFullPath = __webpack_require__(/*! ../core/buildFullPath */ "./node_modules/axios/lib/core/buildFullPath.js");
var parseHeaders = __webpack_require__(/*! ./../helpers/parseHeaders */ "./node_modules/axios/lib/helpers/parseHeaders.js");
var isURLSameOrigin = __webpack_require__(/*! ./../helpers/isURLSameOrigin */ "./node_modules/axios/lib/helpers/isURLSameOrigin.js");
var createError = __webpack_require__(/*! ../core/createError */ "./node_modules/axios/lib/core/createError.js");

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;
    var responseType = config.responseType;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?
        request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(createError('Request aborted', config, 'ECONNABORTED', request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(createError(
        timeoutErrorMessage,
        config,
        config.transitional && config.transitional.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED',
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
        cookies.read(config.xsrfCookieName) :
        undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = config.responseType;
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel);
        // Clean up request
        request = null;
      });
    }

    if (!requestData) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/axios.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/axios.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");
var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");
var Axios = __webpack_require__(/*! ./core/Axios */ "./node_modules/axios/lib/core/Axios.js");
var mergeConfig = __webpack_require__(/*! ./core/mergeConfig */ "./node_modules/axios/lib/core/mergeConfig.js");
var defaults = __webpack_require__(/*! ./defaults */ "./node_modules/axios/lib/defaults.js");

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(mergeConfig(axios.defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = __webpack_require__(/*! ./cancel/Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");
axios.CancelToken = __webpack_require__(/*! ./cancel/CancelToken */ "./node_modules/axios/lib/cancel/CancelToken.js");
axios.isCancel = __webpack_require__(/*! ./cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = __webpack_require__(/*! ./helpers/spread */ "./node_modules/axios/lib/helpers/spread.js");

// Expose isAxiosError
axios.isAxiosError = __webpack_require__(/*! ./helpers/isAxiosError */ "./node_modules/axios/lib/helpers/isAxiosError.js");

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports["default"] = axios;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/Cancel.js":
/*!*************************************************!*\
  !*** ./node_modules/axios/lib/cancel/Cancel.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";


/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/CancelToken.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CancelToken.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Cancel = __webpack_require__(/*! ./Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/isCancel.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/cancel/isCancel.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};


/***/ }),

/***/ "./node_modules/axios/lib/core/Axios.js":
/*!**********************************************!*\
  !*** ./node_modules/axios/lib/core/Axios.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var buildURL = __webpack_require__(/*! ../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");
var InterceptorManager = __webpack_require__(/*! ./InterceptorManager */ "./node_modules/axios/lib/core/InterceptorManager.js");
var dispatchRequest = __webpack_require__(/*! ./dispatchRequest */ "./node_modules/axios/lib/core/dispatchRequest.js");
var mergeConfig = __webpack_require__(/*! ./mergeConfig */ "./node_modules/axios/lib/core/mergeConfig.js");
var validator = __webpack_require__(/*! ../helpers/validator */ "./node_modules/axios/lib/helpers/validator.js");

var validators = validator.validators;
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = arguments[1] || {};
    config.url = arguments[0];
  } else {
    config = config || {};
  }

  config = mergeConfig(this.defaults, config);

  // Set config.method
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  }

  var transitional = config.transitional;

  if (transitional !== undefined) {
    validator.assertOptions(transitional, {
      silentJSONParsing: validators.transitional(validators.boolean, '1.0.0'),
      forcedJSONParsing: validators.transitional(validators.boolean, '1.0.0'),
      clarifyTimeoutError: validators.transitional(validators.boolean, '1.0.0')
    }, false);
  }

  // filter out skipped interceptors
  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
      return;
    }

    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });

  var promise;

  if (!synchronousRequestInterceptors) {
    var chain = [dispatchRequest, undefined];

    Array.prototype.unshift.apply(chain, requestInterceptorChain);
    chain = chain.concat(responseInterceptorChain);

    promise = Promise.resolve(config);
    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }

    return promise;
  }


  var newConfig = config;
  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();
    try {
      newConfig = onFulfilled(newConfig);
    } catch (error) {
      onRejected(error);
      break;
    }
  }

  try {
    promise = dispatchRequest(newConfig);
  } catch (error) {
    return Promise.reject(error);
  }

  while (responseInterceptorChain.length) {
    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: (config || {}).data
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;


/***/ }),

/***/ "./node_modules/axios/lib/core/InterceptorManager.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/core/InterceptorManager.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected,
    synchronous: options ? options.synchronous : false,
    runWhen: options ? options.runWhen : null
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;


/***/ }),

/***/ "./node_modules/axios/lib/core/buildFullPath.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/buildFullPath.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isAbsoluteURL = __webpack_require__(/*! ../helpers/isAbsoluteURL */ "./node_modules/axios/lib/helpers/isAbsoluteURL.js");
var combineURLs = __webpack_require__(/*! ../helpers/combineURLs */ "./node_modules/axios/lib/helpers/combineURLs.js");

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */
module.exports = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
};


/***/ }),

/***/ "./node_modules/axios/lib/core/createError.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/createError.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var enhanceError = __webpack_require__(/*! ./enhanceError */ "./node_modules/axios/lib/core/enhanceError.js");

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};


/***/ }),

/***/ "./node_modules/axios/lib/core/dispatchRequest.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/core/dispatchRequest.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var transformData = __webpack_require__(/*! ./transformData */ "./node_modules/axios/lib/core/transformData.js");
var isCancel = __webpack_require__(/*! ../cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");
var defaults = __webpack_require__(/*! ../defaults */ "./node_modules/axios/lib/defaults.js");

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData.call(
    config,
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData.call(
      config,
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/core/enhanceError.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/core/enhanceError.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */
module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }

  error.request = request;
  error.response = response;
  error.isAxiosError = true;

  error.toJSON = function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code
    };
  };
  return error;
};


/***/ }),

/***/ "./node_modules/axios/lib/core/mergeConfig.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/mergeConfig.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */
module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};

  var valueFromConfig2Keys = ['url', 'method', 'data'];
  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];
  var defaultToConfig2Keys = [
    'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',
    'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',
    'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress',
    'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent',
    'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'
  ];
  var directMergeKeys = ['validateStatus'];

  function getMergedValue(target, source) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge(target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  function mergeDeepProperties(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  }

  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    }
  });

  utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);

  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });

  utils.forEach(directMergeKeys, function merge(prop) {
    if (prop in config2) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });

  var axiosKeys = valueFromConfig2Keys
    .concat(mergeDeepPropertiesKeys)
    .concat(defaultToConfig2Keys)
    .concat(directMergeKeys);

  var otherKeys = Object
    .keys(config1)
    .concat(Object.keys(config2))
    .filter(function filterAxiosKeys(key) {
      return axiosKeys.indexOf(key) === -1;
    });

  utils.forEach(otherKeys, mergeDeepProperties);

  return config;
};


/***/ }),

/***/ "./node_modules/axios/lib/core/settle.js":
/*!***********************************************!*\
  !*** ./node_modules/axios/lib/core/settle.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var createError = __webpack_require__(/*! ./createError */ "./node_modules/axios/lib/core/createError.js");

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError(
      'Request failed with status code ' + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};


/***/ }),

/***/ "./node_modules/axios/lib/core/transformData.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/transformData.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var defaults = __webpack_require__(/*! ./../defaults */ "./node_modules/axios/lib/defaults.js");

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  var context = this || defaults;
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn.call(context, data, headers);
  });

  return data;
};


/***/ }),

/***/ "./node_modules/axios/lib/defaults.js":
/*!********************************************!*\
  !*** ./node_modules/axios/lib/defaults.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "./node_modules/process/browser.js");


var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");
var normalizeHeaderName = __webpack_require__(/*! ./helpers/normalizeHeaderName */ "./node_modules/axios/lib/helpers/normalizeHeaderName.js");
var enhanceError = __webpack_require__(/*! ./core/enhanceError */ "./node_modules/axios/lib/core/enhanceError.js");

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(/*! ./adapters/xhr */ "./node_modules/axios/lib/adapters/xhr.js");
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = __webpack_require__(/*! ./adapters/http */ "./node_modules/axios/lib/adapters/xhr.js");
  }
  return adapter;
}

function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

var defaults = {

  transitional: {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  },

  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');

    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data) || (headers && headers['Content-Type'] === 'application/json')) {
      setContentTypeIfUnset(headers, 'application/json');
      return stringifySafely(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    var transitional = this.transitional;
    var silentJSONParsing = transitional && transitional.silentJSONParsing;
    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';

    if (strictJSONParsing || (forcedJSONParsing && utils.isString(data) && data.length)) {
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw enhanceError(e, this, 'E_JSON_PARSE');
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;


/***/ }),

/***/ "./node_modules/axios/lib/helpers/bind.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/bind.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/buildURL.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/buildURL.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/combineURLs.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/combineURLs.js ***!
  \*******************************************************/
/***/ ((module) => {

"use strict";


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/cookies.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/helpers/cookies.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
    (function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + '=' + encodeURIComponent(value));

          if (utils.isNumber(expires)) {
            cookie.push('expires=' + new Date(expires).toGMTString());
          }

          if (utils.isString(path)) {
            cookie.push('path=' + path);
          }

          if (utils.isString(domain)) {
            cookie.push('domain=' + domain);
          }

          if (secure === true) {
            cookie.push('secure');
          }

          document.cookie = cookie.join('; ');
        },

        read: function read(name) {
          var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
          return (match ? decodeURIComponent(match[3]) : null);
        },

        remove: function remove(name) {
          this.write(name, '', Date.now() - 86400000);
        }
      };
    })() :

  // Non standard browser env (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return {
        write: function write() {},
        read: function read() { return null; },
        remove: function remove() {}
      };
    })()
);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAbsoluteURL.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAbsoluteURL.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAxiosError.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAxiosError.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";


/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
module.exports = function isAxiosError(payload) {
  return (typeof payload === 'object') && (payload.isAxiosError === true);
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isURLSameOrigin.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isURLSameOrigin.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
    (function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement('a');
      var originURL;

      /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
      function resolveURL(url) {
        var href = url;

        if (msie) {
        // IE needs attribute set twice to normalize properties
          urlParsingNode.setAttribute('href', href);
          href = urlParsingNode.href;
        }

        urlParsingNode.setAttribute('href', href);

        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
            urlParsingNode.pathname :
            '/' + urlParsingNode.pathname
        };
      }

      originURL = resolveURL(window.location.href);

      /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
      return function isURLSameOrigin(requestURL) {
        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
        return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
      };
    })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    })()
);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/normalizeHeaderName.js":
/*!***************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/normalizeHeaderName.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/parseHeaders.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseHeaders.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/spread.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/helpers/spread.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/validator.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/validator.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var pkg = __webpack_require__(/*! ./../../package.json */ "./node_modules/axios/package.json");

var validators = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function(type, i) {
  validators[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});

var deprecatedWarnings = {};
var currentVerArr = pkg.version.split('.');

/**
 * Compare package versions
 * @param {string} version
 * @param {string?} thanVersion
 * @returns {boolean}
 */
function isOlderVersion(version, thanVersion) {
  var pkgVersionArr = thanVersion ? thanVersion.split('.') : currentVerArr;
  var destVer = version.split('.');
  for (var i = 0; i < 3; i++) {
    if (pkgVersionArr[i] > destVer[i]) {
      return true;
    } else if (pkgVersionArr[i] < destVer[i]) {
      return false;
    }
  }
  return false;
}

/**
 * Transitional option validator
 * @param {function|boolean?} validator
 * @param {string?} version
 * @param {string} message
 * @returns {function}
 */
validators.transitional = function transitional(validator, version, message) {
  var isDeprecated = version && isOlderVersion(version);

  function formatMessage(opt, desc) {
    return '[Axios v' + pkg.version + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return function(value, opt, opts) {
    if (validator === false) {
      throw new Error(formatMessage(opt, ' has been removed in ' + version));
    }

    if (isDeprecated && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(
        formatMessage(
          opt,
          ' has been deprecated since v' + version + ' and will be removed in the near future'
        )
      );
    }

    return validator ? validator(value, opt, opts) : true;
  };
};

/**
 * Assert object's properties type
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new TypeError('options must be an object');
  }
  var keys = Object.keys(options);
  var i = keys.length;
  while (i-- > 0) {
    var opt = keys[i];
    var validator = schema[opt];
    if (validator) {
      var value = options[opt];
      var result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new TypeError('option ' + opt + ' must be ' + result);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw Error('Unknown option ' + opt);
    }
  }
}

module.exports = {
  isOlderVersion: isOlderVersion,
  assertOptions: assertOptions,
  validators: validators
};


/***/ }),

/***/ "./node_modules/axios/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/utils.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return (typeof FormData !== 'undefined') && (val instanceof FormData);
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */
function isPlainObject(val) {
  if (toString.call(val) !== '[object Object]') {
    return false;
  }

  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                           navigator.product === 'NativeScript' ||
                                           navigator.product === 'NS')) {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */
function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isPlainObject: isPlainObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim,
  stripBOM: stripBOM
};


/***/ }),

/***/ "./node_modules/capnp-ts/lib/constants.js":
/*!************************************************!*\
  !*** ./node_modules/capnp-ts/lib/constants.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * @author jdiaz5513
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
// Perform some bit gymnastics to determine the native endian format.
var tmpWord = new DataView(new ArrayBuffer(8));
new Uint16Array(tmpWord.buffer)[0] = 0x0102;
/** Default size (in bytes) for newly allocated segments. */
exports.DEFAULT_BUFFER_SIZE = 4096;
exports.DEFAULT_DECODE_LIMIT = 64 << 20; // 64 MiB
/**
 * Limit to how deeply nested pointers are allowed to be. The root struct of a message will start at this value, and it
 * is decremented as pointers are dereferenced.
 */
exports.DEFAULT_DEPTH_LIMIT = 64;
/**
 * Limit to the number of **bytes** that can be traversed in a single message. This is necessary to prevent certain
 * classes of DoS attacks where maliciously crafted data can be self-referencing in a way that wouldn't trigger the
 * depth limit.
 *
 * For this reason, it is advised to cache pointers into variables and not constantly dereference them since the
 * message's traversal limit gets decremented each time.
 */
exports.DEFAULT_TRAVERSE_LIMIT = 64 << 20; // 64 MiB
/**
 * When allocating array buffers dynamically (while packing or in certain Arena implementations) the previous buffer's
 * size is multiplied by this number to determine the next buffer's size. This is chosen to keep both time spent
 * reallocating and wasted memory to a minimum.
 *
 * Smaller numbers would save memory at the expense of CPU time.
 */
exports.GROWTH_FACTOR = 1.5;
/** A bitmask applied to obtain the size of a list pointer. */
exports.LIST_SIZE_MASK = 0x00000007;
/** Maximum number of bytes to dump at once when dumping array buffers to string. */
exports.MAX_BUFFER_DUMP_BYTES = 8192;
/** The maximum value for a 32-bit integer. */
exports.MAX_INT32 = 0x7fffffff;
/** The maximum value for a 32-bit unsigned integer. */
exports.MAX_UINT32 = 0xffffffff;
/** The largest integer that can be precisely represented in JavaScript. */
exports.MAX_SAFE_INTEGER = 9007199254740991;
/** Maximum limit on the number of segments in a message stream. */
exports.MAX_STREAM_SEGMENTS = 512;
/** The smallest integer that can be precisely represented in JavaScript. */
exports.MIN_SAFE_INTEGER = -9007199254740991;
/** Minimum growth increment for a SingleSegmentArena. */
exports.MIN_SINGLE_SEGMENT_GROWTH = 4096;
/**
 * This will be `true` if the machine running this code stores numbers natively in little-endian format. This is useful
 * for some numeric type conversions when the endianness does not affect the output. Using the native endianness for
 * these operations is _slightly_ faster.
 */
exports.NATIVE_LITTLE_ENDIAN = tmpWord.getUint8(0) === 0x02;
/**
 * When packing a message, this is the number of zero bytes required after a SPAN (0xff) tag is written to the packed
 * message before the span is terminated.
 *
 * This little detail is left up to the implementation because it can be tuned for performance. Setting this to a higher
 * value may help with messages that contain a ton of text/data.
 *
 * It is imperative to never set this below 1 or else BAD THINGS. You have been warned.
 */
exports.PACK_SPAN_THRESHOLD = 2;
/**
 * How far to travel into a nested pointer structure during a deep copy; when this limit is exhausted the copy
 * operation will throw an error.
 */
exports.POINTER_COPY_LIMIT = 32;
/** A bitmask for looking up the double-far flag on a far pointer. */
exports.POINTER_DOUBLE_FAR_MASK = 0x00000004;
/** A bitmask for looking up the pointer type. */
exports.POINTER_TYPE_MASK = 0x00000003;
/** Used for some 64-bit conversions, equal to Math.pow(2, 32). */
exports.VAL32 = 0x100000000;
/** The maximum value allowed for depth traversal limits. */
exports.MAX_DEPTH = exports.MAX_INT32;
/** The maximum byte length for a single segment. */
exports.MAX_SEGMENT_LENGTH = exports.MAX_UINT32;

//# sourceMappingURL=constants.js.map


/***/ }),

/***/ "./node_modules/capnp-ts/lib/errors.js":
/*!*********************************************!*\
  !*** ./node_modules/capnp-ts/lib/errors.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * This file contains all the error strings used in the library. Also contains silliness.
 *
 * @author jdiaz5513
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var debug_1 = __webpack_require__(/*! debug */ "./node_modules/capnp-ts/node_modules/debug/src/browser.js");
var constants_1 = __webpack_require__(/*! ./constants */ "./node_modules/capnp-ts/lib/constants.js");
var trace = debug_1.default("capnp:errors");
trace("load");
// Invariant violations (sometimes known as "precondition failed").
//
// All right, hold up the brakes. This is a serious 1 === 0 WHAT THE FAILURE moment here. Tell the SO's you won't be
// home for dinner.
exports.INVARIANT_UNREACHABLE_CODE = "CAPNP-TS000 Unreachable code detected.";
function assertNever(n) {
    throw new Error(exports.INVARIANT_UNREACHABLE_CODE + (" (never block hit with: " + n + ")"));
}
exports.assertNever = assertNever;
// Message errors.
//
// Now who told you it would be a good idea to fuzz the inputs? You just made the program sad.
exports.MSG_INVALID_FRAME_HEADER = "CAPNP-TS001 Attempted to parse an invalid message frame header; are you sure this is a Cap'n Proto message?";
exports.MSG_NO_SEGMENTS_IN_ARENA = "CAPNP-TS002 Attempted to preallocate a message with no segments in the arena.";
exports.MSG_PACK_NOT_WORD_ALIGNED = "CAPNP-TS003 Attempted to pack a message that was not word-aligned.";
exports.MSG_SEGMENT_OUT_OF_BOUNDS = "CAPNP-TS004 Segment ID %X is out of bounds for message %s.";
exports.MSG_SEGMENT_TOO_SMALL = "CAPNP-TS005 First segment must have at least enough room to hold the root pointer (8 bytes).";
// Used for methods that are not yet implemented.
//
// My bad. I'll get to it. Eventually.
exports.NOT_IMPLEMENTED = "CAPNP-TS006 %s is not implemented.";
// Pointer-related errors.
//
// Look, this is probably the hardest part of the code. Cut some slack here! You probably found a bug.
exports.PTR_ADOPT_COMPOSITE_STRUCT = "CAPNP-TS007 Attempted to adopt a struct into a composite list (%s).";
exports.PTR_ADOPT_WRONG_MESSAGE = "CAPNP-TS008 Attempted to adopt %s into a pointer in a different message %s.";
exports.PTR_ALREADY_ADOPTED = "CAPNP-TS009 Attempted to adopt %s more than once.";
exports.PTR_COMPOSITE_SIZE_UNDEFINED = "CAPNP-TS010 Attempted to set a composite list without providing a composite element size.";
exports.PTR_DEPTH_LIMIT_EXCEEDED = "CAPNP-TS011 Nesting depth limit exceeded for %s.";
exports.PTR_DISOWN_COMPOSITE_STRUCT = "CAPNP-TS012 Attempted to disown a struct member from a composite list (%s).";
exports.PTR_INIT_COMPOSITE_STRUCT = "CAPNP-TS013 Attempted to initialize a struct member from a composite list (%s).";
exports.PTR_INIT_NON_GROUP = "CAPNP-TS014 Attempted to initialize a group field with a non-group struct class.";
exports.PTR_INVALID_FAR_TARGET = "CAPNP-TS015 Target of a far pointer (%s) is another far pointer.";
exports.PTR_INVALID_LIST_SIZE = "CAPNP-TS016 Invalid list element size: %x.";
exports.PTR_INVALID_POINTER_TYPE = "CAPNP-TS017 Invalid pointer type: %x.";
exports.PTR_INVALID_UNION_ACCESS = "CAPNP-TS018 Attempted to access getter on %s for union field %s that is not currently set (wanted: %d, found: %d).";
exports.PTR_OFFSET_OUT_OF_BOUNDS = "CAPNP-TS019 Pointer offset %a is out of bounds for underlying buffer.";
exports.PTR_STRUCT_DATA_OUT_OF_BOUNDS = "CAPNP-TS020 Attempted to access out-of-bounds struct data (struct: %s, %d bytes at %a, data words: %d).";
exports.PTR_STRUCT_POINTER_OUT_OF_BOUNDS = "CAPNP-TS021 Attempted to access out-of-bounds struct pointer (%s, index: %d, length: %d).";
exports.PTR_TRAVERSAL_LIMIT_EXCEEDED = "CAPNP-TS022 Traversal limit exceeded! Slow down! %s";
exports.PTR_WRONG_LIST_TYPE = "CAPNP-TS023 Cannot convert %s to a %s list.";
exports.PTR_WRONG_POINTER_TYPE = "CAPNP-TS024 Attempted to convert pointer %s to a %s type.";
exports.PTR_WRONG_COMPOSITE_DATA_SIZE = "CAPNP-TS025 Attempted to convert %s to a composite list with the wrong data size (found: %d).";
exports.PTR_WRONG_COMPOSITE_PTR_SIZE = "CAPNP-TS026 Attempted to convert %s to a composite list with the wrong pointer size (found: %d).";
exports.PTR_WRONG_STRUCT_DATA_SIZE = "CAPNP-TS027 Attempted to convert %s to a struct with the wrong data size (found: %d).";
exports.PTR_WRONG_STRUCT_PTR_SIZE = "CAPNP-TS028 Attempted to convert %s to a struct with the wrong pointer size (found: %d).";
// Custom error messages for the built-in `RangeError` class.
//
// You don't get a witty comment with these.
exports.RANGE_INT32_OVERFLOW = "CAPNP-TS029 32-bit signed integer overflow detected.";
exports.RANGE_INT64_UNDERFLOW = "CAPNP-TS030 Buffer is not large enough to hold a word.";
exports.RANGE_INVALID_UTF8 = "CAPNP-TS031 Invalid UTF-8 code sequence detected.";
exports.RANGE_SIZE_OVERFLOW = "CAPNP-TS032 Size %x exceeds maximum " + constants_1.MAX_SEGMENT_LENGTH.toString(16) + ".";
exports.RANGE_UINT32_OVERFLOW = "CAPNP-TS033 32-bit unsigned integer overflow detected.";
// Segment-related errors.
//
// These suck. Deal with it.
exports.SEG_BUFFER_NOT_ALLOCATED = "CAPNP-TS034 allocate() needs to be called at least once before getting a buffer.";
exports.SEG_GET_NON_ZERO_SINGLE = "CAPNP-TS035 Attempted to get a segment other than 0 (%d) from a single segment arena.";
exports.SEG_ID_OUT_OF_BOUNDS = "CAPNP-TS036 Attempted to get an out-of-bounds segment (%d).";
exports.SEG_NOT_WORD_ALIGNED = "CAPNP-TS037 Segment buffer length %d is not a multiple of 8.";
exports.SEG_REPLACEMENT_BUFFER_TOO_SMALL = "CAPNP-TS038 Attempted to replace a segment buffer with one that is smaller than the allocated space.";
exports.SEG_SIZE_OVERFLOW = "CAPNP-TS039 Requested size %x exceeds maximum value (" + constants_1.MAX_SEGMENT_LENGTH + ").";
// Custom error messages for the built-in `TypeError` class.
//
// If it looks like a duck, quacks like an elephant, and has hooves for feet, it's probably JavaScript.
exports.TYPE_COMPOSITE_SIZE_UNDEFINED = "CAPNP-TS040 Must provide a composite element size for composite list pointers.";
exports.TYPE_GET_GENERIC_LIST = "CAPNP-TS041 Attempted to call get() on a generic list.";
exports.TYPE_SET_GENERIC_LIST = "CAPNP-TS042 Attempted to call set() on a generic list.";
exports.PTR_WRITE_CONST_LIST = "CAPNP-TS043 Attempted to write to a const list.";
exports.PTR_WRITE_CONST_STRUCT = "CAPNP-TS044 Attempted to write to a const struct.";

//# sourceMappingURL=errors.js.map


/***/ }),

/***/ "./node_modules/capnp-ts/lib/index.js":
/*!********************************************!*\
  !*** ./node_modules/capnp-ts/lib/index.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @author jdiaz5513
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var serialization_1 = __webpack_require__(/*! ./serialization */ "./node_modules/capnp-ts/lib/serialization/index.js");
exports.ListElementSize = serialization_1.ListElementSize;
exports.Message = serialization_1.Message;
exports.ObjectSize = serialization_1.ObjectSize;
exports.readRawPointer = serialization_1.readRawPointer;
exports.AnyPointerList = serialization_1.AnyPointerList;
exports.BoolList = serialization_1.BoolList;
exports.CompositeList = serialization_1.CompositeList;
exports.Data = serialization_1.Data;
exports.DataList = serialization_1.DataList;
exports.Float32List = serialization_1.Float32List;
exports.Float64List = serialization_1.Float64List;
exports.Int16List = serialization_1.Int16List;
exports.Int32List = serialization_1.Int32List;
exports.Int64List = serialization_1.Int64List;
exports.Int8List = serialization_1.Int8List;
exports.Interface = serialization_1.Interface;
exports.InterfaceList = serialization_1.InterfaceList;
exports.List = serialization_1.List;
exports.Orphan = serialization_1.Orphan;
exports.PointerList = serialization_1.PointerList;
exports.PointerType = serialization_1.PointerType;
exports.Pointer = serialization_1.Pointer;
exports.Struct = serialization_1.Struct;
exports.Text = serialization_1.Text;
exports.TextList = serialization_1.TextList;
exports.Uint16List = serialization_1.Uint16List;
exports.Uint32List = serialization_1.Uint32List;
exports.Uint64List = serialization_1.Uint64List;
exports.Uint8List = serialization_1.Uint8List;
exports.VoidList = serialization_1.VoidList;
exports.Void = serialization_1.Void;
exports.getBitMask = serialization_1.getBitMask;
exports.getFloat32Mask = serialization_1.getFloat32Mask;
exports.getFloat64Mask = serialization_1.getFloat64Mask;
exports.getInt16Mask = serialization_1.getInt16Mask;
exports.getInt32Mask = serialization_1.getInt32Mask;
exports.getInt64Mask = serialization_1.getInt64Mask;
exports.getInt8Mask = serialization_1.getInt8Mask;
exports.getUint16Mask = serialization_1.getUint16Mask;
exports.getUint32Mask = serialization_1.getUint32Mask;
exports.getUint64Mask = serialization_1.getUint64Mask;
exports.getUint8Mask = serialization_1.getUint8Mask;
var types_1 = __webpack_require__(/*! ./types */ "./node_modules/capnp-ts/lib/types/index.js");
exports.Int64 = types_1.Int64;
exports.Uint64 = types_1.Uint64;

//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/capnp-ts/lib/serialization/arena/arena-allocation-result.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/capnp-ts/lib/serialization/arena/arena-allocation-result.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @author jdiaz5513
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var debug_1 = __webpack_require__(/*! debug */ "./node_modules/capnp-ts/node_modules/debug/src/browser.js");
var trace = debug_1.default("capnp:serialization:arena:arena-allocation-result");
trace("load");
var ArenaAllocationResult = /** @class */ (function () {
    function ArenaAllocationResult(id, buffer) {
        this.id = id;
        this.buffer = buffer;
        trace("new", this);
    }
    return ArenaAllocationResult;
}());
exports.ArenaAllocationResult = ArenaAllocationResult;

//# sourceMappingURL=arena-allocation-result.js.map


/***/ }),

/***/ "./node_modules/capnp-ts/lib/serialization/arena/arena-kind.js":
/*!*********************************************************************!*\
  !*** ./node_modules/capnp-ts/lib/serialization/arena/arena-kind.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var ArenaKind;
(function (ArenaKind) {
    ArenaKind[ArenaKind["SINGLE_SEGMENT"] = 0] = "SINGLE_SEGMENT";
    ArenaKind[ArenaKind["MULTI_SEGMENT"] = 1] = "MULTI_SEGMENT";
})(ArenaKind = exports.ArenaKind || (exports.ArenaKind = {}));

//# sourceMappingURL=arena-kind.js.map


/***/ }),

/***/ "./node_modules/capnp-ts/lib/serialization/arena/arena.js":
/*!****************************************************************!*\
  !*** ./node_modules/capnp-ts/lib/serialization/arena/arena.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @author jdiaz5513
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var debug_1 = __webpack_require__(/*! debug */ "./node_modules/capnp-ts/node_modules/debug/src/browser.js");
var errors_1 = __webpack_require__(/*! ../../errors */ "./node_modules/capnp-ts/lib/errors.js");
var arena_kind_1 = __webpack_require__(/*! ./arena-kind */ "./node_modules/capnp-ts/lib/serialization/arena/arena-kind.js");
var multi_segment_arena_1 = __webpack_require__(/*! ./multi-segment-arena */ "./node_modules/capnp-ts/lib/serialization/arena/multi-segment-arena.js");
var single_segment_arena_1 = __webpack_require__(/*! ./single-segment-arena */ "./node_modules/capnp-ts/lib/serialization/arena/single-segment-arena.js");
var trace = debug_1.default("capnp:arena");
trace("load");
var Arena = /** @class */ (function () {
    function Arena() {
    }
    Arena.allocate = allocate;
    Arena.getBuffer = getBuffer;
    Arena.getNumSegments = getNumSegments;
    return Arena;
}());
exports.Arena = Arena;
function allocate(minSize, segments, a) {
    switch (a.kind) {
        case arena_kind_1.ArenaKind.MULTI_SEGMENT:
            return multi_segment_arena_1.MultiSegmentArena.allocate(minSize, a);
        case arena_kind_1.ArenaKind.SINGLE_SEGMENT:
            return single_segment_arena_1.SingleSegmentArena.allocate(minSize, segments, a);
        default:
            return errors_1.assertNever(a);
    }
}
exports.allocate = allocate;
function getBuffer(id, a) {
    switch (a.kind) {
        case arena_kind_1.ArenaKind.MULTI_SEGMENT:
            return multi_segment_arena_1.MultiSegmentArena.getBuffer(id, a);
        case arena_kind_1.ArenaKind.SINGLE_SEGMENT:
            return single_segment_arena_1.SingleSegmentArena.getBuffer(id, a);
        default:
            return errors_1.assertNever(a);
    }
}
exports.getBuffer = getBuffer;
function getNumSegments(a) {
    switch (a.kind) {
        case arena_kind_1.ArenaKind.MULTI_SEGMENT:
            return multi_segment_arena_1.MultiSegmentArena.getNumSegments(a);
        case arena_kind_1.ArenaKind.SINGLE_SEGMENT:
            return single_segment_arena_1.SingleSegmentArena.getNumSegments();
        default:
            return errors_1.assertNever(a);
    }
}
exports.getNumSegments = getNumSegments;

//# sourceMappingURL=arena.js.map


/***/ }),

/***/ "./node_modules/capnp-ts/lib/serialization/arena/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/capnp-ts/lib/serialization/arena/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @author jdiaz5513
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var arena_1 = __webpack_require__(/*! ./arena */ "./node_modules/capnp-ts/lib/serialization/arena/arena.js");
exports.Arena = arena_1.Arena;
var arena_kind_1 = __webpack_require__(/*! ./arena-kind */ "./node_modules/capnp-ts/lib/serialization/arena/arena-kind.js");
exports.ArenaKind = arena_kind_1.ArenaKind;
var multi_segment_arena_1 = __webpack_require__(/*! ./multi-segment-arena */ "./node_modules/capnp-ts/lib/serialization/arena/multi-segment-arena.js");
exports.MultiSegmentArena = multi_segment_arena_1.MultiSegmentArena;
var single_segment_arena_1 = __webpack_require__(/*! ./single-segment-arena */ "./node_modules/capnp-ts/lib/serialization/arena/single-segment-arena.js");
exports.SingleSegmentArena = single_segment_arena_1.SingleSegmentArena;

//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/capnp-ts/lib/serialization/arena/multi-segment-arena.js":
/*!******************************************************************************!*\
  !*** ./node_modules/capnp-ts/lib/serialization/arena/multi-segment-arena.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @author jdiaz5513
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var debug_1 = __webpack_require__(/*! debug */ "./node_modules/capnp-ts/node_modules/debug/src/browser.js");
var constants_1 = __webpack_require__(/*! ../../constants */ "./node_modules/capnp-ts/lib/constants.js");
var errors_1 = __webpack_require__(/*! ../../errors */ "./node_modules/capnp-ts/lib/errors.js");
var util_1 = __webpack_require__(/*! ../../util */ "./node_modules/capnp-ts/lib/util.js");
var arena_allocation_result_1 = __webpack_require__(/*! ./arena-allocation-result */ "./node_modules/capnp-ts/lib/serialization/arena/arena-allocation-result.js");
var arena_kind_1 = __webpack_require__(/*! ./arena-kind */ "./node_modules/capnp-ts/lib/serialization/arena/arena-kind.js");
var trace = debug_1.default("capnp:arena:multi");
trace("load");
var MultiSegmentArena = /** @class */ (function () {
    function MultiSegmentArena(buffers) {
        if (buffers === void 0) { buffers = []; }
        this.kind = arena_kind_1.ArenaKind.MULTI_SEGMENT;
        this.buffers = buffers;
        trace("new %s", this);
    }
    MultiSegmentArena.prototype.toString = function () {
        return util_1.format("MultiSegmentArena_segments:%d", getNumSegments(this));
    };
    MultiSegmentArena.allocate = allocate;
    MultiSegmentArena.getBuffer = getBuffer;
    MultiSegmentArena.getNumSegments = getNumSegments;
    return MultiSegmentArena;
}());
exports.MultiSegmentArena = MultiSegmentArena;
function allocate(minSize, m) {
    var b = new ArrayBuffer(util_1.padToWord(Math.max(minSize, constants_1.DEFAULT_BUFFER_SIZE)));
    m.buffers.push(b);
    return new arena_allocation_result_1.ArenaAllocationResult(m.buffers.length - 1, b);
}
exports.allocate = allocate;
function getBuffer(id, m) {
    if (id < 0 || id >= m.buffers.length) {
        throw new Error(util_1.format(errors_1.SEG_ID_OUT_OF_BOUNDS, id));
    }
    return m.buffers[id];
}
exports.getBuffer = getBuffer;
function getNumSegments(m) {
    return m.buffers.length;
}
exports.getNumSegments = getNumSegments;

//# sourceMappingURL=multi-segment-arena.js.map


/***/ }),

/***/ "./node_modules/capnp-ts/lib/serialization/arena/single-segment-arena.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/capnp-ts/lib/serialization/arena/single-segment-arena.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @author jdiaz5513
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var debug_1 = __webpack_require__(/*! debug */ "./node_modules/capnp-ts/node_modules/debug/src/browser.js");
var constants_1 = __webpack_require__(/*! ../../constants */ "./node_modules/capnp-ts/lib/constants.js");
var errors_1 = __webpack_require__(/*! ../../errors */ "./node_modules/capnp-ts/lib/errors.js");
var util_1 = __webpack_require__(/*! ../../util */ "./node_modules/capnp-ts/lib/util.js");
var arena_allocation_result_1 = __webpack_require__(/*! ./arena-allocation-result */ "./node_modules/capnp-ts/lib/serialization/arena/arena-allocation-result.js");
var arena_kind_1 = __webpack_require__(/*! ./arena-kind */ "./node_modules/capnp-ts/lib/serialization/arena/arena-kind.js");
var trace = debug_1.default("capnp:arena:single");
trace("load");
var SingleSegmentArena = /** @class */ (function () {
    function SingleSegmentArena(buffer) {
        if (buffer === void 0) { buffer = new ArrayBuffer(constants_1.DEFAULT_BUFFER_SIZE); }
        this.kind = arena_kind_1.ArenaKind.SINGLE_SEGMENT;
        if ((buffer.byteLength & 7) !== 0) {
            throw new Error(util_1.format(errors_1.SEG_NOT_WORD_ALIGNED, buffer.byteLength));
        }
        this.buffer = buffer;
        trace("new %s", this);
    }
    SingleSegmentArena.prototype.toString = function () {
        return util_1.format("SingleSegmentArena_len:%x", this.buffer.byteLength);
    };
    SingleSegmentArena.allocate = allocate;
    SingleSegmentArena.getBuffer = getBuffer;
    SingleSegmentArena.getNumSegments = getNumSegments;
    return SingleSegmentArena;
}());
exports.SingleSegmentArena = SingleSegmentArena;
function allocate(minSize, segments, s) {
    trace("Allocating %x bytes for segment 0 in %s.", minSize, s);
    var srcBuffer = segments.length > 0 ? segments[0].buffer : s.buffer;
    if (minSize < constants_1.MIN_SINGLE_SEGMENT_GROWTH) {
        minSize = constants_1.MIN_SINGLE_SEGMENT_GROWTH;
    }
    else {
        minSize = util_1.padToWord(minSize);
    }
    s.buffer = new ArrayBuffer(srcBuffer.byteLength + minSize);
    // PERF: Assume that the source and destination buffers are word-aligned and use Float64Array to copy them one word
    // at a time.
    new Float64Array(s.buffer).set(new Float64Array(srcBuffer));
    return new arena_allocation_result_1.ArenaAllocationResult(0, s.buffer);
}
exports.allocate = allocate;
function getBuffer(id, s) {
    if (id !== 0)
        throw new Error(util_1.format(errors_1.SEG_GET_NON_ZERO_SINGLE, id));
    return s.buffer;
}
exports.getBuffer = getBuffer;
function getNumSegments() {
    return 1;
}
exports.getNumSegments = getNumSegments;

//# sourceMappingURL=single-segment-arena.js.map


/***/ }),

/***/ "./node_modules/capnp-ts/lib/serialization/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/capnp-ts/lib/serialization/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @author jdiaz5513
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
tslib_1.__exportStar(__webpack_require__(/*! ./mask */ "./node_modules/capnp-ts/lib/serialization/mask.js"), exports);
var list_element_size_1 = __webpack_require__(/*! ./list-element-size */ "./node_modules/capnp-ts/lib/serialization/list-element-size.js");
exports.ListElementSize = list_element_size_1.ListElementSize;
var message_1 = __webpack_require__(/*! ./message */ "./node_modules/capnp-ts/lib/serialization/message.js");
exports.Message = message_1.Message;
exports.readRawPointer = message_1.readRawPointer;
var object_size_1 = __webpack_require__(/*! ./object-size */ "./node_modules/capnp-ts/lib/serialization/object-size.js");
exports.ObjectSize = object_size_1.ObjectSize;
tslib_1.__exportStar(__webpack_require__(/*! ./pointers */ "./node_modules/capnp-ts/lib/serialization/pointers/index.js"), exports);

//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/capnp-ts/lib/serialization/list-element-size.js":
/*!**********************************************************************!*\
  !*** ./node_modules/capnp-ts/lib/serialization/list-element-size.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * @author jdiaz5513
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var ListElementSize;
(function (ListElementSize) {
    ListElementSize[ListElementSize["VOID"] = 0] = "VOID";
    ListElementSize[ListElementSize["BIT"] = 1] = "BIT";
    ListElementSize[ListElementSize["BYTE"] = 2] = "BYTE";
    ListElementSize[ListElementSize["BYTE_2"] = 3] = "BYTE_2";
    ListElementSize[ListElementSize["BYTE_4"] = 4] = "BYTE_4";
    ListElementSize[ListElementSize["BYTE_8"] = 5] = "BYTE_8";
    ListElementSize[ListElementSize["POINTER"] = 6] = "POINTER";
    ListElementSize[ListElementSize["COMPOSITE"] = 7] = "COMPOSITE";
})(ListElementSize = exports.ListElementSize || (exports.ListElementSize = {}));
exports.ListElementOffset = [
    0,
    0.125,
    1,
    2,
    4,
    8,
    8,
    NaN // composite
];

//# sourceMappingURL=list-element-size.js.map


/***/ }),

/***/ "./node_modules/capnp-ts/lib/serialization/mask.js":
/*!*********************************************************!*\
  !*** ./node_modules/capnp-ts/lib/serialization/mask.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * @author jdiaz5513
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
function _makePrimitiveMaskFn(byteLength, setter) {
    return function (x) {
        var dv = new DataView(new ArrayBuffer(byteLength));
        setter.call(dv, 0, x, true);
        return dv;
    };
}
/* tslint:disable:no-unsafe-any */
exports.getFloat32Mask = _makePrimitiveMaskFn(4, DataView.prototype.setFloat32);
exports.getFloat64Mask = _makePrimitiveMaskFn(8, DataView.prototype.setFloat64);
exports.getInt16Mask = _makePrimitiveMaskFn(2, DataView.prototype.setInt16);
exports.getInt32Mask = _makePrimitiveMaskFn(4, DataView.prototype.setInt32);
exports.getInt8Mask = _makePrimitiveMaskFn(1, DataView.prototype.setInt8);
exports.getUint16Mask = _makePrimitiveMaskFn(2, DataView.prototype.setUint16);
exports.getUint32Mask = _makePrimitiveMaskFn(4, DataView.prototype.setUint32);
exports.getUint8Mask = _makePrimitiveMaskFn(1, DataView.prototype.setUint8);
/* tslint:enable:no-unsafe-any */
function getBitMask(value, bitOffset) {
    var dv = new DataView(new ArrayBuffer(1));
    if (!value)
        return dv;
    dv.setUint8(0, 1 << bitOffset % 8);
    return dv;
}
exports.getBitMask = getBitMask;
function getInt64Mask(x) {
    return x.toDataView();
}
exports.getInt64Mask = getInt64Mask;
function getUint64Mask(x) {
    return x.toDataView();
}
exports.getUint64Mask = getUint64Mask;

//# sourceMappingURL=mask.js.map


/***/ }),

/***/ "./node_modules/capnp-ts/lib/serialization/message.js":
/*!************************************************************!*\
  !*** ./node_modules/capnp-ts/lib/serialization/message.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @author jdiaz5513
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var debug_1 = __webpack_require__(/*! debug */ "./node_modules/capnp-ts/node_modules/debug/src/browser.js");
var constants_1 = __webpack_require__(/*! ../constants */ "./node_modules/capnp-ts/lib/constants.js");
var errors_1 = __webpack_require__(/*! ../errors */ "./node_modules/capnp-ts/lib/errors.js");
var util_1 = __webpack_require__(/*! ../util */ "./node_modules/capnp-ts/lib/util.js");
var arena_1 = __webpack_require__(/*! ./arena */ "./node_modules/capnp-ts/lib/serialization/arena/index.js");
var packing_1 = __webpack_require__(/*! ./packing */ "./node_modules/capnp-ts/lib/serialization/packing.js");
var pointers_1 = __webpack_require__(/*! ./pointers */ "./node_modules/capnp-ts/lib/serialization/pointers/index.js");
var segment_1 = __webpack_require__(/*! ./segment */ "./node_modules/capnp-ts/lib/serialization/segment.js");
var pointer_1 = __webpack_require__(/*! ./pointers/pointer */ "./node_modules/capnp-ts/lib/serialization/pointers/pointer.js");
var struct_1 = __webpack_require__(/*! ./pointers/struct */ "./node_modules/capnp-ts/lib/serialization/pointers/struct.js");
var trace = debug_1.default("capnp:message");
trace("load");
var Message = /** @class */ (function () {
    /**
     * A Cap'n Proto message.
     *
     * SECURITY WARNING: In nodejs do not pass a Buffer's internal array buffer into this constructor. Pass the buffer
     * directly and everything will be fine. If not, your message will potentially be initialized with random memory
     * contents!
     *
     * The constructor method creates a new Message, optionally using a provided arena for segment allocation, or a buffer
     * to read from.
     *
     * @constructor {Message}
     *
     * @param {AnyArena|ArrayBufferView|ArrayBuffer} [src] The source for the message.
     * A value of `undefined` will cause the message to initialize with a single segment arena only big enough for the
     * root pointer; it will expand as you go. This is a reasonable choice for most messages.
     *
     * Passing an arena will cause the message to use that arena for its segment allocation. Contents will be accepted
     * as-is.
     *
     * Passing an array buffer view (like `DataView`, `Uint8Array` or `Buffer`) will create a **copy** of the source
     * buffer; beware of the potential performance cost!
     *
     * @param {boolean} [packed] Whether or not the message is packed. If `true` (the default), the message will be
     * unpacked.
     *
     * @param {boolean} [singleSegment] If true, `src` will be treated as a message consisting of a single segment without
     * a framing header.
     *
     */
    function Message(src, packed, singleSegment) {
        if (packed === void 0) { packed = true; }
        if (singleSegment === void 0) { singleSegment = false; }
        this._capnp = initMessage(src, packed, singleSegment);
        if (src && !isAnyArena(src))
            preallocateSegments(this);
        trace("new %s", this);
    }
    Message.prototype.allocateSegment = function (byteLength) {
        return allocateSegment(byteLength, this);
    };
    /**
     * Create a pretty-printed string dump of this message; incredibly useful for debugging.
     *
     * WARNING: Do not call this method on large messages!
     *
     * @returns {string} A big steaming pile of pretty hex digits.
     */
    Message.prototype.dump = function () {
        return dump(this);
    };
    /**
     * Get a struct pointer for the root of this message. This is primarily used when reading a message; it will not
     * overwrite existing data.
     *
     * @template T
     * @param {StructCtor<T>} RootStruct The struct type to use as the root.
     * @returns {T} A struct representing the root of the message.
     */
    Message.prototype.getRoot = function (RootStruct) {
        return getRoot(RootStruct, this);
    };
    /**
     * Get a segment by its id.
     *
     * This will lazily allocate the first segment if it doesn't already exist.
     *
     * @param {number} id The segment id.
     * @returns {Segment} The requested segment.
     */
    Message.prototype.getSegment = function (id) {
        return getSegment(id, this);
    };
    /**
     * Initialize a new message using the provided struct type as the root.
     *
     * @template T
     * @param {StructCtor<T>} RootStruct The struct type to use as the root.
     * @returns {T} An initialized struct pointing to the root of the message.
     */
    Message.prototype.initRoot = function (RootStruct) {
        return initRoot(RootStruct, this);
    };
    /**
     * Set the root of the message to a copy of the given pointer. Used internally
     * to make copies of pointers for default values.
     *
     * @param {Pointer} src The source pointer to copy.
     * @returns {void}
     */
    Message.prototype.setRoot = function (src) {
        setRoot(src, this);
    };
    /**
     * Combine the contents of this message's segments into a single array buffer and prepend a stream framing header
     * containing information about the following segment data.
     *
     * @returns {ArrayBuffer} An ArrayBuffer with the contents of this message.
     */
    Message.prototype.toArrayBuffer = function () {
        return toArrayBuffer(this);
    };
    /**
     * Like `toArrayBuffer()`, but also applies the packing algorithm to the output. This is typically what you want to
     * use if you're sending the message over a network link or other slow I/O interface where size matters.
     *
     * @returns {ArrayBuffer} A packed message.
     */
    Message.prototype.toPackedArrayBuffer = function () {
        return toPackedArrayBuffer(this);
    };
    Message.prototype.toString = function () {
        return "Message_arena:" + this._capnp.arena;
    };
    Message.allocateSegment = allocateSegment;
    Message.dump = dump;
    Message.getRoot = getRoot;
    Message.getSegment = getSegment;
    Message.initRoot = initRoot;
    Message.readRawPointer = readRawPointer;
    Message.toArrayBuffer = toArrayBuffer;
    Message.toPackedArrayBuffer = toPackedArrayBuffer;
    return Message;
}());
exports.Message = Message;
function initMessage(src, packed, singleSegment) {
    if (packed === void 0) { packed = true; }
    if (singleSegment === void 0) { singleSegment = false; }
    if (src === undefined) {
        return {
            arena: new arena_1.SingleSegmentArena(),
            segments: [],
            traversalLimit: constants_1.DEFAULT_TRAVERSE_LIMIT
        };
    }
    if (isAnyArena(src)) {
        return { arena: src, segments: [], traversalLimit: constants_1.DEFAULT_TRAVERSE_LIMIT };
    }
    var buf = src;
    if (isArrayBufferView(buf)) {
        buf = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
    }
    if (packed)
        buf = packing_1.unpack(buf);
    if (singleSegment) {
        return {
            arena: new arena_1.SingleSegmentArena(buf),
            segments: [],
            traversalLimit: constants_1.DEFAULT_TRAVERSE_LIMIT
        };
    }
    return {
        arena: new arena_1.MultiSegmentArena(getFramedSegments(buf)),
        segments: [],
        traversalLimit: constants_1.DEFAULT_TRAVERSE_LIMIT
    };
}
exports.initMessage = initMessage;
/**
 * Given an _unpacked_ message with a segment framing header, this will generate an ArrayBuffer for each segment in
 * the message.
 *
 * This method is not typically called directly, but can be useful in certain cases.
 *
 * @static
 * @param {ArrayBuffer} message An unpacked message with a framing header.
 * @returns {ArrayBuffer[]} An array of buffers containing the segment data.
 */
function getFramedSegments(message) {
    var dv = new DataView(message);
    var segmentCount = dv.getUint32(0, true) + 1;
    var segments = new Array(segmentCount);
    trace("reading %d framed segments from stream", segmentCount);
    var byteOffset = 4 + segmentCount * 4;
    byteOffset += byteOffset % 8;
    if (byteOffset + segmentCount * 4 > message.byteLength) {
        throw new Error(errors_1.MSG_INVALID_FRAME_HEADER);
    }
    for (var i = 0; i < segmentCount; i++) {
        var byteLength = dv.getUint32(4 + i * 4, true) * 8;
        if (byteOffset + byteLength > message.byteLength) {
            throw new Error(errors_1.MSG_INVALID_FRAME_HEADER);
        }
        segments[i] = message.slice(byteOffset, byteOffset + byteLength);
        byteOffset += byteLength;
    }
    return segments;
}
exports.getFramedSegments = getFramedSegments;
/**
 * This method is called on messages that were constructed with existing data to prepopulate the segments array with
 * everything we can find in the arena. Each segment will have it's `byteLength` set to the size of its buffer.
 *
 * Technically speaking, the message's segments will be "full" after calling this function. Calling this on your own
 * may void your warranty.
 *
 * @param {Message} m The message to allocate.
 * @returns {void}
 */
function preallocateSegments(m) {
    var numSegments = arena_1.Arena.getNumSegments(m._capnp.arena);
    if (numSegments < 1)
        throw new Error(errors_1.MSG_NO_SEGMENTS_IN_ARENA);
    m._capnp.segments = new Array(numSegments);
    for (var i = 0; i < numSegments; i++) {
        // Set up each segment so that they're fully allocated to the extents of the existing buffers.
        var buffer = arena_1.Arena.getBuffer(i, m._capnp.arena);
        var segment = new segment_1.Segment(i, m, buffer, buffer.byteLength);
        m._capnp.segments[i] = segment;
    }
}
exports.preallocateSegments = preallocateSegments;
function isArrayBufferView(src) {
    return src.byteOffset !== undefined;
}
function isAnyArena(o) {
    return o.kind !== undefined;
}
function allocateSegment(byteLength, m) {
    trace("allocating %x bytes for %s", byteLength, m);
    var res = arena_1.Arena.allocate(byteLength, m._capnp.segments, m._capnp.arena);
    var s;
    if (res.id === m._capnp.segments.length) {
        // Note how we're only allowing new segments in if they're exactly the next one in the array. There is no logical
        // reason for segments to be created out of order.
        s = new segment_1.Segment(res.id, m, res.buffer);
        trace("adding new segment %s", s);
        m._capnp.segments.push(s);
    }
    else if (res.id < 0 || res.id > m._capnp.segments.length) {
        throw new Error(util_1.format(errors_1.MSG_SEGMENT_OUT_OF_BOUNDS, res.id, m));
    }
    else {
        s = m._capnp.segments[res.id];
        trace("replacing segment %s with buffer (len:%d)", s, res.buffer.byteLength);
        s.replaceBuffer(res.buffer);
    }
    return s;
}
exports.allocateSegment = allocateSegment;
function dump(m) {
    var r = "";
    if (m._capnp.segments.length === 0) {
        return "================\nNo Segments\n================\n";
    }
    for (var i = 0; i < m._capnp.segments.length; i++) {
        r += "================\nSegment #" + i + "\n================\n";
        var _a = m._capnp.segments[i], buffer = _a.buffer, byteLength = _a.byteLength;
        var b = new Uint8Array(buffer, 0, byteLength);
        r += util_1.dumpBuffer(b);
    }
    return r;
}
exports.dump = dump;
function getRoot(RootStruct, m) {
    var root = new RootStruct(m.getSegment(0), 0);
    pointer_1.validate(pointers_1.PointerType.STRUCT, root);
    var ts = pointer_1.getTargetStructSize(root);
    // Make sure the underlying pointer is actually big enough to hold the data and pointers as specified in the schema.
    // If not a shallow copy of the struct contents needs to be made before returning.
    if (ts.dataByteLength < RootStruct._capnp.size.dataByteLength ||
        ts.pointerLength < RootStruct._capnp.size.pointerLength) {
        trace("need to resize root struct %s", root);
        struct_1.resize(RootStruct._capnp.size, root);
    }
    return root;
}
exports.getRoot = getRoot;
function getSegment(id, m) {
    var segmentLength = m._capnp.segments.length;
    if (id === 0 && segmentLength === 0) {
        // Segment zero is special. If we have no segments in the arena we'll want to allocate a new one and leave room
        // for the root pointer.
        var arenaSegments = arena_1.Arena.getNumSegments(m._capnp.arena);
        if (arenaSegments === 0) {
            allocateSegment(constants_1.DEFAULT_BUFFER_SIZE, m);
        }
        else {
            // Okay, the arena already has a buffer we can use. This is totally fine.
            m._capnp.segments[0] = new segment_1.Segment(0, m, arena_1.Arena.getBuffer(0, m._capnp.arena));
        }
        if (!m._capnp.segments[0].hasCapacity(8)) {
            throw new Error(errors_1.MSG_SEGMENT_TOO_SMALL);
        }
        // This will leave room for the root pointer.
        m._capnp.segments[0].allocate(8);
        return m._capnp.segments[0];
    }
    if (id < 0 || id >= segmentLength) {
        throw new Error(util_1.format(errors_1.MSG_SEGMENT_OUT_OF_BOUNDS, id, m));
    }
    return m._capnp.segments[id];
}
exports.getSegment = getSegment;
function initRoot(RootStruct, m) {
    var root = new RootStruct(m.getSegment(0), 0);
    struct_1.initStruct(RootStruct._capnp.size, root);
    trace("Initialized root pointer %s for %s.", root, m);
    return root;
}
exports.initRoot = initRoot;
/**
 * Read a pointer in raw form (a packed message with framing headers). Does not
 * care or attempt to validate the input beyond parsing the message
 * segments.
 *
 * This is typically used by the compiler to load default values, but can be
 * useful to work with messages with an unknown schema.
 *
 * @param {ArrayBuffer} data The raw data to read.
 * @returns {Pointer} A root pointer.
 */
function readRawPointer(data) {
    return new pointers_1.Pointer(new Message(data).getSegment(0), 0);
}
exports.readRawPointer = readRawPointer;
function setRoot(src, m) {
    pointers_1.Pointer.copyFrom(src, new pointers_1.Pointer(m.getSegment(0), 0));
}
exports.setRoot = setRoot;
function toArrayBuffer(m) {
    var streamFrame = getStreamFrame(m);
    // Make sure the first segment is allocated.
    if (m._capnp.segments.length === 0)
        getSegment(0, m);
    var segments = m._capnp.segments;
    // Add space for the stream framing.
    var totalLength = streamFrame.byteLength +
        segments.reduce(function (l, s) { return l + util_1.padToWord(s.byteLength); }, 0);
    var out = new Uint8Array(new ArrayBuffer(totalLength));
    var o = streamFrame.byteLength;
    out.set(new Uint8Array(streamFrame));
    segments.forEach(function (s) {
        var segmentLength = util_1.padToWord(s.byteLength);
        out.set(new Uint8Array(s.buffer, 0, segmentLength), o);
        o += segmentLength;
    });
    return out.buffer;
}
exports.toArrayBuffer = toArrayBuffer;
function toPackedArrayBuffer(m) {
    var streamFrame = packing_1.pack(getStreamFrame(m));
    // Make sure the first segment is allocated.
    if (m._capnp.segments.length === 0)
        m.getSegment(0);
    // NOTE: A copy operation can be avoided here if we capture the intermediate array and use that directly in the copy
    // loop below, rather than have `pack()` copy it to an ArrayBuffer just to have to copy it again later. If the
    // intermediate array can be avoided altogether that's even better!
    var segments = m._capnp.segments.map(function (s) {
        return packing_1.pack(s.buffer, 0, util_1.padToWord(s.byteLength));
    });
    var totalLength = streamFrame.byteLength + segments.reduce(function (l, s) { return l + s.byteLength; }, 0);
    var out = new Uint8Array(new ArrayBuffer(totalLength));
    var o = streamFrame.byteLength;
    out.set(new Uint8Array(streamFrame));
    segments.forEach(function (s) {
        out.set(new Uint8Array(s), o);
        o += s.byteLength;
    });
    return out.buffer;
}
exports.toPackedArrayBuffer = toPackedArrayBuffer;
function getStreamFrame(m) {
    var length = m._capnp.segments.length;
    if (length === 0) {
        // Don't bother allocating the first segment, just return a single zero word for the frame header.
        return new Float64Array(1).buffer;
    }
    var frameLength = 4 + length * 4 + (1 - (length % 2)) * 4;
    var out = new DataView(new ArrayBuffer(frameLength));
    trace("Writing message stream frame with segment count: %d.", length);
    out.setUint32(0, length - 1, true);
    m._capnp.segments.forEach(function (s, i) {
        trace("Message segment %d word count: %d.", s.id, s.byteLength / 8);
        out.setUint32(i * 4 + 4, s.byteLength / 8, true);
    });
    return out.buffer;
}
exports.getStreamFrame = getStreamFrame;

//# sourceMappingURL=message.js.map


/***/ }),

/***/ "./node_modules/capnp-ts/lib/serialization/object-size.js":
/*!****************************************************************!*\
  !*** ./node_modules/capnp-ts/lib/serialization/object-size.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @author jdiaz5513
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var debug_1 = __webpack_require__(/*! debug */ "./node_modules/capnp-ts/node_modules/debug/src/browser.js");
var _ = __webpack_require__(/*! ../util */ "./node_modules/capnp-ts/lib/util.js");
var trace = debug_1.default("capnp:object-size");
trace("load");
/**
 * A simple object that describes the size of a struct.
 *
 * @export
 * @class ObjectSize
 */
var ObjectSize = /** @class */ (function () {
    function ObjectSize(dataByteLength, pointerCount) {
        this.dataByteLength = dataByteLength;
        this.pointerLength = pointerCount;
    }
    ObjectSize.prototype.toString = function () {
        return _.format("ObjectSize_dw:%d,pc:%d", getDataWordLength(this), this.pointerLength);
    };
    return ObjectSize;
}());
exports.ObjectSize = ObjectSize;
function getByteLength(o) {
    return o.dataByteLength + o.pointerLength * 8;
}
exports.getByteLength = getByteLength;
function getDataWordLength(o) {
    return o.dataByteLength / 8;
}
exports.getDataWordLength = getDataWordLength;
function getWordLength(o) {
    return o.dataByteLength / 8 + o.pointerLength;
}
exports.getWordLength = getWordLength;
function padToWord(o) {
    return new ObjectSize(_.padToWord(o.dataByteLength), o.pointerLength);
}
exports.padToWord = padToWord;

//# sourceMappingURL=object-size.js.map


/***/ }),

/***/ "./node_modules/capnp-ts/lib/serialization/packing.js":
/*!************************************************************!*\
  !*** ./node_modules/capnp-ts/lib/serialization/packing.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @author jdiaz5513
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var constants_1 = __webpack_require__(/*! ../constants */ "./node_modules/capnp-ts/lib/constants.js");
var errors_1 = __webpack_require__(/*! ../errors */ "./node_modules/capnp-ts/lib/errors.js");
/**
 * Compute the Hamming weight (number of bits set to 1) of a number. Used to figure out how many bytes follow a tag byte
 * while computing the size of a packed message.
 *
 * WARNING: Using this with floating point numbers will void your warranty.
 *
 * @param {number} x A real integer.
 * @returns {number} The hamming weight (integer).
 */
function getHammingWeight(x) {
    // Thanks, HACKMEM!
    var w = x - ((x >> 1) & 0x55555555);
    w = (w & 0x33333333) + ((w >> 2) & 0x33333333);
    return (((w + (w >> 4)) & 0x0f0f0f0f) * 0x01010101) >> 24;
}
exports.getHammingWeight = getHammingWeight;
/**
 * Compute the tag byte from the 8 bytes of a 64-bit word.
 *
 * @param {byte} a The first byte.
 * @param {byte} b The second byte.
 * @param {byte} c The third byte.
 * @param {byte} d The fourth byte.
 * @param {byte} e The fifth byte.
 * @param {byte} f The sixth byte.
 * @param {byte} g The seventh byte.
 * @param {byte} h The eighth byte (phew!).
 * @returns {number} The tag byte.
 */
function getTagByte(a, b, c, d, e, f, g, h) {
    // Yes, it's pretty. Don't touch it.
    return ((a === 0 ? 0 : 1) |
        (b === 0 ? 0 : 2) |
        (c === 0 ? 0 : 4) |
        (d === 0 ? 0 : 8) |
        (e === 0 ? 0 : 16) |
        (f === 0 ? 0 : 32) |
        (g === 0 ? 0 : 64) |
        (h === 0 ? 0 : 128));
}
exports.getTagByte = getTagByte;
/**
 * Efficiently calculate the length of a packed Cap'n Proto message.
 *
 * @export
 * @param {ArrayBuffer} packed The packed message.
 * @returns {number} The length of the unpacked message in bytes.
 */
function getUnpackedByteLength(packed) {
    var p = new Uint8Array(packed);
    var wordLength = 0;
    var lastTag = 0x77;
    for (var i = 0; i < p.byteLength;) {
        var tag = p[i];
        if (lastTag === 0 /* ZERO */) {
            wordLength += tag;
            i++;
            lastTag = 0x77;
        }
        else if (lastTag === 255 /* SPAN */) {
            wordLength += tag;
            i += tag * 8 + 1;
            lastTag = 0x77;
        }
        else {
            wordLength++;
            i += getHammingWeight(tag) + 1;
            lastTag = tag;
        }
    }
    return wordLength * 8;
}
exports.getUnpackedByteLength = getUnpackedByteLength;
/**
 * Compute the number of zero bytes that occur in a given 64-bit word, provided as eight separate bytes.
 *
 * @param {byte} a The first byte.
 * @param {byte} b The second byte.
 * @param {byte} c The third byte.
 * @param {byte} d The fourth byte.
 * @param {byte} e The fifth byte.
 * @param {byte} f The sixth byte.
 * @param {byte} g The seventh byte.
 * @param {byte} h The eighth byte (phew!).
 * @returns {number} The number of these bytes that are zero.
 */
function getZeroByteCount(a, b, c, d, e, f, g, h) {
    return ((a === 0 ? 1 : 0) +
        (b === 0 ? 1 : 0) +
        (c === 0 ? 1 : 0) +
        (d === 0 ? 1 : 0) +
        (e === 0 ? 1 : 0) +
        (f === 0 ? 1 : 0) +
        (g === 0 ? 1 : 0) +
        (h === 0 ? 1 : 0));
}
exports.getZeroByteCount = getZeroByteCount;
/**
 * Pack a section of a Cap'n Proto message into a compressed format. This will efficiently compress zero bytes (which
 * are common in idiomatic Cap'n Proto messages) into a compact form.
 *
 * For stream-framed messages this is called once for the frame header and once again for each segment in the message.
 *
 * The returned array buffer is trimmed to the exact size of the packed message with a single copy operation at the end.
 * This should be decent on CPU time but does require quite a lot of memory (a normal array is filled up with each
 * packed byte until the packing is complete).
 *
 * @export
 * @param {ArrayBuffer} unpacked The message to pack.
 * @param {number} [byteOffset] Starting byte offset to read bytes from, defaults to 0.
 * @param {number} [byteLength] Total number of bytes to read, defaults to the remainder of the buffer contents.
 * @returns {ArrayBuffer} A packed version of the message.
 */
function pack(unpacked, byteOffset, byteLength) {
    if (byteOffset === void 0) { byteOffset = 0; }
    if (unpacked.byteLength % 8 !== 0)
        throw new Error(errors_1.MSG_PACK_NOT_WORD_ALIGNED);
    var src = new Uint8Array(unpacked, byteOffset, byteLength);
    // TODO: Maybe we should do this with buffers? This costs more than 8x the final compressed size in temporary RAM.
    var dst = [];
    /* Just have to be sure it's neither ZERO nor SPAN. */
    var lastTag = 0x77;
    /** This is where we need to remember to write the SPAN tag (0xff). */
    var spanTagOffset = NaN;
    /** How many words have been copied during the current span. */
    var spanWordLength = 0;
    /**
     * When this hits zero, we've had PACK_SPAN_THRESHOLD zero bytes pass by and it's time to bail from the span.
     */
    var spanThreshold = constants_1.PACK_SPAN_THRESHOLD;
    for (var srcByteOffset = 0; srcByteOffset < src.byteLength; srcByteOffset += 8) {
        /** Read in the entire word. Yes, this feels silly but it's fast! */
        var a = src[srcByteOffset];
        var b = src[srcByteOffset + 1];
        var c = src[srcByteOffset + 2];
        var d = src[srcByteOffset + 3];
        var e = src[srcByteOffset + 4];
        var f = src[srcByteOffset + 5];
        var g = src[srcByteOffset + 6];
        var h = src[srcByteOffset + 7];
        var tag = getTagByte(a, b, c, d, e, f, g, h);
        /** If this is true we'll skip the normal word write logic after the switch statement. */
        var skipWriteWord = true;
        switch (lastTag) {
            case 0 /* ZERO */:
                // We're writing a span of words with all zeroes in them. See if we need to bail out of the fast path.
                if (tag !== 0 /* ZERO */ || spanWordLength >= 0xff) {
                    // There's a bit in there or we got too many zeroes. Damn, we need to bail.
                    dst.push(spanWordLength);
                    spanWordLength = 0;
                    skipWriteWord = false;
                }
                else {
                    // Kay, let's quickly inc this and go.
                    spanWordLength++;
                }
                break;
            case 255 /* SPAN */:
                // We're writing a span of nonzero words.
                var zeroCount = getZeroByteCount(a, b, c, d, e, f, g, h);
                // See if we need to bail now.
                spanThreshold -= zeroCount;
                if (spanThreshold <= 0 || spanWordLength >= 0xff) {
                    // Alright, time to get packing again. Write the number of words we skipped to the beginning of the span.
                    dst[spanTagOffset] = spanWordLength;
                    spanWordLength = 0;
                    spanThreshold = constants_1.PACK_SPAN_THRESHOLD;
                    // We have to write this word normally.
                    skipWriteWord = false;
                }
                else {
                    // Just write this word verbatim.
                    dst.push(a, b, c, d, e, f, g, h);
                    spanWordLength++;
                }
                break;
            default:
                // Didn't get a special tag last time, let's write this as normal.
                skipWriteWord = false;
                break;
        }
        // A goto is fast, idk why people keep hatin'.
        if (skipWriteWord)
            continue;
        dst.push(tag);
        lastTag = tag;
        if (a !== 0)
            dst.push(a);
        if (b !== 0)
            dst.push(b);
        if (c !== 0)
            dst.push(c);
        if (d !== 0)
            dst.push(d);
        if (e !== 0)
            dst.push(e);
        if (f !== 0)
            dst.push(f);
        if (g !== 0)
            dst.push(g);
        if (h !== 0)
            dst.push(h);
        // Record the span tag offset if needed, making sure to actually leave room for it.
        if (tag === 255 /* SPAN */) {
            spanTagOffset = dst.length;
            dst.push(0);
        }
    }
    // We're done. If we were writing a span let's finish it.
    if (lastTag === 0 /* ZERO */) {
        dst.push(spanWordLength);
    }
    else if (lastTag === 255 /* SPAN */) {
        dst[spanTagOffset] = spanWordLength;
    }
    return new Uint8Array(dst).buffer;
}
exports.pack = pack;
/**
 * Unpack a compressed Cap'n Proto message into a new ArrayBuffer.
 *
 * Unlike the `pack` function, this is able to efficiently determine the exact size needed for the output buffer and
 * runs considerably more efficiently.
 *
 * @export
 * @param {ArrayBuffer} packed An array buffer containing the packed message.
 * @returns {ArrayBuffer} The unpacked message.
 */
function unpack(packed) {
    // We have no choice but to read the packed buffer one byte at a time.
    var src = new Uint8Array(packed);
    var dst = new Uint8Array(new ArrayBuffer(getUnpackedByteLength(packed)));
    /** The last tag byte that we've seen - it starts at a "neutral" value. */
    var lastTag = 0x77;
    for (var srcByteOffset = 0, dstByteOffset = 0; srcByteOffset < src.byteLength;) {
        var tag = src[srcByteOffset];
        if (lastTag === 0 /* ZERO */) {
            // We have a span of zeroes. New array buffers are guaranteed to be initialized to zero so we just seek ahead.
            dstByteOffset += tag * 8;
            srcByteOffset++;
            lastTag = 0x77;
        }
        else if (lastTag === 255 /* SPAN */) {
            // We have a span of unpacked bytes. Copy them verbatim from the source buffer.
            var spanByteLength = tag * 8;
            dst.set(src.subarray(srcByteOffset + 1, srcByteOffset + 1 + spanByteLength), dstByteOffset);
            dstByteOffset += spanByteLength;
            srcByteOffset += 1 + spanByteLength;
            lastTag = 0x77;
        }
        else {
            // Okay, a normal tag. Let's read past the tag and copy bytes that have a bit set in the tag.
            srcByteOffset++;
            for (var i = 1; i <= 128; i <<= 1) {
                // We only need to actually touch `dst` if there's a nonzero byte (it's already initialized to zeroes).
                if ((tag & i) !== 0)
                    dst[dstByteOffset] = src[srcByteOffset++];
                dstByteOffset++;
            }
            lastTag = tag;
        }
    }
    return dst.buffer;
}
exports.unpack = unpack;

//# sourceMappingURL=packing.js.map


/***/ }),

/***/ "./node_modules/capnp-ts/lib/serialization/pointers/any-pointer-list.js":
/*!******************************************************************************!*\
  !*** ./node_modules/capnp-ts/lib/serialization/pointers/any-pointer-list.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @author jdiaz5513
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var pointer_1 = __webpack_require__(/*! ./pointer */ "./node_modules/capnp-ts/lib/serialization/pointers/pointer.js");
var pointer_list_1 = __webpack_require__(/*! ./pointer-list */ "./node_modules/capnp-ts/lib/serialization/pointers/pointer-list.js");
exports.AnyPointerList = pointer_list_1.PointerList(pointer_1.Pointer);

//# sourceMappingURL=any-pointer-list.js.map


/***/ }),

/***/ "./node_modules/capnp-ts/lib/serialization/pointers/bool-list.js":
/*!***********************************************************************!*\
  !*** ./node_modules/capnp-ts/lib/serialization/pointers/bool-list.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @author jdiaz5513
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var debug_1 = __webpack_require__(/*! debug */ "./node_modules/capnp-ts/node_modules/debug/src/browser.js");
var list_element_size_1 = __webpack_require__(/*! ../list-element-size */ "./node_modules/capnp-ts/lib/serialization/list-element-size.js");
var list_1 = __webpack_require__(/*! ./list */ "./node_modules/capnp-ts/lib/serialization/pointers/list.js");
var pointer_1 = __webpack_require__(/*! ./pointer */ "./node_modules/capnp-ts/lib/serialization/pointers/pointer.js");
var trace = debug_1.default("capnp:list:composite");
trace("load");
var BoolList = /** @class */ (function (_super) {
    tslib_1.__extends(BoolList, _super);
    function BoolList() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    BoolList.prototype.get = function (index) {
        var bitMask = 1 << index % 8;
        var byteOffset = index >>> 3;
        var c = pointer_1.getContent(this);
        var v = c.segment.getUint8(c.byteOffset + byteOffset);
        return (v & bitMask) !== 0;
    };
    BoolList.prototype.set = function (index, value) {
        var bitMask = 1 << index % 8;
        var c = pointer_1.getContent(this);
        var byteOffset = c.byteOffset + (index >>> 3);
        var v = c.segment.getUint8(byteOffset);
        c.segment.setUint8(byteOffset, value ? v | bitMask : v & ~bitMask);
    };
    BoolList.prototype.toString = function () {
        return "Bool_" + _super.prototype.toString.call(this);
    };
    BoolList._capnp = {
        displayName: "List<boolean>",
        size: list_element_size_1.ListElementSize.BIT
    };
    return BoolList;
}(list_1.List));
exports.BoolList = BoolList;

//# sourceMappingURL=bool-list.js.map


/***/ }),

/***/ "./node_modules/capnp-ts/lib/serialization/pointers/composite-list.js":
/*!****************************************************************************!*\
  !*** ./node_modules/capnp-ts/lib/serialization/pointers/composite-list.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @author jdiaz5513
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var debug_1 = __webpack_require__(/*! debug */ "./node_modules/capnp-ts/node_modules/debug/src/browser.js");
var list_element_size_1 = __webpack_require__(/*! ../list-element-size */ "./node_modules/capnp-ts/lib/serialization/list-element-size.js");
var list_1 = __webpack_require__(/*! ./list */ "./node_modules/capnp-ts/lib/serialization/pointers/list.js");
var pointer_1 = __webpack_require__(/*! ./pointer */ "./node_modules/capnp-ts/lib/serialization/pointers/pointer.js");
var trace = debug_1.default("capnp:list:composite");
trace("load");
function CompositeList(CompositeClass) {
    var _a;
    return _a = /** @class */ (function (_super) {
            tslib_1.__extends(class_1, _super);
            function class_1() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            class_1.prototype.get = function (index) {
                return new CompositeClass(this.segment, this.byteOffset, this._capnp.depthLimit - 1, index);
            };
            class_1.prototype.set = function (index, value) {
                pointer_1.copyFrom(value, this.get(index));
            };
            class_1.prototype.toString = function () {
                return "Composite_" + _super.prototype.toString.call(this) + ",cls:" + CompositeClass.toString();
            };
            return class_1;
        }(list_1.List)),
        _a._capnp = {
            compositeSize: CompositeClass._capnp.size,
            displayName: "List<" + CompositeClass._capnp.displayName + ">",
            size: list_element_size_1.ListElementSize.COMPOSITE
        },
        _a;
}
exports.CompositeList = CompositeList;

//# sourceMappingURL=composite-list.js.map


/***/ }),

/***/ "./node_modules/capnp-ts/lib/serialization/pointers/data-list.js":
/*!***********************************************************************!*\
  !*** ./node_modules/capnp-ts/lib/serialization/pointers/data-list.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @author jdiaz5513
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var data_1 = __webpack_require__(/*! ./data */ "./node_modules/capnp-ts/lib/serialization/pointers/data.js");
var pointer_list_1 = __webpack_require__(/*! ./pointer-list */ "./node_modules/capnp-ts/lib/serialization/pointers/pointer-list.js");
exports.DataList = pointer_list_1.PointerList(data_1.Data);

//# sourceMappingURL=data-list.js.map


/***/ }),

/***/ "./node_modules/capnp-ts/lib/serialization/pointers/data.js":
/*!******************************************************************!*\
  !*** ./node_modules/capnp-ts/lib/serialization/pointers/data.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @author jdiaz5513
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var debug_1 = __webpack_require__(/*! debug */ "./node_modules/capnp-ts/node_modules/debug/src/browser.js");
var list_element_size_1 = __webpack_require__(/*! ../list-element-size */ "./node_modules/capnp-ts/lib/serialization/list-element-size.js");
var list_1 = __webpack_require__(/*! ./list */ "./node_modules/capnp-ts/lib/serialization/pointers/list.js");
var pointer_1 = __webpack_require__(/*! ./pointer */ "./node_modules/capnp-ts/lib/serialization/pointers/pointer.js");
var pointer_type_1 = __webpack_require__(/*! ./pointer-type */ "./node_modules/capnp-ts/lib/serialization/pointers/pointer-type.js");
var trace = debug_1.default("capnp:data");
trace("load");
/**
 * A generic blob of bytes. Can be converted to a DataView or Uint8Array to access its contents using `toDataView()` and
 * `toUint8Array()`. Use `copyBuffer()` to copy an entire buffer at once.
 *
 * @export
 * @class Data
 * @extends {List<number>}
 */
var Data = /** @class */ (function (_super) {
    tslib_1.__extends(Data, _super);
    function Data() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Data.fromPointer = function (pointer) {
        pointer_1.validate(pointer_type_1.PointerType.LIST, pointer, list_element_size_1.ListElementSize.BYTE);
        return this._fromPointerUnchecked(pointer);
    };
    Data._fromPointerUnchecked = function (pointer) {
        return new this(pointer.segment, pointer.byteOffset, pointer._capnp.depthLimit);
    };
    /**
     * Copy the contents of `src` into this Data pointer. If `src` is smaller than the length of this pointer then the
     * remaining bytes will be zeroed out. Extra bytes in `src` are ignored.
     *
     * @param {(ArrayBuffer | ArrayBufferView)} src The source buffer.
     * @returns {void}
     */
    // TODO: Would be nice to have a way to zero-copy a buffer by allocating a new segment into the message with that
    // buffer data.
    Data.prototype.copyBuffer = function (src) {
        var c = pointer_1.getContent(this);
        var dstLength = this.getLength();
        var srcLength = src.byteLength;
        var i = src instanceof ArrayBuffer
            ? new Uint8Array(src)
            : new Uint8Array(src.buffer, src.byteOffset, Math.min(dstLength, srcLength));
        var o = new Uint8Array(c.segment.buffer, c.byteOffset, this.getLength());
        o.set(i);
        if (dstLength > srcLength) {
            trace("Zeroing out remaining %d bytes after copy into %s.", dstLength - srcLength, this);
            o.fill(0, srcLength, dstLength);
        }
        else if (dstLength < srcLength) {
            trace("Truncated %d bytes from source buffer while copying to %s.", srcLength - dstLength, this);
        }
    };
    /**
     * Read a byte from the specified offset.
     *
     * @param {number} byteOffset The byte offset to read.
     * @returns {number} The byte value.
     */
    Data.prototype.get = function (byteOffset) {
        var c = pointer_1.getContent(this);
        return c.segment.getUint8(c.byteOffset + byteOffset);
    };
    /**
     * Write a byte at the specified offset.
     *
     * @param {number} byteOffset The byte offset to set.
     * @param {number} value The byte value to set.
     * @returns {void}
     */
    Data.prototype.set = function (byteOffset, value) {
        var c = pointer_1.getContent(this);
        c.segment.setUint8(c.byteOffset + byteOffset, value);
    };
    /**
     * Creates a **copy** of the underlying buffer data and returns it as an ArrayBuffer.
     *
     * To obtain a reference to the underlying buffer instead, use `toUint8Array()` or `toDataView()`.
     *
     * @returns {ArrayBuffer} A copy of this data buffer.
     */
    Data.prototype.toArrayBuffer = function () {
        var c = pointer_1.getContent(this);
        return c.segment.buffer.slice(c.byteOffset, c.byteOffset + this.getLength());
    };
    /**
     * Convert this Data pointer to a DataView representing the pointer's contents.
     *
     * WARNING: The DataView references memory from a message segment, so do not venture outside the bounds of the
     * DataView or else BAD THINGS.
     *
     * @returns {DataView} A live reference to the underlying buffer.
     */
    Data.prototype.toDataView = function () {
        var c = pointer_1.getContent(this);
        return new DataView(c.segment.buffer, c.byteOffset, this.getLength());
    };
    Data.prototype.toString = function () {
        return "Data_" + _super.prototype.toString.call(this);
    };
    /**
     * Convert this Data pointer to a Uint8Array representing the pointer's contents.
     *
     * WARNING: The Uint8Array references memory from a message segment, so do not venture outside the bounds of the
     * Uint8Array or else BAD THINGS.
     *
     * @returns {DataView} A live reference to the underlying buffer.
     */
    Data.prototype.toUint8Array = function () {
        var c = pointer_1.getContent(this);
        return new Uint8Array(c.segment.buffer, c.byteOffset, this.getLength());
    };
    return Data;
}(list_1.List));
exports.Data = Data;

//# sourceMappingURL=data.js.map


/***/ }),

/***/ "./node_modules/capnp-ts/lib/serialization/pointers/float32-list.js":
/*!**************************************************************************!*\
  !*** ./node_modules/capnp-ts/lib/serialization/pointers/float32-list.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @author jdiaz5513
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var debug_1 = __webpack_require__(/*! debug */ "./node_modules/capnp-ts/node_modules/debug/src/browser.js");
var list_element_size_1 = __webpack_require__(/*! ../list-element-size */ "./node_modules/capnp-ts/lib/serialization/list-element-size.js");
var list_1 = __webpack_require__(/*! ./list */ "./node_modules/capnp-ts/lib/serialization/pointers/list.js");
var pointer_1 = __webpack_require__(/*! ./pointer */ "./node_modules/capnp-ts/lib/serialization/pointers/pointer.js");
var trace = debug_1.default("capnp:list:composite");
trace("load");
var Float32List = /** @class */ (function (_super) {
    tslib_1.__extends(Float32List, _super);
    function Float32List() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Float32List.prototype.get = function (index) {
        var c = pointer_1.getContent(this);
        return c.segment.getFloat32(c.byteOffset + index * 4);
    };
    Float32List.prototype.set = function (index, value) {
        var c = pointer_1.getContent(this);
        c.segment.setFloat32(c.byteOffset + index * 4, value);
    };
    Float32List.prototype.toString = function () {
        return "Float32_" + _super.prototype.toString.call(this);
    };
    Float32List._capnp = {
        displayName: "List<Float32>",
        size: list_element_size_1.ListElementSize.BYTE_4
    };
    return Float32List;
}(list_1.List));
exports.Float32List = Float32List;

//# sourceMappingURL=float32-list.js.map


/***/ }),

/***/ "./node_modules/capnp-ts/lib/serialization/pointers/float64-list.js":
/*!**************************************************************************!*\
  !*** ./node_modules/capnp-ts/lib/serialization/pointers/float64-list.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @author jdiaz5513
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var debug_1 = __webpack_require__(/*! debug */ "./node_modules/capnp-ts/node_modules/debug/src/browser.js");
var list_element_size_1 = __webpack_require__(/*! ../list-element-size */ "./node_modules/capnp-ts/lib/serialization/list-element-size.js");
var list_1 = __webpack_require__(/*! ./list */ "./node_modules/capnp-ts/lib/serialization/pointers/list.js");
var pointer_1 = __webpack_require__(/*! ./pointer */ "./node_modules/capnp-ts/lib/serialization/pointers/pointer.js");
var trace = debug_1.default("capnp:list:composite");
trace("load");
var Float64List = /** @class */ (function (_super) {
    tslib_1.__extends(Float64List, _super);
    function Float64List() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Float64List.prototype.get = function (index) {
        var c = pointer_1.getContent(this);
        return c.segment.getFloat64(c.byteOffset + index * 8);
    };
    Float64List.prototype.set = function (index, value) {
        var c = pointer_1.getContent(this);
        c.segment.setFloat64(c.byteOffset + index * 8, value);
    };
    Float64List.prototype.toString = function () {
        return "Float64_" + _super.prototype.toString.call(this);
    };
    Float64List._capnp = {
        displayName: "List<Float64>",
        size: list_element_size_1.ListElementSize.BYTE_8
    };
    return Float64List;
}(list_1.List));
exports.Float64List = Float64List;

//# sourceMappingURL=float64-list.js.map


/***/ }),

/***/ "./node_modules/capnp-ts/lib/serialization/pointers/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/capnp-ts/lib/serialization/pointers/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @author jdiaz5513
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var any_pointer_list_1 = __webpack_require__(/*! ./any-pointer-list */ "./node_modules/capnp-ts/lib/serialization/pointers/any-pointer-list.js");
exports.AnyPointerList = any_pointer_list_1.AnyPointerList;
var bool_list_1 = __webpack_require__(/*! ./bool-list */ "./node_modules/capnp-ts/lib/serialization/pointers/bool-list.js");
exports.BoolList = bool_list_1.BoolList;
var composite_list_1 = __webpack_require__(/*! ./composite-list */ "./node_modules/capnp-ts/lib/serialization/pointers/composite-list.js");
exports.CompositeList = composite_list_1.CompositeList;
var data_1 = __webpack_require__(/*! ./data */ "./node_modules/capnp-ts/lib/serialization/pointers/data.js");
exports.Data = data_1.Data;
var data_list_1 = __webpack_require__(/*! ./data-list */ "./node_modules/capnp-ts/lib/serialization/pointers/data-list.js");
exports.DataList = data_list_1.DataList;
var float32_list_1 = __webpack_require__(/*! ./float32-list */ "./node_modules/capnp-ts/lib/serialization/pointers/float32-list.js");
exports.Float32List = float32_list_1.Float32List;
var float64_list_1 = __webpack_require__(/*! ./float64-list */ "./node_modules/capnp-ts/lib/serialization/pointers/float64-list.js");
exports.Float64List = float64_list_1.Float64List;
var int8_list_1 = __webpack_require__(/*! ./int8-list */ "./node_modules/capnp-ts/lib/serialization/pointers/int8-list.js");
exports.Int8List = int8_list_1.Int8List;
var int16_list_1 = __webpack_require__(/*! ./int16-list */ "./node_modules/capnp-ts/lib/serialization/pointers/int16-list.js");
exports.Int16List = int16_list_1.Int16List;
var int32_list_1 = __webpack_require__(/*! ./int32-list */ "./node_modules/capnp-ts/lib/serialization/pointers/int32-list.js");
exports.Int32List = int32_list_1.Int32List;
var int64_list_1 = __webpack_require__(/*! ./int64-list */ "./node_modules/capnp-ts/lib/serialization/pointers/int64-list.js");
exports.Int64List = int64_list_1.Int64List;
var interface_1 = __webpack_require__(/*! ./interface */ "./node_modules/capnp-ts/lib/serialization/pointers/interface.js");
exports.Interface = interface_1.Interface;
var interface_list_1 = __webpack_require__(/*! ./interface-list */ "./node_modules/capnp-ts/lib/serialization/pointers/interface-list.js");
exports.InterfaceList = interface_list_1.InterfaceList;
var list_1 = __webpack_require__(/*! ./list */ "./node_modules/capnp-ts/lib/serialization/pointers/list.js");
exports.List = list_1.List;
var orphan_1 = __webpack_require__(/*! ./orphan */ "./node_modules/capnp-ts/lib/serialization/pointers/orphan.js");
exports.Orphan = orphan_1.Orphan;
var pointer_list_1 = __webpack_require__(/*! ./pointer-list */ "./node_modules/capnp-ts/lib/serialization/pointers/pointer-list.js");
exports.PointerList = pointer_list_1.PointerList;
var pointer_type_1 = __webpack_require__(/*! ./pointer-type */ "./node_modules/capnp-ts/lib/serialization/pointers/pointer-type.js");
exports.PointerType = pointer_type_1.PointerType;
var pointer_1 = __webpack_require__(/*! ./pointer */ "./node_modules/capnp-ts/lib/serialization/pointers/pointer.js");
exports.Pointer = pointer_1.Pointer;
var struct_1 = __webpack_require__(/*! ./struct */ "./node_modules/capnp-ts/lib/serialization/pointers/struct.js");
exports.Struct = struct_1.Struct;
var text_1 = __webpack_require__(/*! ./text */ "./node_modules/capnp-ts/lib/serialization/pointers/text.js");
exports.Text = text_1.Text;
var text_list_1 = __webpack_require__(/*! ./text-list */ "./node_modules/capnp-ts/lib/serialization/pointers/text-list.js");
exports.TextList = text_list_1.TextList;
var uint8_list_1 = __webpack_require__(/*! ./uint8-list */ "./node_modules/capnp-ts/lib/serialization/pointers/uint8-list.js");
exports.Uint8List = uint8_list_1.Uint8List;
var uint16_list_1 = __webpack_require__(/*! ./uint16-list */ "./node_modules/capnp-ts/lib/serialization/pointers/uint16-list.js");
exports.Uint16List = uint16_list_1.Uint16List;
var uint32_list_1 = __webpack_require__(/*! ./uint32-list */ "./node_modules/capnp-ts/lib/serialization/pointers/uint32-list.js");
exports.Uint32List = uint32_list_1.Uint32List;
var uint64_list_1 = __webpack_require__(/*! ./uint64-list */ "./node_modules/capnp-ts/lib/serialization/pointers/uint64-list.js");
exports.Uint64List = uint64_list_1.Uint64List;
var void_1 = __webpack_require__(/*! ./void */ "./node_modules/capnp-ts/lib/serialization/pointers/void.js");
exports.Void = void_1.Void;
exports.VOID = void_1.VOID;
var void_list_1 = __webpack_require__(/*! ./void-list */ "./node_modules/capnp-ts/lib/serialization/pointers/void-list.js");
exports.VoidList = void_list_1.VoidList;

//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/capnp-ts/lib/serialization/pointers/int16-list.js":
/*!************************************************************************!*\
  !*** ./node_modules/capnp-ts/lib/serialization/pointers/int16-list.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @author jdiaz5513
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var debug_1 = __webpack_require__(/*! debug */ "./node_modules/capnp-ts/node_modules/debug/src/browser.js");
var list_element_size_1 = __webpack_require__(/*! ../list-element-size */ "./node_modules/capnp-ts/lib/serialization/list-element-size.js");
var list_1 = __webpack_require__(/*! ./list */ "./node_modules/capnp-ts/lib/serialization/pointers/list.js");
var pointer_1 = __webpack_require__(/*! ./pointer */ "./node_modules/capnp-ts/lib/serialization/pointers/pointer.js");
var trace = debug_1.default("capnp:list:composite");
trace("load");
var Int16List = /** @class */ (function (_super) {
    tslib_1.__extends(Int16List, _super);
    function Int16List() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Int16List.prototype.get = function (index) {
        var c = pointer_1.getContent(this);
        return c.segment.getInt16(c.byteOffset + index * 2);
    };
    Int16List.prototype.set = function (index, value) {
        var c = pointer_1.getContent(this);
        c.segment.setInt16(c.byteOffset + index * 2, value);
    };
    Int16List.prototype.toString = function () {
        return "Int16_" + _super.prototype.toString.call(this);
    };
    Int16List._capnp = {
        displayName: "List<Int16>",
        size: list_element_size_1.ListElementSize.BYTE_2
    };
    return Int16List;
}(list_1.List));
exports.Int16List = Int16List;

//# sourceMappingURL=int16-list.js.map


/***/ }),

/***/ "./node_modules/capnp-ts/lib/serialization/pointers/int32-list.js":
/*!************************************************************************!*\
  !*** ./node_modules/capnp-ts/lib/serialization/pointers/int32-list.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @author jdiaz5513
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var debug_1 = __webpack_require__(/*! debug */ "./node_modules/capnp-ts/node_modules/debug/src/browser.js");
var list_element_size_1 = __webpack_require__(/*! ../list-element-size */ "./node_modules/capnp-ts/lib/serialization/list-element-size.js");
var list_1 = __webpack_require__(/*! ./list */ "./node_modules/capnp-ts/lib/serialization/pointers/list.js");
var pointer_1 = __webpack_require__(/*! ./pointer */ "./node_modules/capnp-ts/lib/serialization/pointers/pointer.js");
var trace = debug_1.default("capnp:list:composite");
trace("load");
var Int32List = /** @class */ (function (_super) {
    tslib_1.__extends(Int32List, _super);
    function Int32List() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Int32List.prototype.get = function (index) {
        var c = pointer_1.getContent(this);
        return c.segment.getInt32(c.byteOffset + index * 4);
    };
    Int32List.prototype.set = function (index, value) {
        var c = pointer_1.getContent(this);
        c.segment.setInt32(c.byteOffset + index * 4, value);
    };
    Int32List.prototype.toString = function () {
        return "Int32_" + _super.prototype.toString.call(this);
    };
    Int32List._capnp = {
        displayName: "List<Int32>",
        size: list_element_size_1.ListElementSize.BYTE_4
    };
    return Int32List;
}(list_1.List));
exports.Int32List = Int32List;

//# sourceMappingURL=int32-list.js.map


/***/ }),

/***/ "./node_modules/capnp-ts/lib/serialization/pointers/int64-list.js":
/*!************************************************************************!*\
  !*** ./node_modules/capnp-ts/lib/serialization/pointers/int64-list.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @author jdiaz5513
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var debug_1 = __webpack_require__(/*! debug */ "./node_modules/capnp-ts/node_modules/debug/src/browser.js");
var list_element_size_1 = __webpack_require__(/*! ../list-element-size */ "./node_modules/capnp-ts/lib/serialization/list-element-size.js");
var list_1 = __webpack_require__(/*! ./list */ "./node_modules/capnp-ts/lib/serialization/pointers/list.js");
var pointer_1 = __webpack_require__(/*! ./pointer */ "./node_modules/capnp-ts/lib/serialization/pointers/pointer.js");
var trace = debug_1.default("capnp:list:composite");
trace("load");
var Int64List = /** @class */ (function (_super) {
    tslib_1.__extends(Int64List, _super);
    function Int64List() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Int64List.prototype.get = function (index) {
        var c = pointer_1.getContent(this);
        return c.segment.getInt64(c.byteOffset + index * 8);
    };
    Int64List.prototype.set = function (index, value) {
        var c = pointer_1.getContent(this);
        c.segment.setInt64(c.byteOffset + index * 8, value);
    };
    Int64List.prototype.toString = function () {
        return "Int64_" + _super.prototype.toString.call(this);
    };
    Int64List._capnp = {
        displayName: "List<Int64>",
        size: list_element_size_1.ListElementSize.BYTE_8
    };
    return Int64List;
}(list_1.List));
exports.Int64List = Int64List;

//# sourceMappingURL=int64-list.js.map


/***/ }),

/***/ "./node_modules/capnp-ts/lib/serialization/pointers/int8-list.js":
/*!***********************************************************************!*\
  !*** ./node_modules/capnp-ts/lib/serialization/pointers/int8-list.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @author jdiaz5513
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var debug_1 = __webpack_require__(/*! debug */ "./node_modules/capnp-ts/node_modules/debug/src/browser.js");
var list_element_size_1 = __webpack_require__(/*! ../list-element-size */ "./node_modules/capnp-ts/lib/serialization/list-element-size.js");
var list_1 = __webpack_require__(/*! ./list */ "./node_modules/capnp-ts/lib/serialization/pointers/list.js");
var pointer_1 = __webpack_require__(/*! ./pointer */ "./node_modules/capnp-ts/lib/serialization/pointers/pointer.js");
var trace = debug_1.default("capnp:list:composite");
trace("load");
var Int8List = /** @class */ (function (_super) {
    tslib_1.__extends(Int8List, _super);
    function Int8List() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Int8List.prototype.get = function (index) {
        var c = pointer_1.getContent(this);
        return c.segment.getInt8(c.byteOffset + index);
    };
    Int8List.prototype.set = function (index, value) {
        var c = pointer_1.getContent(this);
        c.segment.setInt8(c.byteOffset + index, value);
    };
    Int8List.prototype.toString = function () {
        return "Int8_" + _super.prototype.toString.call(this);
    };
    Int8List._capnp = {
        displayName: "List<Int8>",
        size: list_element_size_1.ListElementSize.BYTE
    };
    return Int8List;
}(list_1.List));
exports.Int8List = Int8List;

//# sourceMappingURL=int8-list.js.map


/***/ }),

/***/ "./node_modules/capnp-ts/lib/serialization/pointers/interface-list.js":
/*!****************************************************************************!*\
  !*** ./node_modules/capnp-ts/lib/serialization/pointers/interface-list.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @author jdiaz5513
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var interface_1 = __webpack_require__(/*! ./interface */ "./node_modules/capnp-ts/lib/serialization/pointers/interface.js");
var pointer_list_1 = __webpack_require__(/*! ./pointer-list */ "./node_modules/capnp-ts/lib/serialization/pointers/pointer-list.js");
exports.InterfaceList = pointer_list_1.PointerList(interface_1.Interface);

//# sourceMappingURL=interface-list.js.map


/***/ }),

/***/ "./node_modules/capnp-ts/lib/serialization/pointers/interface.js":
/*!***********************************************************************!*\
  !*** ./node_modules/capnp-ts/lib/serialization/pointers/interface.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @author jdiaz5513
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var constants_1 = __webpack_require__(/*! ../../constants */ "./node_modules/capnp-ts/lib/constants.js");
var errors_1 = __webpack_require__(/*! ../../errors */ "./node_modules/capnp-ts/lib/errors.js");
var util_1 = __webpack_require__(/*! ../../util */ "./node_modules/capnp-ts/lib/util.js");
var pointer_1 = __webpack_require__(/*! ./pointer */ "./node_modules/capnp-ts/lib/serialization/pointers/pointer.js");
var Interface = /** @class */ (function (_super) {
    tslib_1.__extends(Interface, _super);
    function Interface(segment, byteOffset, depthLimit) {
        if (depthLimit === void 0) { depthLimit = constants_1.MAX_DEPTH; }
        var _this = _super.call(this, segment, byteOffset, depthLimit) || this;
        throw new Error(util_1.format(errors_1.NOT_IMPLEMENTED, "new Interface"));
        return _this;
    }
    return Interface;
}(pointer_1.Pointer));
exports.Interface = Interface;

//# sourceMappingURL=interface.js.map


/***/ }),

/***/ "./node_modules/capnp-ts/lib/serialization/pointers/list.js":
/*!******************************************************************!*\
  !*** ./node_modules/capnp-ts/lib/serialization/pointers/list.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @author jdiaz5513
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var debug_1 = __webpack_require__(/*! debug */ "./node_modules/capnp-ts/node_modules/debug/src/browser.js");
var errors_1 = __webpack_require__(/*! ../../errors */ "./node_modules/capnp-ts/lib/errors.js");
var util_1 = __webpack_require__(/*! ../../util */ "./node_modules/capnp-ts/lib/util.js");
var list_element_size_1 = __webpack_require__(/*! ../list-element-size */ "./node_modules/capnp-ts/lib/serialization/list-element-size.js");
var object_size_1 = __webpack_require__(/*! ../object-size */ "./node_modules/capnp-ts/lib/serialization/object-size.js");
var pointer_1 = __webpack_require__(/*! ./pointer */ "./node_modules/capnp-ts/lib/serialization/pointers/pointer.js");
var trace = debug_1.default("capnp:list");
trace("load");
/**
 * A generic list class. Implements Filterable,
 */
var List = /** @class */ (function (_super) {
    tslib_1.__extends(List, _super);
    function List() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    List.toString = function () {
        return this._capnp.displayName;
    };
    List.prototype.all = function (callbackfn) {
        var length = this.getLength();
        for (var i = 0; i < length; i++) {
            if (!callbackfn(this.get(i), i))
                return false;
        }
        return true;
    };
    List.prototype.any = function (callbackfn) {
        var length = this.getLength();
        for (var i = 0; i < length; i++) {
            if (callbackfn(this.get(i), i))
                return true;
        }
        return false;
    };
    List.prototype.ap = function (callbackfns) {
        var _this = this;
        var length = this.getLength();
        var res = [];
        var _loop_1 = function (i) {
            res.push.apply(res, callbackfns.map(function (f) { return f(_this.get(i), i); }));
        };
        for (var i = 0; i < length; i++) {
            _loop_1(i);
        }
        return res;
    };
    List.prototype.concat = function (other) {
        var length = this.getLength();
        var otherLength = other.getLength();
        var res = new Array(length + otherLength);
        for (var i = 0; i < length; i++)
            res[i] = this.get(i);
        for (var i = 0; i < otherLength; i++)
            res[i + length] = other.get(i);
        return res;
    };
    List.prototype.drop = function (n) {
        var length = this.getLength();
        var res = new Array(length);
        for (var i = n; i < length; i++)
            res[i] = this.get(i);
        return res;
    };
    List.prototype.dropWhile = function (callbackfn) {
        var length = this.getLength();
        var res = [];
        var drop = true;
        for (var i = 0; i < length; i++) {
            var v = this.get(i);
            if (drop)
                drop = callbackfn(v, i);
            if (!drop)
                res.push(v);
        }
        return res;
    };
    List.prototype.empty = function () {
        return [];
    };
    List.prototype.every = function (callbackfn) {
        return this.all(callbackfn);
    };
    List.prototype.filter = function (callbackfn) {
        var length = this.getLength();
        var res = [];
        for (var i = 0; i < length; i++) {
            var value = this.get(i);
            if (callbackfn(value, i))
                res.push(value);
        }
        return res;
    };
    List.prototype.find = function (callbackfn) {
        var length = this.getLength();
        for (var i = 0; i < length; i++) {
            var value = this.get(i);
            if (callbackfn(value, i))
                return value;
        }
        return undefined;
    };
    List.prototype.findIndex = function (callbackfn) {
        var length = this.getLength();
        for (var i = 0; i < length; i++) {
            var value = this.get(i);
            if (callbackfn(value, i))
                return i;
        }
        return -1;
    };
    List.prototype.forEach = function (callbackfn) {
        var length = this.getLength();
        for (var i = 0; i < length; i++)
            callbackfn(this.get(i), i);
    };
    List.prototype.get = function (_index) {
        return get(_index, this);
    };
    /**
     * Get the length of this list.
     *
     * @returns {number} The number of elements in this list.
     */
    List.prototype.getLength = function () {
        return pointer_1.getTargetListLength(this);
    };
    List.prototype.groupBy = function (callbackfn) {
        var length = this.getLength();
        var res = {};
        for (var i = 0; i < length; i++) {
            var v = this.get(i);
            res[callbackfn(v, i)] = v;
        }
        return res;
    };
    List.prototype.intersperse = function (sep) {
        var length = this.getLength();
        var res = new Array(length);
        for (var i = 0; i < length; i++) {
            if (i > 0)
                res.push(sep);
            res.push(this.get(i));
        }
        return res;
    };
    List.prototype.map = function (callbackfn) {
        var length = this.getLength();
        var res = new Array(length);
        for (var i = 0; i < length; i++)
            res[i] = callbackfn(this.get(i), i);
        return res;
    };
    List.prototype.reduce = function (callbackfn, initialValue) {
        var i = 0;
        var res;
        if (initialValue === undefined) {
            // LINT: It's okay, I know what I'm doing here.
            /* tslint:disable-next-line:no-any */
            res = this.get(0);
            i++;
        }
        else {
            res = initialValue;
        }
        for (; i < this.getLength(); i++)
            res = callbackfn(res, this.get(i), i);
        return res;
    };
    List.prototype.set = function (_index, _value) {
        set(_index, _value, this);
    };
    List.prototype.slice = function (start, end) {
        if (start === void 0) { start = 0; }
        var length = end ? Math.min(this.getLength(), end) : this.getLength();
        var res = new Array(length - start);
        for (var i = start; i < length; i++)
            res[i] = this.get(i);
        return res;
    };
    List.prototype.some = function (callbackfn) {
        return this.any(callbackfn);
    };
    List.prototype.take = function (n) {
        var length = Math.min(this.getLength(), n);
        var res = new Array(length);
        for (var i = 0; i < length; i++)
            res[i] = this.get(i);
        return res;
    };
    List.prototype.takeWhile = function (callbackfn) {
        var length = this.getLength();
        var res = [];
        var take;
        for (var i = 0; i < length; i++) {
            var v = this.get(i);
            take = callbackfn(v, i);
            if (!take)
                return res;
            res.push(v);
        }
        return res;
    };
    List.prototype.toArray = function () {
        return this.map(util_1.identity);
    };
    List.prototype.toString = function () {
        return "List_" + _super.prototype.toString.call(this);
    };
    List._capnp = {
        displayName: "List<Generic>",
        size: list_element_size_1.ListElementSize.VOID
    };
    List.get = get;
    List.initList = initList;
    List.set = set;
    return List;
}(pointer_1.Pointer));
exports.List = List;
/**
 * Initialize the list with the given element size and length. This will allocate new space for the list, ideally in
 * the same segment as this pointer.
 *
 * @param {ListElementSize} elementSize The size of each element in the list.
 * @param {number} length The number of elements in the list.
 * @param {List<T>} l The list to initialize.
 * @param {ObjectSize} [compositeSize] The size of each element in a composite list. This value is required for
 * composite lists.
 * @returns {void}
 */
function initList(elementSize, length, l, compositeSize) {
    var c;
    switch (elementSize) {
        case list_element_size_1.ListElementSize.BIT:
            c = l.segment.allocate(Math.ceil(length / 8));
            break;
        case list_element_size_1.ListElementSize.BYTE:
        case list_element_size_1.ListElementSize.BYTE_2:
        case list_element_size_1.ListElementSize.BYTE_4:
        case list_element_size_1.ListElementSize.BYTE_8:
        case list_element_size_1.ListElementSize.POINTER:
            c = l.segment.allocate(length * pointer_1.getListElementByteLength(elementSize));
            break;
        case list_element_size_1.ListElementSize.COMPOSITE:
            if (compositeSize === undefined) {
                throw new Error(util_1.format(errors_1.PTR_COMPOSITE_SIZE_UNDEFINED));
            }
            compositeSize = object_size_1.padToWord(compositeSize);
            var byteLength = object_size_1.getByteLength(compositeSize) * length;
            // We need to allocate an extra 8 bytes for the tag word, then make sure we write the length to it. We advance
            // the content pointer by 8 bytes so that it then points to the first list element as intended. Everything
            // starts off zeroed out so these nested structs don't need to be initialized in any way.
            c = l.segment.allocate(byteLength + 8);
            pointer_1.setStructPointer(length, compositeSize, c);
            trace("Wrote composite tag word %s for %s.", c, l);
            break;
        case list_element_size_1.ListElementSize.VOID:
            // No need to allocate anything, we can write the list pointer right here.
            pointer_1.setListPointer(0, elementSize, length, l);
            return;
        default:
            throw new Error(util_1.format(errors_1.PTR_INVALID_LIST_SIZE, elementSize));
    }
    var res = pointer_1.initPointer(c.segment, c.byteOffset, l);
    pointer_1.setListPointer(res.offsetWords, elementSize, length, res.pointer, compositeSize);
}
exports.initList = initList;
function get(_index, _l) {
    throw new TypeError();
}
exports.get = get;
function set(_index, _value, _l) {
    throw new TypeError();
}
exports.set = set;

//# sourceMappingURL=list.js.map


/***/ }),

/***/ "./node_modules/capnp-ts/lib/serialization/pointers/orphan.js":
/*!********************************************************************!*\
  !*** ./node_modules/capnp-ts/lib/serialization/pointers/orphan.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var debug_1 = __webpack_require__(/*! debug */ "./node_modules/capnp-ts/node_modules/debug/src/browser.js");
var errors_1 = __webpack_require__(/*! ../../errors */ "./node_modules/capnp-ts/lib/errors.js");
var util_1 = __webpack_require__(/*! ../../util */ "./node_modules/capnp-ts/lib/util.js");
var list_element_size_1 = __webpack_require__(/*! ../list-element-size */ "./node_modules/capnp-ts/lib/serialization/list-element-size.js");
var object_size_1 = __webpack_require__(/*! ../object-size */ "./node_modules/capnp-ts/lib/serialization/object-size.js");
var pointer_1 = __webpack_require__(/*! ./pointer */ "./node_modules/capnp-ts/lib/serialization/pointers/pointer.js");
var pointer_type_1 = __webpack_require__(/*! ./pointer-type */ "./node_modules/capnp-ts/lib/serialization/pointers/pointer-type.js");
var trace = debug_1.default("capnp:orphan");
trace("load");
// Technically speaking this class doesn't need to be generic, but the extra type checking enforced by this helps to
// make sure you don't accidentally adopt a pointer of the wrong type.
/**
 * An orphaned pointer. This object itself is technically a pointer to the original pointer's content, which was left
 * untouched in its original message. The original pointer data is encoded as attributes on the Orphan object, ready to
 * be reconstructed once another pointer is ready to adopt it.
 *
 * @export
 * @class Orphan
 * @extends {Pointer}
 * @template T
 */
var Orphan = /** @class */ (function () {
    function Orphan(src) {
        var c = pointer_1.getContent(src);
        this.segment = c.segment;
        this.byteOffset = c.byteOffset;
        this._capnp = {};
        // Read vital info from the src pointer so we can reconstruct it during adoption.
        this._capnp.type = pointer_1.getTargetPointerType(src);
        switch (this._capnp.type) {
            case pointer_type_1.PointerType.STRUCT:
                this._capnp.size = pointer_1.getTargetStructSize(src);
                break;
            case pointer_type_1.PointerType.LIST:
                this._capnp.length = pointer_1.getTargetListLength(src);
                this._capnp.elementSize = pointer_1.getTargetListElementSize(src);
                if (this._capnp.elementSize === list_element_size_1.ListElementSize.COMPOSITE) {
                    this._capnp.size = pointer_1.getTargetCompositeListSize(src);
                }
                break;
            case pointer_type_1.PointerType.OTHER:
                this._capnp.capId = pointer_1.getCapabilityId(src);
                break;
            default:
                // COVERAGE: Unreachable code.
                /* istanbul ignore next */
                throw new Error(errors_1.PTR_INVALID_POINTER_TYPE);
        }
        // Zero out the source pointer (but not the contents!).
        pointer_1.erasePointer(src);
    }
    /**
     * Adopt (move) this orphan into the target pointer location. This will allocate far pointers in `dst` as needed.
     *
     * @param {T} dst The destination pointer.
     * @returns {void}
     */
    Orphan.prototype._moveTo = function (dst) {
        if (this._capnp === undefined) {
            throw new Error(util_1.format(errors_1.PTR_ALREADY_ADOPTED, this));
        }
        // TODO: Implement copy semantics when this happens.
        if (this.segment.message !== dst.segment.message) {
            throw new Error(util_1.format(errors_1.PTR_ADOPT_WRONG_MESSAGE, this, dst));
        }
        // Recursively wipe out the destination pointer first.
        pointer_1.erase(dst);
        var res = pointer_1.initPointer(this.segment, this.byteOffset, dst);
        switch (this._capnp.type) {
            case pointer_type_1.PointerType.STRUCT:
                pointer_1.setStructPointer(res.offsetWords, this._capnp.size, res.pointer);
                break;
            case pointer_type_1.PointerType.LIST:
                var offsetWords = res.offsetWords;
                if (this._capnp.elementSize === list_element_size_1.ListElementSize.COMPOSITE) {
                    offsetWords--; // The tag word gets skipped.
                }
                pointer_1.setListPointer(offsetWords, this._capnp.elementSize, this._capnp.length, res.pointer, this._capnp.size);
                break;
            case pointer_type_1.PointerType.OTHER:
                pointer_1.setInterfacePointer(this._capnp.capId, res.pointer);
                break;
            /* istanbul ignore next */
            default:
                throw new Error(errors_1.PTR_INVALID_POINTER_TYPE);
        }
        this._capnp = undefined;
    };
    Orphan.prototype.dispose = function () {
        // FIXME: Should this throw?
        if (this._capnp === undefined) {
            trace("not disposing an already disposed orphan", this);
            return;
        }
        switch (this._capnp.type) {
            case pointer_type_1.PointerType.STRUCT:
                this.segment.fillZeroWords(this.byteOffset, object_size_1.getWordLength(this._capnp.size));
                break;
            case pointer_type_1.PointerType.LIST:
                var byteLength = pointer_1.getListByteLength(this._capnp.elementSize, this._capnp.length, this._capnp.size);
                this.segment.fillZeroWords(this.byteOffset, byteLength);
                break;
            default:
                // Other pointer types don't actually have any content.
                break;
        }
        this._capnp = undefined;
    };
    Orphan.prototype.toString = function () {
        return util_1.format("Orphan_%d@%a,type:%s", this.segment.id, this.byteOffset, this._capnp && this._capnp.type);
    };
    return Orphan;
}());
exports.Orphan = Orphan;

//# sourceMappingURL=orphan.js.map


/***/ }),

/***/ "./node_modules/capnp-ts/lib/serialization/pointers/pointer-allocation-result.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/capnp-ts/lib/serialization/pointers/pointer-allocation-result.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @author jdiaz5513
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var debug_1 = __webpack_require__(/*! debug */ "./node_modules/capnp-ts/node_modules/debug/src/browser.js");
var trace = debug_1.default("capnp:pointer-allocation-result");
trace("load");
/**
 * This is used as the return value for `Pointer.prototype.initPointer`. Turns out using a class in V8 for multiple
 * return values is faster than using an array or anonymous object.
 *
 * http://jsben.ch/#/zTdbD
 *
 * @export
 * @class PointerAllocationResult
 */
var PointerAllocationResult = /** @class */ (function () {
    function PointerAllocationResult(pointer, offsetWords) {
        this.pointer = pointer;
        this.offsetWords = offsetWords;
    }
    return PointerAllocationResult;
}());
exports.PointerAllocationResult = PointerAllocationResult;

//# sourceMappingURL=pointer-allocation-result.js.map


/***/ }),

/***/ "./node_modules/capnp-ts/lib/serialization/pointers/pointer-list.js":
/*!**************************************************************************!*\
  !*** ./node_modules/capnp-ts/lib/serialization/pointers/pointer-list.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @author jdiaz5513
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var debug_1 = __webpack_require__(/*! debug */ "./node_modules/capnp-ts/node_modules/debug/src/browser.js");
var list_element_size_1 = __webpack_require__(/*! ../list-element-size */ "./node_modules/capnp-ts/lib/serialization/list-element-size.js");
var list_1 = __webpack_require__(/*! ./list */ "./node_modules/capnp-ts/lib/serialization/pointers/list.js");
var pointer_1 = __webpack_require__(/*! ./pointer */ "./node_modules/capnp-ts/lib/serialization/pointers/pointer.js");
var trace = debug_1.default("capnp:list:composite");
trace("load");
function PointerList(PointerClass) {
    var _a;
    return _a = /** @class */ (function (_super) {
            tslib_1.__extends(class_1, _super);
            function class_1() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            class_1.prototype.get = function (index) {
                var c = pointer_1.getContent(this);
                return new PointerClass(c.segment, c.byteOffset + index * 8, this._capnp.depthLimit - 1);
            };
            class_1.prototype.set = function (index, value) {
                pointer_1.copyFrom(value, this.get(index));
            };
            class_1.prototype.toString = function () {
                return "Pointer_" + _super.prototype.toString.call(this) + ",cls:" + PointerClass.toString();
            };
            return class_1;
        }(list_1.List)),
        _a._capnp = {
            displayName: "List<" + PointerClass._capnp.displayName + ">",
            size: list_element_size_1.ListElementSize.POINTER
        },
        _a;
}
exports.PointerList = PointerList;

//# sourceMappingURL=pointer-list.js.map


/***/ }),

/***/ "./node_modules/capnp-ts/lib/serialization/pointers/pointer-type.js":
/*!**************************************************************************!*\
  !*** ./node_modules/capnp-ts/lib/serialization/pointers/pointer-type.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * @author jdiaz5513
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var PointerType;
(function (PointerType) {
    PointerType[PointerType["STRUCT"] = 0] = "STRUCT";
    PointerType[PointerType["LIST"] = 1] = "LIST";
    PointerType[PointerType["FAR"] = 2] = "FAR";
    PointerType[PointerType["OTHER"] = 3] = "OTHER";
})(PointerType = exports.PointerType || (exports.PointerType = {}));

//# sourceMappingURL=pointer-type.js.map


/***/ }),

/***/ "./node_modules/capnp-ts/lib/serialization/pointers/pointer.js":
/*!*********************************************************************!*\
  !*** ./node_modules/capnp-ts/lib/serialization/pointers/pointer.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @author jdiaz5513
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var debug_1 = __webpack_require__(/*! debug */ "./node_modules/capnp-ts/node_modules/debug/src/browser.js");
var constants_1 = __webpack_require__(/*! ../../constants */ "./node_modules/capnp-ts/lib/constants.js");
var util_1 = __webpack_require__(/*! ../../util */ "./node_modules/capnp-ts/lib/util.js");
var list_element_size_1 = __webpack_require__(/*! ../list-element-size */ "./node_modules/capnp-ts/lib/serialization/list-element-size.js");
var object_size_1 = __webpack_require__(/*! ../object-size */ "./node_modules/capnp-ts/lib/serialization/object-size.js");
var orphan_1 = __webpack_require__(/*! ./orphan */ "./node_modules/capnp-ts/lib/serialization/pointers/orphan.js");
var pointer_allocation_result_1 = __webpack_require__(/*! ./pointer-allocation-result */ "./node_modules/capnp-ts/lib/serialization/pointers/pointer-allocation-result.js");
var pointer_type_1 = __webpack_require__(/*! ./pointer-type */ "./node_modules/capnp-ts/lib/serialization/pointers/pointer-type.js");
var errors_1 = __webpack_require__(/*! ../../errors */ "./node_modules/capnp-ts/lib/errors.js");
var trace = debug_1.default("capnp:pointer");
trace("load");
/**
 * A pointer referencing a single byte location in a segment. This is typically used for Cap'n Proto pointers, but is
 * also sometimes used to reference an offset to a pointer's content or tag words.
 *
 * @export
 * @class Pointer
 */
var Pointer = /** @class */ (function () {
    function Pointer(segment, byteOffset, depthLimit) {
        if (depthLimit === void 0) { depthLimit = constants_1.MAX_DEPTH; }
        this._capnp = { compositeList: false, depthLimit: depthLimit };
        this.segment = segment;
        this.byteOffset = byteOffset;
        if (depthLimit === 0) {
            throw new Error(util_1.format(errors_1.PTR_DEPTH_LIMIT_EXCEEDED, this));
        }
        // Make sure we keep track of all pointer allocations; there's a limit per message (prevent DoS).
        trackPointerAllocation(segment.message, this);
        // NOTE: It's okay to have a pointer to the end of the segment; you'll see this when creating pointers to the
        // beginning of the content of a newly-allocated composite list with zero elements. Unlike other language
        // implementations buffer over/underflows are not a big issue since all buffer access is bounds checked in native
        // code anyway.
        if (byteOffset < 0 || byteOffset > segment.byteLength) {
            throw new Error(util_1.format(errors_1.PTR_OFFSET_OUT_OF_BOUNDS, byteOffset));
        }
        trace("new %s", this);
    }
    Pointer.prototype.toString = function () {
        return util_1.format("Pointer_%d@%a,%s,limit:%x", this.segment.id, this.byteOffset, dump(this), this._capnp.depthLimit);
    };
    Pointer.adopt = adopt;
    Pointer.copyFrom = copyFrom;
    Pointer.disown = disown;
    Pointer.dump = dump;
    Pointer.isNull = isNull;
    Pointer._capnp = {
        displayName: "Pointer"
    };
    return Pointer;
}());
exports.Pointer = Pointer;
/**
 * Adopt an orphaned pointer, making the pointer point to the orphaned content without copying it.
 *
 * @param {Orphan<Pointer>} src The orphan to adopt.
 * @param {Pointer} p The the pointer to adopt into.
 * @returns {void}
 */
function adopt(src, p) {
    src._moveTo(p);
}
exports.adopt = adopt;
/**
 * Convert a pointer to an Orphan, zeroing out the pointer and leaving its content untouched. If the content is no
 * longer needed, call `disown()` on the orphaned pointer to erase the contents as well.
 *
 * Call `adopt()` on the orphan with the new target pointer location to move it back into the message; the orphan
 * object is then invalidated after adoption (can only adopt once!).
 *
 * @param {T} p The pointer to turn into an Orphan.
 * @returns {Orphan<T>} An orphaned pointer.
 */
function disown(p) {
    return new orphan_1.Orphan(p);
}
exports.disown = disown;
function dump(p) {
    return util_1.bufferToHex(p.segment.buffer.slice(p.byteOffset, p.byteOffset + 8));
}
exports.dump = dump;
/**
 * Get the total number of bytes required to hold a list of the provided size with the given length, rounded up to the
 * nearest word.
 *
 * @param {ListElementSize} elementSize A number describing the size of the list elements.
 * @param {number} length The length of the list.
 * @param {ObjectSize} [compositeSize] The size of each element in a composite list; required if
 * `elementSize === ListElementSize.COMPOSITE`.
 * @returns {number} The number of bytes required to hold an element of that size, or `NaN` if that is undefined.
 */
function getListByteLength(elementSize, length, compositeSize) {
    switch (elementSize) {
        case list_element_size_1.ListElementSize.BIT:
            return util_1.padToWord((length + 7) >>> 3);
        case list_element_size_1.ListElementSize.BYTE:
        case list_element_size_1.ListElementSize.BYTE_2:
        case list_element_size_1.ListElementSize.BYTE_4:
        case list_element_size_1.ListElementSize.BYTE_8:
        case list_element_size_1.ListElementSize.POINTER:
        case list_element_size_1.ListElementSize.VOID:
            return util_1.padToWord(getListElementByteLength(elementSize) * length);
        /* istanbul ignore next */
        case list_element_size_1.ListElementSize.COMPOSITE:
            if (compositeSize === undefined) {
                throw new Error(util_1.format(errors_1.PTR_INVALID_LIST_SIZE, NaN));
            }
            return length * util_1.padToWord(object_size_1.getByteLength(compositeSize));
        /* istanbul ignore next */
        default:
            throw new Error(errors_1.PTR_INVALID_LIST_SIZE);
    }
}
exports.getListByteLength = getListByteLength;
/**
 * Get the number of bytes required to hold a list element of the provided size. `COMPOSITE` elements do not have a
 * fixed size, and `BIT` elements are packed into exactly a single bit, so these both return `NaN`.
 *
 * @param {ListElementSize} elementSize A number describing the size of the list elements.
 * @returns {number} The number of bytes required to hold an element of that size, or `NaN` if that is undefined.
 */
function getListElementByteLength(elementSize) {
    switch (elementSize) {
        /* istanbul ignore next */
        case list_element_size_1.ListElementSize.BIT:
            return NaN;
        case list_element_size_1.ListElementSize.BYTE:
            return 1;
        case list_element_size_1.ListElementSize.BYTE_2:
            return 2;
        case list_element_size_1.ListElementSize.BYTE_4:
            return 4;
        case list_element_size_1.ListElementSize.BYTE_8:
        case list_element_size_1.ListElementSize.POINTER:
            return 8;
        /* istanbul ignore next */
        case list_element_size_1.ListElementSize.COMPOSITE:
            // Caller has to figure it out based on the tag word.
            return NaN;
        /* istanbul ignore next */
        case list_element_size_1.ListElementSize.VOID:
            return 0;
        /* istanbul ignore next */
        default:
            throw new Error(util_1.format(errors_1.PTR_INVALID_LIST_SIZE, elementSize));
    }
}
exports.getListElementByteLength = getListElementByteLength;
/**
 * Add an offset to the pointer's offset and return a new Pointer for that address.
 *
 * @param {number} offset The number of bytes to add to the offset.
 * @param {Pointer} p The pointer to add from.
 * @returns {Pointer} A new pointer to the address.
 */
function add(offset, p) {
    return new Pointer(p.segment, p.byteOffset + offset, p._capnp.depthLimit);
}
exports.add = add;
/**
 * Replace a pointer with a deep copy of the pointer at `src` and all of its contents.
 *
 * @param {Pointer} src The pointer to copy.
 * @param {Pointer} p The pointer to copy into.
 * @returns {void}
 */
function copyFrom(src, p) {
    // If the pointer is the same then this is a noop.
    if (p.segment === src.segment && p.byteOffset === src.byteOffset) {
        trace("ignoring copy operation from identical pointer %s", src);
        return;
    }
    // Make sure we erase this pointer's contents before moving on. If src is null, that's all we do.
    erase(p); // noop if null
    if (isNull(src))
        return;
    switch (getTargetPointerType(src)) {
        case pointer_type_1.PointerType.STRUCT:
            copyFromStruct(src, p);
            break;
        case pointer_type_1.PointerType.LIST:
            copyFromList(src, p);
            break;
        /* istanbul ignore next */
        default:
            throw new Error(util_1.format(errors_1.PTR_INVALID_POINTER_TYPE, getTargetPointerType(p)));
    }
}
exports.copyFrom = copyFrom;
/**
 * Recursively erase a pointer, any far pointers/landing pads/tag words, and the content it points to.
 *
 * Note that this will leave "holes" of zeroes in the message, since the space cannot be reclaimed. With packing this
 * will have a negligible effect on the final message size.
 *
 * FIXME: This may need protection against infinite recursion...
 *
 * @param {Pointer} p The pointer to erase.
 * @returns {void}
 */
function erase(p) {
    if (isNull(p))
        return;
    // First deal with the contents.
    var c;
    switch (getTargetPointerType(p)) {
        case pointer_type_1.PointerType.STRUCT:
            var size = getTargetStructSize(p);
            c = getContent(p);
            // Wipe the data section.
            c.segment.fillZeroWords(c.byteOffset, size.dataByteLength / 8);
            // Iterate over all the pointers and nuke them.
            for (var i = 0; i < size.pointerLength; i++) {
                erase(add(i * 8, c));
            }
            break;
        case pointer_type_1.PointerType.LIST:
            var elementSize = getTargetListElementSize(p);
            var length = getTargetListLength(p);
            var contentWords = util_1.padToWord(length * getListElementByteLength(elementSize));
            c = getContent(p);
            if (elementSize === list_element_size_1.ListElementSize.POINTER) {
                for (var i = 0; i < length; i++) {
                    erase(new Pointer(c.segment, c.byteOffset + i * 8, p._capnp.depthLimit - 1));
                }
                // Calling erase on each pointer takes care of the content, nothing left to do here.
                break;
            }
            else if (elementSize === list_element_size_1.ListElementSize.COMPOSITE) {
                // Read some stuff from the tag word.
                var tag = add(-8, c);
                var compositeSize = getStructSize(tag);
                var compositeByteLength = object_size_1.getByteLength(compositeSize);
                contentWords = getOffsetWords(tag);
                // Kill the tag word.
                c.segment.setWordZero(c.byteOffset - 8);
                // Recursively erase each pointer.
                for (var i = 0; i < length; i++) {
                    for (var j = 0; j < compositeSize.pointerLength; j++) {
                        erase(new Pointer(c.segment, c.byteOffset + i * compositeByteLength + j * 8, p._capnp.depthLimit - 1));
                    }
                }
            }
            c.segment.fillZeroWords(c.byteOffset, contentWords);
            break;
        case pointer_type_1.PointerType.OTHER:
            // No content.
            break;
        default:
            throw new Error(util_1.format(errors_1.PTR_INVALID_POINTER_TYPE, getTargetPointerType(p)));
    }
    erasePointer(p);
}
exports.erase = erase;
/**
 * Set the pointer (and far pointer landing pads, if applicable) to zero. Does not touch the pointer's content.
 *
 * @param {Pointer} p The pointer to erase.
 * @returns {void}
 */
function erasePointer(p) {
    if (getPointerType(p) === pointer_type_1.PointerType.FAR) {
        var landingPad = followFar(p);
        if (isDoubleFar(p)) {
            // Kill the double-far tag word.
            landingPad.segment.setWordZero(landingPad.byteOffset + 8);
        }
        // Kill the landing pad.
        landingPad.segment.setWordZero(landingPad.byteOffset);
    }
    // Finally! Kill the pointer itself...
    p.segment.setWordZero(p.byteOffset);
}
exports.erasePointer = erasePointer;
/**
 * Interpret the pointer as a far pointer, returning its target segment and offset.
 *
 * @param {Pointer} p The pointer to read from.
 * @returns {Pointer} A pointer to the far target.
 */
function followFar(p) {
    var targetSegment = p.segment.message.getSegment(p.segment.getUint32(p.byteOffset + 4));
    var targetWordOffset = p.segment.getUint32(p.byteOffset) >>> 3;
    return new Pointer(targetSegment, targetWordOffset * 8, p._capnp.depthLimit - 1);
}
exports.followFar = followFar;
/**
 * If the pointer address references a far pointer, follow it to the location where the actual pointer data is written.
 * Otherwise, returns the pointer unmodified.
 *
 * @param {Pointer} p The pointer to read from.
 * @returns {Pointer} A new pointer representing the target location, or `p` if it is not a far pointer.
 */
function followFars(p) {
    if (getPointerType(p) === pointer_type_1.PointerType.FAR) {
        var landingPad = followFar(p);
        if (isDoubleFar(p))
            landingPad.byteOffset += 8;
        return landingPad;
    }
    return p;
}
exports.followFars = followFars;
function getCapabilityId(p) {
    return p.segment.getUint32(p.byteOffset + 4);
}
exports.getCapabilityId = getCapabilityId;
function isCompositeList(p) {
    return (getTargetPointerType(p) === pointer_type_1.PointerType.LIST &&
        getTargetListElementSize(p) === list_element_size_1.ListElementSize.COMPOSITE);
}
/**
 * Obtain the location of the pointer's content, following far pointers as needed.
 * If the pointer is a struct pointer and `compositeIndex` is set, it will be offset by a multiple of the struct's size.
 *
 * @param {Pointer} p The pointer to read from.
 * @param {boolean} [ignoreCompositeIndex] If true, will not follow the composite struct pointer's composite index and
 * instead return a pointer to the parent list's contents (also the beginning of the first struct).
 * @returns {Pointer} A pointer to the beginning of the pointer's content.
 */
function getContent(p, ignoreCompositeIndex) {
    var c;
    if (isDoubleFar(p)) {
        var landingPad = followFar(p);
        c = new Pointer(p.segment.message.getSegment(getFarSegmentId(landingPad)), getOffsetWords(landingPad) * 8);
    }
    else {
        var target = followFars(p);
        c = new Pointer(target.segment, target.byteOffset + 8 + getOffsetWords(target) * 8);
    }
    if (isCompositeList(p))
        c.byteOffset += 8;
    if (!ignoreCompositeIndex && p._capnp.compositeIndex !== undefined) {
        // Seek backwards by one word so we can read the struct size off the tag word.
        c.byteOffset -= 8;
        // Seek ahead by `compositeIndex` multiples of the struct's total size.
        c.byteOffset +=
            8 +
                p._capnp.compositeIndex *
                    object_size_1.getByteLength(object_size_1.padToWord(getStructSize(c)));
    }
    return c;
}
exports.getContent = getContent;
/**
 * Read the target segment ID from a far pointer.
 *
 * @param {Pointer} p The pointer to read from.
 * @returns {number} The target segment ID.
 */
function getFarSegmentId(p) {
    return p.segment.getUint32(p.byteOffset + 4);
}
exports.getFarSegmentId = getFarSegmentId;
/**
 * Get a number indicating the size of the list's elements.
 *
 * @param {Pointer} p The pointer to read from.
 * @returns {ListElementSize} The size of the list's elements.
 */
function getListElementSize(p) {
    return p.segment.getUint32(p.byteOffset + 4) & constants_1.LIST_SIZE_MASK;
}
exports.getListElementSize = getListElementSize;
/**
 * Get the number of elements in a list pointer. For composite lists, it instead represents the total number of words in
 * the list (not counting the tag word).
 *
 * This method does **not** attempt to distinguish between composite and non-composite lists. To get the correct
 * length for composite lists use `getTargetListLength()` instead.
 *
 * @param {Pointer} p The pointer to read from.
 * @returns {number} The length of the list, or total number of words for composite lists.
 */
function getListLength(p) {
    return p.segment.getUint32(p.byteOffset + 4) >>> 3;
}
exports.getListLength = getListLength;
/**
 * Get the offset (in words) from the end of a pointer to the start of its content. For struct pointers, this is the
 * beginning of the data section, and for list pointers it is the location of the first element. The value should
 * always be zero for interface pointers.
 *
 * @param {Pointer} p The pointer to read from.
 * @returns {number} The offset, in words, from the end of the pointer to the start of the data section.
 */
function getOffsetWords(p) {
    var o = p.segment.getInt32(p.byteOffset);
    // Far pointers only have 29 offset bits.
    return o & 2 ? o >> 3 : o >> 2;
}
exports.getOffsetWords = getOffsetWords;
/**
 * Look up the pointer's type.
 *
 * @param {Pointer} p The pointer to read from.
 * @returns {PointerType} The type of pointer.
 */
function getPointerType(p) {
    return p.segment.getUint32(p.byteOffset) & constants_1.POINTER_TYPE_MASK;
}
exports.getPointerType = getPointerType;
/**
 * Read the number of data words from this struct pointer.
 *
 * @param {Pointer} p The pointer to read from.
 * @returns {number} The number of data words in the struct.
 */
function getStructDataWords(p) {
    return p.segment.getUint16(p.byteOffset + 4);
}
exports.getStructDataWords = getStructDataWords;
/**
 * Read the number of pointers contained in this struct pointer.
 *
 * @param {Pointer} p The pointer to read from.
 * @returns {number} The number of pointers in this struct.
 */
function getStructPointerLength(p) {
    return p.segment.getUint16(p.byteOffset + 6);
}
exports.getStructPointerLength = getStructPointerLength;
/**
 * Get an object describing this struct pointer's size.
 *
 * @param {Pointer} p The pointer to read from.
 * @returns {ObjectSize} The size of the struct.
 */
function getStructSize(p) {
    return new object_size_1.ObjectSize(getStructDataWords(p) * 8, getStructPointerLength(p));
}
exports.getStructSize = getStructSize;
/**
 * Get a pointer to this pointer's composite list tag word, following far pointers as needed.
 *
 * @param {Pointer} p The pointer to read from.
 * @returns {Pointer} A pointer to the list's composite tag word.
 */
function getTargetCompositeListTag(p) {
    var c = getContent(p);
    // The composite list tag is always one word before the content.
    c.byteOffset -= 8;
    return c;
}
exports.getTargetCompositeListTag = getTargetCompositeListTag;
/**
 * Get the object size for the target composite list, following far pointers as needed.
 *
 * @param {Pointer} p The pointer to read from.
 * @returns {ObjectSize} An object describing the size of each struct in the list.
 */
function getTargetCompositeListSize(p) {
    return getStructSize(getTargetCompositeListTag(p));
}
exports.getTargetCompositeListSize = getTargetCompositeListSize;
/**
 * Get the size of the list elements referenced by this pointer, following far pointers if necessary.
 *
 * @param {Pointer} p The pointer to read from.
 * @returns {ListElementSize} The size of the elements in the list.
 */
function getTargetListElementSize(p) {
    return getListElementSize(followFars(p));
}
exports.getTargetListElementSize = getTargetListElementSize;
/**
 * Get the length of the list referenced by this pointer, following far pointers if necessary. If the list is a
 * composite list, it will look up the tag word and read the length from there.
 *
 * @param {Pointer} p The pointer to read from.
 * @returns {number} The number of elements in the list.
 */
function getTargetListLength(p) {
    var t = followFars(p);
    if (getListElementSize(t) === list_element_size_1.ListElementSize.COMPOSITE) {
        // The content is prefixed by a tag word; it's a struct pointer whose offset contains the list's length.
        return getOffsetWords(getTargetCompositeListTag(p));
    }
    return getListLength(t);
}
exports.getTargetListLength = getTargetListLength;
/**
 * Get the type of a pointer, following far pointers if necessary. For non-far pointers this is equivalent to calling
 * `getPointerType()`.
 *
 * The target of a far pointer can never be another far pointer, and this method will throw if such a situation is
 * encountered.
 *
 * @param {Pointer} p The pointer to read from.
 * @returns {PointerType} The type of pointer referenced by this pointer.
 */
function getTargetPointerType(p) {
    var t = getPointerType(followFars(p));
    if (t === pointer_type_1.PointerType.FAR)
        throw new Error(util_1.format(errors_1.PTR_INVALID_FAR_TARGET, p));
    return t;
}
exports.getTargetPointerType = getTargetPointerType;
/**
 * Get the size of the struct referenced by a pointer, following far pointers if necessary.
 *
 * @param {Pointer} p The poiner to read from.
 * @returns {ObjectSize} The size of the struct referenced by this pointer.
 */
function getTargetStructSize(p) {
    return getStructSize(followFars(p));
}
exports.getTargetStructSize = getTargetStructSize;
/**
 * Initialize a pointer to point at the data in the content segment. If the content segment is not the same as the
 * pointer's segment, this will allocate and write far pointers as needed. Nothing is written otherwise.
 *
 * The return value includes a pointer to write the pointer's actual data to (the eventual far target), and the offset
 * value (in words) to use for that pointer. In the case of double-far pointers this offset will always be zero.
 *
 * @param {Segment} contentSegment The segment containing this pointer's content.
 * @param {number} contentOffset The offset within the content segment for the beginning of this pointer's content.
 * @param {Pointer} p The pointer to initialize.
 * @returns {PointerAllocationResult} An object containing a pointer (where the pointer data should be written), and
 * the value to use as the offset for that pointer.
 */
function initPointer(contentSegment, contentOffset, p) {
    if (p.segment !== contentSegment) {
        // Need a far pointer.
        trace("Initializing far pointer %s -> %s.", p, contentSegment);
        if (!contentSegment.hasCapacity(8)) {
            // GAH! Not enough space in the content segment for a landing pad so we need a double far pointer.
            var landingPad_1 = p.segment.allocate(16);
            trace("GAH! Initializing double-far pointer in %s from %s -> %s.", p, contentSegment, landingPad_1);
            setFarPointer(true, landingPad_1.byteOffset / 8, landingPad_1.segment.id, p);
            setFarPointer(false, contentOffset / 8, contentSegment.id, landingPad_1);
            landingPad_1.byteOffset += 8;
            return new pointer_allocation_result_1.PointerAllocationResult(landingPad_1, 0);
        }
        // Allocate a far pointer landing pad in the target segment.
        var landingPad = contentSegment.allocate(8);
        if (landingPad.segment.id !== contentSegment.id) {
            throw new Error(errors_1.INVARIANT_UNREACHABLE_CODE);
        }
        setFarPointer(false, landingPad.byteOffset / 8, landingPad.segment.id, p);
        return new pointer_allocation_result_1.PointerAllocationResult(landingPad, (contentOffset - landingPad.byteOffset - 8) / 8);
    }
    trace("Initializing intra-segment pointer %s -> %a.", p, contentOffset);
    return new pointer_allocation_result_1.PointerAllocationResult(p, (contentOffset - p.byteOffset - 8) / 8);
}
exports.initPointer = initPointer;
/**
 * Check if the pointer is a double-far pointer.
 *
 * @param {Pointer} p The pointer to read from.
 * @returns {boolean} `true` if it is a double-far pointer, `false` otherwise.
 */
function isDoubleFar(p) {
    return (getPointerType(p) === pointer_type_1.PointerType.FAR &&
        (p.segment.getUint32(p.byteOffset) & constants_1.POINTER_DOUBLE_FAR_MASK) !== 0);
}
exports.isDoubleFar = isDoubleFar;
/**
 * Quickly check to see if the pointer is "null". A "null" pointer is a zero word, equivalent to an empty struct
 * pointer.
 *
 * @param {Pointer} p The pointer to read from.
 * @returns {boolean} `true` if the pointer is "null".
 */
function isNull(p) {
    return p.segment.isWordZero(p.byteOffset);
}
exports.isNull = isNull;
/**
 * Relocate a pointer to the given destination, ensuring that it points to the same content. This will create far
 * pointers as needed if the content is in a different segment than the destination. After the relocation the source
 * pointer will be erased and is no longer valid.
 *
 * @param {Pointer} dst The desired location for the `src` pointer. Any existing contents will be erased before
 * relocating!
 * @param {Pointer} src The pointer to relocate.
 * @returns {void}
 */
function relocateTo(dst, src) {
    var t = followFars(src);
    var lo = t.segment.getUint8(t.byteOffset) & 0x03; // discard the offset
    var hi = t.segment.getUint32(t.byteOffset + 4);
    // Make sure anything dst was pointing to is wiped out.
    erase(dst);
    var res = initPointer(t.segment, t.byteOffset + 8 + getOffsetWords(t) * 8, dst);
    // Keep the low 2 bits and write the new offset.
    res.pointer.segment.setUint32(res.pointer.byteOffset, lo | (res.offsetWords << 2));
    // Keep the high 32 bits intact.
    res.pointer.segment.setUint32(res.pointer.byteOffset + 4, hi);
    erasePointer(src);
}
exports.relocateTo = relocateTo;
/**
 * Write a far pointer.
 *
 * @param {boolean} doubleFar Set to `true` if this is a double far pointer.
 * @param {number} offsetWords The offset, in words, to the target pointer.
 * @param {number} segmentId The segment the target pointer is located in.
 * @param {Pointer} p The pointer to write to.
 * @returns {void}
 */
function setFarPointer(doubleFar, offsetWords, segmentId, p) {
    var A = pointer_type_1.PointerType.FAR;
    var B = doubleFar ? 1 : 0;
    var C = offsetWords;
    var D = segmentId;
    p.segment.setUint32(p.byteOffset, A | (B << 2) | (C << 3));
    p.segment.setUint32(p.byteOffset + 4, D);
}
exports.setFarPointer = setFarPointer;
/**
 * Write a raw interface pointer.
 *
 * @param {number} capId The capability ID.
 * @param {Pointer} p The pointer to write to.
 * @returns {void}
 */
function setInterfacePointer(capId, p) {
    p.segment.setUint32(p.byteOffset, pointer_type_1.PointerType.OTHER);
    p.segment.setUint32(p.byteOffset + 4, capId);
}
exports.setInterfacePointer = setInterfacePointer;
/**
 * Write a raw list pointer.
 *
 * @param {number} offsetWords The number of words from the end of this pointer to the beginning of the list content.
 * @param {ListElementSize} size The size of each element in the list.
 * @param {number} length The number of elements in the list.
 * @param {Pointer} p The pointer to write to.
 * @param {ObjectSize} [compositeSize] For composite lists this describes the size of each element in this list. This
 * is required for composite lists.
 * @returns {void}
 */
function setListPointer(offsetWords, size, length, p, compositeSize) {
    var A = pointer_type_1.PointerType.LIST;
    var B = offsetWords;
    var C = size;
    var D = length;
    if (size === list_element_size_1.ListElementSize.COMPOSITE) {
        if (compositeSize === undefined) {
            throw new TypeError(errors_1.TYPE_COMPOSITE_SIZE_UNDEFINED);
        }
        D *= object_size_1.getWordLength(compositeSize);
    }
    p.segment.setUint32(p.byteOffset, A | (B << 2));
    p.segment.setUint32(p.byteOffset + 4, C | (D << 3));
}
exports.setListPointer = setListPointer;
/**
 * Write a raw struct pointer.
 *
 * @param {number} offsetWords The number of words from the end of this pointer to the beginning of the struct's data
 * section.
 * @param {ObjectSize} size An object describing the size of the struct.
 * @param {Pointer} p The pointer to write to.
 * @returns {void}
 */
function setStructPointer(offsetWords, size, p) {
    var A = pointer_type_1.PointerType.STRUCT;
    var B = offsetWords;
    var C = object_size_1.getDataWordLength(size);
    var D = size.pointerLength;
    p.segment.setUint32(p.byteOffset, A | (B << 2));
    p.segment.setUint16(p.byteOffset + 4, C);
    p.segment.setUint16(p.byteOffset + 6, D);
}
exports.setStructPointer = setStructPointer;
/**
 * Read some bits off a pointer to make sure it has the right pointer data.
 *
 * @param {PointerType} pointerType The expected pointer type.
 * @param {Pointer} p The pointer to validate.
 * @param {ListElementSize} [elementSize] For list pointers, the expected element size. Leave this
 * undefined for struct pointers.
 * @returns {void}
 */
function validate(pointerType, p, elementSize) {
    if (isNull(p))
        return;
    var t = followFars(p);
    // Check the pointer type.
    var A = t.segment.getUint32(t.byteOffset) & constants_1.POINTER_TYPE_MASK;
    if (A !== pointerType) {
        throw new Error(util_1.format(errors_1.PTR_WRONG_POINTER_TYPE, p, pointerType));
    }
    // Check the list element size, if provided.
    if (elementSize !== undefined) {
        var C = t.segment.getUint32(t.byteOffset + 4) & constants_1.LIST_SIZE_MASK;
        if (C !== elementSize) {
            throw new Error(util_1.format(errors_1.PTR_WRONG_LIST_TYPE, p, list_element_size_1.ListElementSize[elementSize]));
        }
    }
}
exports.validate = validate;
function copyFromList(src, dst) {
    if (dst._capnp.depthLimit <= 0)
        throw new Error(errors_1.PTR_DEPTH_LIMIT_EXCEEDED);
    var srcContent = getContent(src);
    var srcElementSize = getTargetListElementSize(src);
    var srcLength = getTargetListLength(src);
    var srcCompositeSize;
    var srcStructByteLength;
    var dstContent;
    if (srcElementSize === list_element_size_1.ListElementSize.POINTER) {
        dstContent = dst.segment.allocate(srcLength << 3);
        // Recursively copy each pointer in the list.
        for (var i = 0; i < srcLength; i++) {
            var srcPtr = new Pointer(srcContent.segment, srcContent.byteOffset + (i << 3), src._capnp.depthLimit - 1);
            var dstPtr = new Pointer(dstContent.segment, dstContent.byteOffset + (i << 3), dst._capnp.depthLimit - 1);
            copyFrom(srcPtr, dstPtr);
        }
    }
    else if (srcElementSize === list_element_size_1.ListElementSize.COMPOSITE) {
        srcCompositeSize = object_size_1.padToWord(getTargetCompositeListSize(src));
        srcStructByteLength = object_size_1.getByteLength(srcCompositeSize);
        dstContent = dst.segment.allocate(object_size_1.getByteLength(srcCompositeSize) * srcLength + 8);
        // Copy the tag word.
        dstContent.segment.copyWord(dstContent.byteOffset, srcContent.segment, srcContent.byteOffset - 8);
        // Copy the entire contents, including all pointers. This should be more efficient than making `srcLength`
        // copies to skip the pointer sections, and we're about to rewrite all those pointers anyway.
        // PERF: Skip this step if the composite struct only contains pointers.
        if (srcCompositeSize.dataByteLength > 0) {
            var wordLength = object_size_1.getWordLength(srcCompositeSize) * srcLength;
            dstContent.segment.copyWords(dstContent.byteOffset + 8, srcContent.segment, srcContent.byteOffset, wordLength);
        }
        // Recursively copy all the pointers in each struct.
        for (var i = 0; i < srcLength; i++) {
            for (var j = 0; j < srcCompositeSize.pointerLength; j++) {
                var offset = i * srcStructByteLength + srcCompositeSize.dataByteLength + (j << 3);
                var srcPtr = new Pointer(srcContent.segment, srcContent.byteOffset + offset, src._capnp.depthLimit - 1);
                var dstPtr = new Pointer(dstContent.segment, dstContent.byteOffset + offset + 8, dst._capnp.depthLimit - 1);
                copyFrom(srcPtr, dstPtr);
            }
        }
    }
    else {
        var byteLength = util_1.padToWord(srcElementSize === list_element_size_1.ListElementSize.BIT
            ? (srcLength + 7) >>> 3
            : getListElementByteLength(srcElementSize) * srcLength);
        var wordLength = byteLength >>> 3;
        dstContent = dst.segment.allocate(byteLength);
        // Copy all of the list contents word-by-word.
        dstContent.segment.copyWords(dstContent.byteOffset, srcContent.segment, srcContent.byteOffset, wordLength);
    }
    // Initialize the list pointer.
    var res = initPointer(dstContent.segment, dstContent.byteOffset, dst);
    setListPointer(res.offsetWords, srcElementSize, srcLength, res.pointer, srcCompositeSize);
}
exports.copyFromList = copyFromList;
function copyFromStruct(src, dst) {
    if (dst._capnp.depthLimit <= 0)
        throw new Error(errors_1.PTR_DEPTH_LIMIT_EXCEEDED);
    var srcContent = getContent(src);
    var srcSize = getTargetStructSize(src);
    var srcDataWordLength = object_size_1.getDataWordLength(srcSize);
    // Allocate space for the destination content.
    var dstContent = dst.segment.allocate(object_size_1.getByteLength(srcSize));
    // Copy the data section.
    dstContent.segment.copyWords(dstContent.byteOffset, srcContent.segment, srcContent.byteOffset, srcDataWordLength);
    // Copy the pointer section.
    for (var i = 0; i < srcSize.pointerLength; i++) {
        var offset = srcSize.dataByteLength + i * 8;
        var srcPtr = new Pointer(srcContent.segment, srcContent.byteOffset + offset, src._capnp.depthLimit - 1);
        var dstPtr = new Pointer(dstContent.segment, dstContent.byteOffset + offset, dst._capnp.depthLimit - 1);
        copyFrom(srcPtr, dstPtr);
    }
    // Don't touch dst if it's already initialized as a composite list pointer. With composite struct pointers there's
    // no pointer to copy here and we've already copied the contents.
    if (dst._capnp.compositeList)
        return;
    // Initialize the struct pointer.
    var res = initPointer(dstContent.segment, dstContent.byteOffset, dst);
    setStructPointer(res.offsetWords, srcSize, res.pointer);
}
exports.copyFromStruct = copyFromStruct;
/**
 * Track the allocation of a new Pointer object.
 *
 * This will decrement an internal counter tracking how many bytes have been traversed in the message so far. After
 * a certain limit, this method will throw an error in order to prevent a certain class of DoS attacks.
 *
 * @param {Message} message The message the pointer belongs to.
 * @param {Pointer} p The pointer being allocated.
 * @returns {void}
 */
function trackPointerAllocation(message, p) {
    message._capnp.traversalLimit -= 8;
    if (message._capnp.traversalLimit <= 0) {
        throw new Error(util_1.format(errors_1.PTR_TRAVERSAL_LIMIT_EXCEEDED, p));
    }
}
exports.trackPointerAllocation = trackPointerAllocation;

//# sourceMappingURL=pointer.js.map


/***/ }),

/***/ "./node_modules/capnp-ts/lib/serialization/pointers/struct.js":
/*!********************************************************************!*\
  !*** ./node_modules/capnp-ts/lib/serialization/pointers/struct.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @author jdiaz5513
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var debug_1 = __webpack_require__(/*! debug */ "./node_modules/capnp-ts/node_modules/debug/src/browser.js");
var constants_1 = __webpack_require__(/*! ../../constants */ "./node_modules/capnp-ts/lib/constants.js");
var types_1 = __webpack_require__(/*! ../../types */ "./node_modules/capnp-ts/lib/types/index.js");
var util_1 = __webpack_require__(/*! ../../util */ "./node_modules/capnp-ts/lib/util.js");
var list_element_size_1 = __webpack_require__(/*! ../list-element-size */ "./node_modules/capnp-ts/lib/serialization/list-element-size.js");
var object_size_1 = __webpack_require__(/*! ../object-size */ "./node_modules/capnp-ts/lib/serialization/object-size.js");
var data_1 = __webpack_require__(/*! ./data */ "./node_modules/capnp-ts/lib/serialization/pointers/data.js");
var list_1 = __webpack_require__(/*! ./list */ "./node_modules/capnp-ts/lib/serialization/pointers/list.js");
var pointer_1 = __webpack_require__(/*! ./pointer */ "./node_modules/capnp-ts/lib/serialization/pointers/pointer.js");
var pointer_type_1 = __webpack_require__(/*! ./pointer-type */ "./node_modules/capnp-ts/lib/serialization/pointers/pointer-type.js");
var text_1 = __webpack_require__(/*! ./text */ "./node_modules/capnp-ts/lib/serialization/pointers/text.js");
var errors_1 = __webpack_require__(/*! ../../errors */ "./node_modules/capnp-ts/lib/errors.js");
var trace = debug_1.default("capnp:struct");
trace("load");
// Used to apply bit masks (default values).
var TMP_WORD = new DataView(new ArrayBuffer(8));
var Struct = /** @class */ (function (_super) {
    tslib_1.__extends(Struct, _super);
    /**
     * Create a new pointer to a struct.
     *
     * @constructor {Struct}
     * @param {Segment} segment The segment the pointer resides in.
     * @param {number} byteOffset The offset from the beginning of the segment to the beginning of the pointer data.
     * @param {any} [depthLimit=MAX_DEPTH] The nesting depth limit for this object.
     * @param {number} [compositeIndex] If set, then this pointer is actually a reference to a composite list
     * (`this._getPointerTargetType() === PointerType.LIST`), and this number is used as the index of the struct within
     * the list. It is not valid to call `initStruct()` on a composite struct – the struct contents are initialized when
     * the list pointer is initialized.
     */
    function Struct(segment, byteOffset, depthLimit, compositeIndex) {
        if (depthLimit === void 0) { depthLimit = constants_1.MAX_DEPTH; }
        var _this = _super.call(this, segment, byteOffset, depthLimit) || this;
        _this._capnp.compositeIndex = compositeIndex;
        _this._capnp.compositeList = compositeIndex !== undefined;
        return _this;
    }
    Struct.toString = function () {
        return this._capnp.displayName;
    };
    Struct.prototype.toString = function () {
        return ("Struct_" + _super.prototype.toString.call(this) +
            ("" + (this._capnp.compositeIndex === undefined
                ? ""
                : ",ci:" + this._capnp.compositeIndex)));
    };
    Struct._capnp = {
        displayName: "Struct"
    };
    Struct.getAs = getAs;
    Struct.getBit = getBit;
    Struct.getData = getData;
    Struct.getFloat32 = getFloat32;
    Struct.getFloat64 = getFloat64;
    Struct.getUint8 = getUint8;
    Struct.getUint16 = getUint16;
    Struct.getUint32 = getUint32;
    Struct.getUint64 = getUint64;
    Struct.getInt8 = getInt8;
    Struct.getInt16 = getInt16;
    Struct.getInt32 = getInt32;
    Struct.getInt64 = getInt64;
    Struct.getList = getList;
    Struct.getPointer = getPointer;
    Struct.getPointerAs = getPointerAs;
    Struct.getStruct = getStruct;
    Struct.getText = getText;
    Struct.initData = initData;
    Struct.initList = initList;
    Struct.initStruct = initStruct;
    Struct.initStructAt = initStructAt;
    Struct.setBit = setBit;
    Struct.setFloat32 = setFloat32;
    Struct.setFloat64 = setFloat64;
    Struct.setUint8 = setUint8;
    Struct.setUint16 = setUint16;
    Struct.setUint32 = setUint32;
    Struct.setUint64 = setUint64;
    Struct.setInt8 = setInt8;
    Struct.setInt16 = setInt16;
    Struct.setInt32 = setInt32;
    Struct.setInt64 = setInt64;
    Struct.setText = setText;
    Struct.testWhich = testWhich;
    return Struct;
}(pointer_1.Pointer));
exports.Struct = Struct;
/**
 * Initialize a struct with the provided object size. This will allocate new space for the struct contents, ideally in
 * the same segment as this pointer.
 *
 * @param {ObjectSize} size An object describing the size of the struct's data and pointer sections.
 * @param {Struct} s The struct to initialize.
 * @returns {void}
 */
function initStruct(size, s) {
    if (s._capnp.compositeIndex !== undefined) {
        throw new Error(util_1.format(errors_1.PTR_INIT_COMPOSITE_STRUCT, s));
    }
    // Make sure to clear existing contents before overwriting the pointer data (erase is a noop if already empty).
    pointer_1.erase(s);
    var c = s.segment.allocate(object_size_1.getByteLength(size));
    var res = pointer_1.initPointer(c.segment, c.byteOffset, s);
    pointer_1.setStructPointer(res.offsetWords, size, res.pointer);
}
exports.initStruct = initStruct;
function initStructAt(index, StructClass, p) {
    var s = getPointerAs(index, StructClass, p);
    initStruct(StructClass._capnp.size, s);
    return s;
}
exports.initStructAt = initStructAt;
/**
 * Make a shallow copy of a struct's contents and update the pointer to point to the new content. The data and pointer
 * sections will be resized to the provided size.
 *
 * WARNING: This method can cause data loss if `dstSize` is smaller than the original size!
 *
 * @param {ObjectSize} dstSize The desired size for the struct contents.
 * @param {Struct} s The struct to resize.
 * @returns {void}
 */
function resize(dstSize, s) {
    var srcSize = getSize(s);
    var srcContent = pointer_1.getContent(s);
    var dstContent = s.segment.allocate(object_size_1.getByteLength(dstSize));
    // Only copy the data section for now. The pointer section will need to be rewritten.
    dstContent.segment.copyWords(dstContent.byteOffset, srcContent.segment, srcContent.byteOffset, Math.min(object_size_1.getDataWordLength(srcSize), object_size_1.getDataWordLength(dstSize)));
    var res = pointer_1.initPointer(dstContent.segment, dstContent.byteOffset, s);
    pointer_1.setStructPointer(res.offsetWords, dstSize, res.pointer);
    // Iterate through the new pointer section and update the offsets so they point to the right place. This is a bit
    // more complicated than it appears due to the fact that the original pointers could have been far pointers, and
    // the new pointers might need to be allocated as far pointers if the segment is full.
    for (var i = 0; i < Math.min(srcSize.pointerLength, dstSize.pointerLength); i++) {
        var srcPtr = new pointer_1.Pointer(srcContent.segment, srcContent.byteOffset + srcSize.dataByteLength + i * 8);
        if (pointer_1.isNull(srcPtr)) {
            // If source pointer is null, leave the destination pointer as default null.
            continue;
        }
        var srcPtrTarget = pointer_1.followFars(srcPtr);
        var srcPtrContent = pointer_1.getContent(srcPtr);
        var dstPtr = new pointer_1.Pointer(dstContent.segment, dstContent.byteOffset + dstSize.dataByteLength + i * 8);
        // For composite lists the offset needs to point to the tag word, not the first element which is what getContent
        // returns.
        if (pointer_1.getTargetPointerType(srcPtr) === pointer_type_1.PointerType.LIST &&
            pointer_1.getTargetListElementSize(srcPtr) === list_element_size_1.ListElementSize.COMPOSITE) {
            srcPtrContent.byteOffset -= 8;
        }
        var r = pointer_1.initPointer(srcPtrContent.segment, srcPtrContent.byteOffset, dstPtr);
        // Read the old pointer data, but discard the original offset.
        var a = srcPtrTarget.segment.getUint8(srcPtrTarget.byteOffset) & 0x03;
        var b = srcPtrTarget.segment.getUint32(srcPtrTarget.byteOffset + 4);
        r.pointer.segment.setUint32(r.pointer.byteOffset, a | (r.offsetWords << 2));
        r.pointer.segment.setUint32(r.pointer.byteOffset + 4, b);
    }
    // Zero out the old data and pointer sections.
    srcContent.segment.fillZeroWords(srcContent.byteOffset, object_size_1.getWordLength(srcSize));
}
exports.resize = resize;
function adopt(src, s) {
    if (s._capnp.compositeIndex !== undefined) {
        throw new Error(util_1.format(errors_1.PTR_ADOPT_COMPOSITE_STRUCT, s));
    }
    pointer_1.Pointer.adopt(src, s);
}
exports.adopt = adopt;
function disown(s) {
    if (s._capnp.compositeIndex !== undefined) {
        throw new Error(util_1.format(errors_1.PTR_DISOWN_COMPOSITE_STRUCT, s));
    }
    return pointer_1.Pointer.disown(s);
}
exports.disown = disown;
/**
 * Convert a struct to a struct of the provided class. Particularly useful when casting to nested group types.
 *
 * @protected
 * @template T
 * @param {StructCtor<T>} StructClass The struct class to convert to. Not particularly useful if `Struct`.
 * @param {Struct} s The struct to convert.
 * @returns {T} A new instance of the desired struct class pointing to the same location.
 */
function getAs(StructClass, s) {
    return new StructClass(s.segment, s.byteOffset, s._capnp.depthLimit, s._capnp.compositeIndex);
}
exports.getAs = getAs;
/**
 * Read a boolean (bit) value out of a struct.
 *
 * @protected
 * @param {number} bitOffset The offset in **bits** from the start of the data section.
 * @param {Struct} s The struct to read from.
 * @param {DataView} [defaultMask] The default value as a DataView.
 * @returns {boolean} The value.
 */
function getBit(bitOffset, s, defaultMask) {
    var byteOffset = Math.floor(bitOffset / 8);
    var bitMask = 1 << bitOffset % 8;
    checkDataBounds(byteOffset, 1, s);
    var ds = getDataSection(s);
    var v = ds.segment.getUint8(ds.byteOffset + byteOffset);
    if (defaultMask === undefined)
        return (v & bitMask) !== 0;
    var defaultValue = defaultMask.getUint8(0);
    return ((v ^ defaultValue) & bitMask) !== 0;
}
exports.getBit = getBit;
function getData(index, s, defaultValue) {
    checkPointerBounds(index, s);
    var ps = getPointerSection(s);
    ps.byteOffset += index * 8;
    var l = new data_1.Data(ps.segment, ps.byteOffset, s._capnp.depthLimit - 1);
    if (pointer_1.isNull(l)) {
        if (defaultValue) {
            pointer_1.Pointer.copyFrom(defaultValue, l);
        }
        else {
            list_1.List.initList(list_element_size_1.ListElementSize.BYTE, 0, l);
        }
    }
    return l;
}
exports.getData = getData;
function getDataSection(s) {
    return pointer_1.getContent(s);
}
exports.getDataSection = getDataSection;
/**
 * Read a float32 value out of a struct.
 *
 * @param {number} byteOffset The offset in bytes from the start of the data section.
 * @param {Struct} s The struct to read from.
 * @param {DataView} [defaultMask] The default value as a DataView.
 * @returns {number} The value.
 */
function getFloat32(byteOffset, s, defaultMask) {
    checkDataBounds(byteOffset, 4, s);
    var ds = getDataSection(s);
    if (defaultMask === undefined) {
        return ds.segment.getFloat32(ds.byteOffset + byteOffset);
    }
    var v = ds.segment.getUint32(ds.byteOffset + byteOffset) ^
        defaultMask.getUint32(0, true);
    TMP_WORD.setUint32(0, v, constants_1.NATIVE_LITTLE_ENDIAN);
    return TMP_WORD.getFloat32(0, constants_1.NATIVE_LITTLE_ENDIAN);
}
exports.getFloat32 = getFloat32;
/**
 * Read a float64 value out of this segment.
 *
 * @param {number} byteOffset The offset in bytes from the start of the data section.
 * @param {Struct} s The struct to read from.
 * @param {DataView} [defaultMask] The default value as a DataView.
 * @returns {number} The value.
 */
function getFloat64(byteOffset, s, defaultMask) {
    checkDataBounds(byteOffset, 8, s);
    var ds = getDataSection(s);
    if (defaultMask !== undefined) {
        var lo = ds.segment.getUint32(ds.byteOffset + byteOffset) ^
            defaultMask.getUint32(0, true);
        var hi = ds.segment.getUint32(ds.byteOffset + byteOffset + 4) ^
            defaultMask.getUint32(4, true);
        TMP_WORD.setUint32(0, lo, constants_1.NATIVE_LITTLE_ENDIAN);
        TMP_WORD.setUint32(4, hi, constants_1.NATIVE_LITTLE_ENDIAN);
        return TMP_WORD.getFloat64(0, constants_1.NATIVE_LITTLE_ENDIAN);
    }
    return ds.segment.getFloat64(ds.byteOffset + byteOffset);
}
exports.getFloat64 = getFloat64;
/**
 * Read an int16 value out of this segment.
 *
 * @param {number} byteOffset The offset in bytes from the start of the data section.
 * @param {Struct} s The struct to read from.
 * @param {DataView} [defaultMask] The default value as a DataView.
 * @returns {number} The value.
 */
function getInt16(byteOffset, s, defaultMask) {
    checkDataBounds(byteOffset, 2, s);
    var ds = getDataSection(s);
    if (defaultMask === undefined) {
        return ds.segment.getInt16(ds.byteOffset + byteOffset);
    }
    var v = ds.segment.getUint16(ds.byteOffset + byteOffset) ^
        defaultMask.getUint16(0, true);
    TMP_WORD.setUint16(0, v, constants_1.NATIVE_LITTLE_ENDIAN);
    return TMP_WORD.getInt16(0, constants_1.NATIVE_LITTLE_ENDIAN);
}
exports.getInt16 = getInt16;
/**
 * Read an int32 value out of this segment.
 *
 * @param {number} byteOffset The offset in bytes from the start of the data section.
 * @param {Struct} s The struct to read from.
 * @param {DataView} [defaultMask] The default value as a DataView.
 * @returns {number} The value.
 */
function getInt32(byteOffset, s, defaultMask) {
    checkDataBounds(byteOffset, 4, s);
    var ds = getDataSection(s);
    if (defaultMask === undefined) {
        return ds.segment.getInt32(ds.byteOffset + byteOffset);
    }
    var v = ds.segment.getUint32(ds.byteOffset + byteOffset) ^
        defaultMask.getUint16(0, true);
    TMP_WORD.setUint32(0, v, constants_1.NATIVE_LITTLE_ENDIAN);
    return TMP_WORD.getInt32(0, constants_1.NATIVE_LITTLE_ENDIAN);
}
exports.getInt32 = getInt32;
/**
 * Read an int64 value out of this segment.
 *
 * @param {number} byteOffset The offset in bytes from the start of the data section.
 * @param {Struct} s The struct to read from.
 * @param {DataView} [defaultMask] The default value as a DataView.
 * @returns {number} The value.
 */
function getInt64(byteOffset, s, defaultMask) {
    checkDataBounds(byteOffset, 8, s);
    var ds = getDataSection(s);
    if (defaultMask === undefined) {
        return ds.segment.getInt64(ds.byteOffset + byteOffset);
    }
    var lo = ds.segment.getUint32(ds.byteOffset + byteOffset) ^
        defaultMask.getUint32(0, true);
    var hi = ds.segment.getUint32(ds.byteOffset + byteOffset + 4) ^
        defaultMask.getUint32(4, true);
    TMP_WORD.setUint32(0, lo, constants_1.NATIVE_LITTLE_ENDIAN);
    TMP_WORD.setUint32(4, hi, constants_1.NATIVE_LITTLE_ENDIAN);
    return new types_1.Int64(new Uint8Array(TMP_WORD.buffer.slice(0)));
}
exports.getInt64 = getInt64;
/**
 * Read an int8 value out of this segment.
 *
 * @param {number} byteOffset The offset in bytes from the start of the data section.
 * @param {Struct} s The struct to read from.
 * @param {DataView} [defaultMask] The default value as a DataView.
 * @returns {number} The value.
 */
function getInt8(byteOffset, s, defaultMask) {
    checkDataBounds(byteOffset, 1, s);
    var ds = getDataSection(s);
    if (defaultMask === undefined) {
        return ds.segment.getInt8(ds.byteOffset + byteOffset);
    }
    var v = ds.segment.getUint8(ds.byteOffset + byteOffset) ^ defaultMask.getUint8(0);
    TMP_WORD.setUint8(0, v);
    return TMP_WORD.getInt8(0);
}
exports.getInt8 = getInt8;
function getList(index, ListClass, s, defaultValue) {
    checkPointerBounds(index, s);
    var ps = getPointerSection(s);
    ps.byteOffset += index * 8;
    var l = new ListClass(ps.segment, ps.byteOffset, s._capnp.depthLimit - 1);
    if (pointer_1.isNull(l)) {
        if (defaultValue) {
            pointer_1.Pointer.copyFrom(defaultValue, l);
        }
        else {
            list_1.List.initList(ListClass._capnp.size, 0, l, ListClass._capnp.compositeSize);
        }
    }
    else if (ListClass._capnp.compositeSize !== undefined) {
        // If this is a composite list we need to be sure the composite elements are big enough to hold everything as
        // specified in the schema. If the new schema has added fields we'll need to "resize" (shallow-copy) the list so
        // it has room for the new fields.
        var srcSize = pointer_1.getTargetCompositeListSize(l);
        var dstSize = ListClass._capnp.compositeSize;
        if (dstSize.dataByteLength > srcSize.dataByteLength ||
            dstSize.pointerLength > srcSize.pointerLength) {
            var srcContent = pointer_1.getContent(l);
            var srcLength = pointer_1.getTargetListLength(l);
            trace("resizing composite list %s due to protocol upgrade, new size: %d", l, object_size_1.getByteLength(dstSize) * srcLength);
            // Allocate an extra 8 bytes for the tag.
            var dstContent = l.segment.allocate(object_size_1.getByteLength(dstSize) * srcLength + 8);
            var res = pointer_1.initPointer(dstContent.segment, dstContent.byteOffset, l);
            pointer_1.setListPointer(res.offsetWords, ListClass._capnp.size, srcLength, res.pointer, dstSize);
            // Write the new tag word.
            pointer_1.setStructPointer(srcLength, dstSize, dstContent);
            // Seek ahead past the tag word before copying the content.
            dstContent.byteOffset += 8;
            for (var i = 0; i < srcLength; i++) {
                var srcElementOffset = srcContent.byteOffset + i * object_size_1.getByteLength(srcSize);
                var dstElementOffset = dstContent.byteOffset + i * object_size_1.getByteLength(dstSize);
                // Copy the data section.
                dstContent.segment.copyWords(dstElementOffset, srcContent.segment, srcElementOffset, object_size_1.getWordLength(srcSize));
                // Iterate through the pointers and update the offsets so they point to the right place.
                for (var j = 0; j < srcSize.pointerLength; j++) {
                    var srcPtr = new pointer_1.Pointer(srcContent.segment, srcElementOffset + srcSize.dataByteLength + j * 8);
                    var dstPtr = new pointer_1.Pointer(dstContent.segment, dstElementOffset + dstSize.dataByteLength + j * 8);
                    var srcPtrTarget = pointer_1.followFars(srcPtr);
                    var srcPtrContent = pointer_1.getContent(srcPtr);
                    if (pointer_1.getTargetPointerType(srcPtr) === pointer_type_1.PointerType.LIST &&
                        pointer_1.getTargetListElementSize(srcPtr) === list_element_size_1.ListElementSize.COMPOSITE) {
                        srcPtrContent.byteOffset -= 8;
                    }
                    var r = pointer_1.initPointer(srcPtrContent.segment, srcPtrContent.byteOffset, dstPtr);
                    // Read the old pointer data, but discard the original offset.
                    var a = srcPtrTarget.segment.getUint8(srcPtrTarget.byteOffset) & 0x03;
                    var b = srcPtrTarget.segment.getUint32(srcPtrTarget.byteOffset + 4);
                    r.pointer.segment.setUint32(r.pointer.byteOffset, a | (r.offsetWords << 2));
                    r.pointer.segment.setUint32(r.pointer.byteOffset + 4, b);
                }
            }
            // Zero out the old content.
            srcContent.segment.fillZeroWords(srcContent.byteOffset, object_size_1.getWordLength(srcSize) * srcLength);
        }
    }
    return l;
}
exports.getList = getList;
function getPointer(index, s) {
    checkPointerBounds(index, s);
    var ps = getPointerSection(s);
    ps.byteOffset += index * 8;
    return new pointer_1.Pointer(ps.segment, ps.byteOffset, s._capnp.depthLimit - 1);
}
exports.getPointer = getPointer;
function getPointerAs(index, PointerClass, s) {
    checkPointerBounds(index, s);
    var ps = getPointerSection(s);
    ps.byteOffset += index * 8;
    return new PointerClass(ps.segment, ps.byteOffset, s._capnp.depthLimit - 1);
}
exports.getPointerAs = getPointerAs;
function getPointerSection(s) {
    var ps = pointer_1.getContent(s);
    ps.byteOffset += util_1.padToWord(getSize(s).dataByteLength);
    return ps;
}
exports.getPointerSection = getPointerSection;
function getSize(s) {
    if (s._capnp.compositeIndex !== undefined) {
        // For composite lists the object size is stored in a tag word right before the content.
        var c = pointer_1.getContent(s, true);
        c.byteOffset -= 8;
        return pointer_1.getStructSize(c);
    }
    return pointer_1.getTargetStructSize(s);
}
exports.getSize = getSize;
function getStruct(index, StructClass, s, defaultValue) {
    var t = getPointerAs(index, StructClass, s);
    if (pointer_1.isNull(t)) {
        if (defaultValue) {
            pointer_1.Pointer.copyFrom(defaultValue, t);
        }
        else {
            initStruct(StructClass._capnp.size, t);
        }
    }
    else {
        pointer_1.validate(pointer_type_1.PointerType.STRUCT, t);
        var ts = pointer_1.getTargetStructSize(t);
        // This can happen when reading a struct that was constructed with an older version of the same schema, and new
        // fields were added to the struct. A shallow copy of the struct will be made so that there's enough room for the
        // data and pointer sections. This will unfortunately leave a "hole" of zeroes in the message, but that hole will
        // at least compress well.
        if (ts.dataByteLength < StructClass._capnp.size.dataByteLength ||
            ts.pointerLength < StructClass._capnp.size.pointerLength) {
            trace("need to resize child struct %s", t);
            resize(StructClass._capnp.size, t);
        }
    }
    return t;
}
exports.getStruct = getStruct;
function getText(index, s, defaultValue) {
    var t = text_1.Text.fromPointer(getPointer(index, s));
    // FIXME: This will perform an unnecessary string<>ArrayBuffer roundtrip.
    if (pointer_1.isNull(t) && defaultValue)
        t.set(0, defaultValue);
    return t.get(0);
}
exports.getText = getText;
/**
 * Read an uint16 value out of a struct..
 *
 * @param {number} byteOffset The offset in bytes from the start of the data section.
 * @param {Struct} s The struct to read from.
 * @param {DataView} [defaultMask] The default value as a DataView.
 * @returns {number} The value.
 */
function getUint16(byteOffset, s, defaultMask) {
    checkDataBounds(byteOffset, 2, s);
    var ds = getDataSection(s);
    if (defaultMask === undefined) {
        return ds.segment.getUint16(ds.byteOffset + byteOffset);
    }
    return (ds.segment.getUint16(ds.byteOffset + byteOffset) ^
        defaultMask.getUint16(0, true));
}
exports.getUint16 = getUint16;
/**
 * Read an uint32 value out of a struct.
 *
 * @param {number} byteOffset The offset in bytes from the start of the data section.
 * @param {Struct} s The struct to read from.
 * @param {DataView} [defaultMask] The default value as a DataView.
 * @returns {number} The value.
 */
function getUint32(byteOffset, s, defaultMask) {
    checkDataBounds(byteOffset, 4, s);
    var ds = getDataSection(s);
    if (defaultMask === undefined) {
        return ds.segment.getUint32(ds.byteOffset + byteOffset);
    }
    return (ds.segment.getUint32(ds.byteOffset + byteOffset) ^
        defaultMask.getUint32(0, true));
}
exports.getUint32 = getUint32;
/**
 * Read an uint64 value out of a struct.
 *
 * @param {number} byteOffset The offset in bytes from the start of the data section.
 * @param {Struct} s The struct to read from.
 * @param {DataView} [defaultMask] The default value as a DataView.
 * @returns {number} The value.
 */
function getUint64(byteOffset, s, defaultMask) {
    checkDataBounds(byteOffset, 8, s);
    var ds = getDataSection(s);
    if (defaultMask === undefined) {
        return ds.segment.getUint64(ds.byteOffset + byteOffset);
    }
    var lo = ds.segment.getUint32(ds.byteOffset + byteOffset) ^
        defaultMask.getUint32(0, true);
    var hi = ds.segment.getUint32(ds.byteOffset + byteOffset + 4) ^
        defaultMask.getUint32(4, true);
    TMP_WORD.setUint32(0, lo, constants_1.NATIVE_LITTLE_ENDIAN);
    TMP_WORD.setUint32(4, hi, constants_1.NATIVE_LITTLE_ENDIAN);
    return new types_1.Uint64(new Uint8Array(TMP_WORD.buffer.slice(0)));
}
exports.getUint64 = getUint64;
/**
 * Read an uint8 value out of a struct.
 *
 * @param {number} byteOffset The offset in bytes from the start of the data section.
 * @param {Struct} s The struct to read from.
 * @param {DataView} [defaultMask] The default value as a DataView.
 * @returns {number} The value.
 */
function getUint8(byteOffset, s, defaultMask) {
    checkDataBounds(byteOffset, 1, s);
    var ds = getDataSection(s);
    if (defaultMask === undefined) {
        return ds.segment.getUint8(ds.byteOffset + byteOffset);
    }
    return (ds.segment.getUint8(ds.byteOffset + byteOffset) ^ defaultMask.getUint8(0));
}
exports.getUint8 = getUint8;
function initData(index, length, s) {
    checkPointerBounds(index, s);
    var ps = getPointerSection(s);
    ps.byteOffset += index * 8;
    var l = new data_1.Data(ps.segment, ps.byteOffset, s._capnp.depthLimit - 1);
    pointer_1.erase(l);
    list_1.List.initList(list_element_size_1.ListElementSize.BYTE, length, l);
    return l;
}
exports.initData = initData;
function initList(index, ListClass, length, s) {
    checkPointerBounds(index, s);
    var ps = getPointerSection(s);
    ps.byteOffset += index * 8;
    var l = new ListClass(ps.segment, ps.byteOffset, s._capnp.depthLimit - 1);
    pointer_1.erase(l);
    list_1.List.initList(ListClass._capnp.size, length, l, ListClass._capnp.compositeSize);
    return l;
}
exports.initList = initList;
/**
 * Write a boolean (bit) value to the struct.
 *
 * @protected
 * @param {number} bitOffset The offset in **bits** from the start of the data section.
 * @param {boolean} value The value to write (writes a 0 for `false`, 1 for `true`).
 * @param {Struct} s The struct to write to.
 * @param {DataView} [defaultMask] The default value as a DataView.
 * @returns {void}
 */
function setBit(bitOffset, value, s, defaultMask) {
    var byteOffset = Math.floor(bitOffset / 8);
    var bitMask = 1 << bitOffset % 8;
    checkDataBounds(byteOffset, 1, s);
    var ds = getDataSection(s);
    var b = ds.segment.getUint8(ds.byteOffset + byteOffset);
    // If the default mask bit is set, that means `true` values are actually written as `0`.
    if (defaultMask !== undefined) {
        value = (defaultMask.getUint8(0) & bitMask) !== 0 ? !value : value;
    }
    ds.segment.setUint8(ds.byteOffset + byteOffset, value ? b | bitMask : b & ~bitMask);
}
exports.setBit = setBit;
/**
 * Write a primitive float32 value to the struct.
 *
 * @protected
 * @param {number} byteOffset The offset in bytes from the start of the data section.
 * @param {number} value The value to write.
 * @param {Struct} s The struct to write to.
 * @param {DataView} [defaultMask] The default value as a DataView.
 * @returns {void}
 */
function setFloat32(byteOffset, value, s, defaultMask) {
    checkDataBounds(byteOffset, 4, s);
    var ds = getDataSection(s);
    if (defaultMask !== undefined) {
        TMP_WORD.setFloat32(0, value, constants_1.NATIVE_LITTLE_ENDIAN);
        var v = TMP_WORD.getUint32(0, constants_1.NATIVE_LITTLE_ENDIAN) ^
            defaultMask.getUint32(0, true);
        ds.segment.setUint32(ds.byteOffset + byteOffset, v);
        return;
    }
    ds.segment.setFloat32(ds.byteOffset + byteOffset, value);
}
exports.setFloat32 = setFloat32;
/**
 * Write a primitive float64 value to the struct.
 *
 * @protected
 * @param {number} byteOffset The offset in bytes from the start of the data section.
 * @param {number} value The value to write.
 * @param {Struct} s The struct to write to.
 * @param {DataView} [defaultMask] The default value as a DataView.
 * @returns {void}
 */
function setFloat64(byteOffset, value, s, defaultMask) {
    checkDataBounds(byteOffset, 8, s);
    var ds = getDataSection(s);
    if (defaultMask !== undefined) {
        TMP_WORD.setFloat64(0, value, constants_1.NATIVE_LITTLE_ENDIAN);
        var lo = TMP_WORD.getUint32(0, constants_1.NATIVE_LITTLE_ENDIAN) ^
            defaultMask.getUint32(0, true);
        var hi = TMP_WORD.getUint32(4, constants_1.NATIVE_LITTLE_ENDIAN) ^
            defaultMask.getUint32(4, true);
        ds.segment.setUint32(ds.byteOffset + byteOffset, lo);
        ds.segment.setUint32(ds.byteOffset + byteOffset + 4, hi);
        return;
    }
    ds.segment.setFloat64(ds.byteOffset + byteOffset, value);
}
exports.setFloat64 = setFloat64;
/**
 * Write a primitive int16 value to the struct.
 *
 * @protected
 * @param {number} byteOffset The offset in bytes from the start of the data section.
 * @param {number} value The value to write.
 * @param {Struct} s The struct to write to.
 * @param {DataView} [defaultMask] The default value as a DataView.
 * @returns {void}
 */
function setInt16(byteOffset, value, s, defaultMask) {
    checkDataBounds(byteOffset, 2, s);
    var ds = getDataSection(s);
    if (defaultMask !== undefined) {
        TMP_WORD.setInt16(0, value, constants_1.NATIVE_LITTLE_ENDIAN);
        var v = TMP_WORD.getUint16(0, constants_1.NATIVE_LITTLE_ENDIAN) ^
            defaultMask.getUint16(0, true);
        ds.segment.setUint16(ds.byteOffset + byteOffset, v);
        return;
    }
    ds.segment.setInt16(ds.byteOffset + byteOffset, value);
}
exports.setInt16 = setInt16;
/**
 * Write a primitive int32 value to the struct.
 *
 * @protected
 * @param {number} byteOffset The offset in bytes from the start of the data section.
 * @param {number} value The value to write.
 * @param {Struct} s The struct to write to.
 * @param {DataView} [defaultMask] The default value as a DataView.
 * @returns {void}
 */
function setInt32(byteOffset, value, s, defaultMask) {
    checkDataBounds(byteOffset, 4, s);
    var ds = getDataSection(s);
    if (defaultMask !== undefined) {
        TMP_WORD.setInt32(0, value, constants_1.NATIVE_LITTLE_ENDIAN);
        var v = TMP_WORD.getUint32(0, constants_1.NATIVE_LITTLE_ENDIAN) ^
            defaultMask.getUint32(0, true);
        ds.segment.setUint32(ds.byteOffset + byteOffset, v);
        return;
    }
    ds.segment.setInt32(ds.byteOffset + byteOffset, value);
}
exports.setInt32 = setInt32;
/**
 * Write a primitive int64 value to the struct.
 *
 * @protected
 * @param {number} byteOffset The offset in bytes from the start of the data section.
 * @param {number} value The value to write.
 * @param {Struct} s The struct to write to.
 * @param {DataView} [defaultMask] The default value as a DataView.
 * @returns {void}
 */
function setInt64(byteOffset, value, s, defaultMask) {
    checkDataBounds(byteOffset, 8, s);
    var ds = getDataSection(s);
    if (defaultMask !== undefined) {
        // PERF: We could cast the Int64 to a DataView to apply the mask using four 32-bit reads, but we already have a
        // typed array so avoiding the object allocation turns out to be slightly faster. Int64 is guaranteed to be in
        // little-endian format by design.
        for (var i = 0; i < 8; i++) {
            ds.segment.setUint8(ds.byteOffset + byteOffset + i, value.buffer[i] ^ defaultMask.getUint8(i));
        }
        return;
    }
    ds.segment.setInt64(ds.byteOffset + byteOffset, value);
}
exports.setInt64 = setInt64;
/**
 * Write a primitive int8 value to the struct.
 *
 * @protected
 * @param {number} byteOffset The offset in bytes from the start of the data section.
 * @param {number} value The value to write.
 * @param {Struct} s The struct to write to.
 * @param {DataView} [defaultMask] The default value as a DataView.
 * @returns {void}
 */
function setInt8(byteOffset, value, s, defaultMask) {
    checkDataBounds(byteOffset, 1, s);
    var ds = getDataSection(s);
    if (defaultMask !== undefined) {
        TMP_WORD.setInt8(0, value);
        var v = TMP_WORD.getUint8(0) ^ defaultMask.getUint8(0);
        ds.segment.setUint8(ds.byteOffset + byteOffset, v);
        return;
    }
    ds.segment.setInt8(ds.byteOffset + byteOffset, value);
}
exports.setInt8 = setInt8;
function setPointer(index, value, s) {
    pointer_1.copyFrom(value, getPointer(index, s));
}
exports.setPointer = setPointer;
function setText(index, value, s) {
    text_1.Text.fromPointer(getPointer(index, s)).set(0, value);
}
exports.setText = setText;
/**
 * Write a primitive uint16 value to the struct.
 *
 * @protected
 * @param {number} byteOffset The offset in bytes from the start of the data section.
 * @param {number} value The value to write.
 * @param {Struct} s The struct to write to.
 * @param {DataView} [defaultMask] The default value as a DataView.
 * @returns {void}
 */
function setUint16(byteOffset, value, s, defaultMask) {
    checkDataBounds(byteOffset, 2, s);
    var ds = getDataSection(s);
    if (defaultMask !== undefined)
        value ^= defaultMask.getUint16(0, true);
    ds.segment.setUint16(ds.byteOffset + byteOffset, value);
}
exports.setUint16 = setUint16;
/**
 * Write a primitive uint32 value to the struct.
 *
 * @protected
 * @param {number} byteOffset The offset in bytes from the start of the data section.
 * @param {number} value The value to write.
 * @param {Struct} s The struct to write to.
 * @param {DataView} [defaultMask] The default value as a DataView.
 * @returns {void}
 */
function setUint32(byteOffset, value, s, defaultMask) {
    checkDataBounds(byteOffset, 4, s);
    var ds = getDataSection(s);
    if (defaultMask !== undefined)
        value ^= defaultMask.getUint32(0, true);
    ds.segment.setUint32(ds.byteOffset + byteOffset, value);
}
exports.setUint32 = setUint32;
/**
 * Write a primitive uint64 value to the struct.
 *
 * @protected
 * @param {number} byteOffset The offset in bytes from the start of the data section.
 * @param {number} value The value to write.
 * @param {Struct} s The struct to write to.
 * @param {DataView} [defaultMask] The default value as a DataView.
 * @returns {void}
 */
function setUint64(byteOffset, value, s, defaultMask) {
    checkDataBounds(byteOffset, 8, s);
    var ds = getDataSection(s);
    if (defaultMask !== undefined) {
        // PERF: We could cast the Uint64 to a DataView to apply the mask using four 32-bit reads, but we already have a
        // typed array so avoiding the object allocation turns out to be slightly faster. Uint64 is guaranteed to be in
        // little-endian format by design.
        for (var i = 0; i < 8; i++) {
            ds.segment.setUint8(ds.byteOffset + byteOffset + i, value.buffer[i] ^ defaultMask.getUint8(i));
        }
        return;
    }
    ds.segment.setUint64(ds.byteOffset + byteOffset, value);
}
exports.setUint64 = setUint64;
/**
 * Write a primitive uint8 value to the struct.
 *
 * @protected
 * @param {number} byteOffset The offset in bytes from the start of the data section.
 * @param {number} value The value to write.
 * @param {Struct} s The struct to write to.
 * @param {DataView} [defaultMask] The default value as a DataView.
 * @returns {void}
 */
function setUint8(byteOffset, value, s, defaultMask) {
    checkDataBounds(byteOffset, 1, s);
    var ds = getDataSection(s);
    if (defaultMask !== undefined)
        value ^= defaultMask.getUint8(0);
    ds.segment.setUint8(ds.byteOffset + byteOffset, value);
}
exports.setUint8 = setUint8;
function testWhich(name, found, wanted, s) {
    if (found !== wanted) {
        throw new Error(util_1.format(errors_1.PTR_INVALID_UNION_ACCESS, s, name, found, wanted));
    }
}
exports.testWhich = testWhich;
function checkDataBounds(byteOffset, byteLength, s) {
    var dataByteLength = getSize(s).dataByteLength;
    if (byteOffset < 0 ||
        byteLength < 0 ||
        byteOffset + byteLength > dataByteLength) {
        throw new Error(util_1.format(errors_1.PTR_STRUCT_DATA_OUT_OF_BOUNDS, s, byteLength, byteOffset, dataByteLength));
    }
}
exports.checkDataBounds = checkDataBounds;
function checkPointerBounds(index, s) {
    var pointerLength = getSize(s).pointerLength;
    if (index < 0 || index >= pointerLength) {
        throw new Error(util_1.format(errors_1.PTR_STRUCT_POINTER_OUT_OF_BOUNDS, s, index, pointerLength));
    }
}
exports.checkPointerBounds = checkPointerBounds;

//# sourceMappingURL=struct.js.map


/***/ }),

/***/ "./node_modules/capnp-ts/lib/serialization/pointers/text-list.js":
/*!***********************************************************************!*\
  !*** ./node_modules/capnp-ts/lib/serialization/pointers/text-list.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @author jdiaz5513
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var debug_1 = __webpack_require__(/*! debug */ "./node_modules/capnp-ts/node_modules/debug/src/browser.js");
var list_element_size_1 = __webpack_require__(/*! ../list-element-size */ "./node_modules/capnp-ts/lib/serialization/list-element-size.js");
var list_1 = __webpack_require__(/*! ./list */ "./node_modules/capnp-ts/lib/serialization/pointers/list.js");
var text_1 = __webpack_require__(/*! ./text */ "./node_modules/capnp-ts/lib/serialization/pointers/text.js");
var pointer_1 = __webpack_require__(/*! ./pointer */ "./node_modules/capnp-ts/lib/serialization/pointers/pointer.js");
var trace = debug_1.default("capnp:list:composite");
trace("load");
var TextList = /** @class */ (function (_super) {
    tslib_1.__extends(TextList, _super);
    function TextList() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TextList.prototype.get = function (index) {
        var c = pointer_1.getContent(this);
        c.byteOffset += index * 8;
        return text_1.Text.fromPointer(c).get(0);
    };
    TextList.prototype.set = function (index, value) {
        var c = pointer_1.getContent(this);
        c.byteOffset += index * 8;
        text_1.Text.fromPointer(c).set(0, value);
    };
    TextList.prototype.toString = function () {
        return "Text_" + _super.prototype.toString.call(this);
    };
    TextList._capnp = {
        displayName: "List<Text>",
        size: list_element_size_1.ListElementSize.POINTER
    };
    return TextList;
}(list_1.List));
exports.TextList = TextList;

//# sourceMappingURL=text-list.js.map


/***/ }),

/***/ "./node_modules/capnp-ts/lib/serialization/pointers/text.js":
/*!******************************************************************!*\
  !*** ./node_modules/capnp-ts/lib/serialization/pointers/text.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @author jdiaz5513
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var debug_1 = __webpack_require__(/*! debug */ "./node_modules/capnp-ts/node_modules/debug/src/browser.js");
var util_1 = __webpack_require__(/*! ../../util */ "./node_modules/capnp-ts/lib/util.js");
var list_element_size_1 = __webpack_require__(/*! ../list-element-size */ "./node_modules/capnp-ts/lib/serialization/list-element-size.js");
var list_1 = __webpack_require__(/*! ./list */ "./node_modules/capnp-ts/lib/serialization/pointers/list.js");
var pointer_1 = __webpack_require__(/*! ./pointer */ "./node_modules/capnp-ts/lib/serialization/pointers/pointer.js");
var pointer_type_1 = __webpack_require__(/*! ./pointer-type */ "./node_modules/capnp-ts/lib/serialization/pointers/pointer-type.js");
var trace = debug_1.default("capnp:text");
trace("load");
var Text = /** @class */ (function (_super) {
    tslib_1.__extends(Text, _super);
    function Text() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Text.fromPointer = function (pointer) {
        pointer_1.validate(pointer_type_1.PointerType.LIST, pointer, list_element_size_1.ListElementSize.BYTE);
        return textFromPointerUnchecked(pointer);
    };
    /**
     * Read a utf-8 encoded string value from this pointer.
     *
     * @param {number} [index] The index at which to start reading; defaults to zero.
     * @returns {string} The string value.
     */
    Text.prototype.get = function (index) {
        if (index === void 0) { index = 0; }
        if (index !== 0) {
            trace("Called get() on %s with a strange index (%d).", this, index);
        }
        if (pointer_1.isNull(this))
            return "";
        var c = pointer_1.getContent(this);
        // Remember to exclude the NUL byte.
        return util_1.decodeUtf8(new Uint8Array(c.segment.buffer, c.byteOffset + index, this.getLength() - index));
    };
    /**
     * Get the number of utf-8 encoded bytes in this text. This does **not** include the NUL byte.
     *
     * @returns {number} The number of bytes allocated for the text.
     */
    Text.prototype.getLength = function () {
        return _super.prototype.getLength.call(this) - 1;
    };
    /**
     * Write a utf-8 encoded string value starting at the specified index.
     *
     * @param {number} index The index at which to start copying the string. Note that if this is not zero the bytes
     * before `index` will be left as-is. All bytes after `index` will be overwritten.
     * @param {string} value The string value to set.
     * @returns {void}
     */
    Text.prototype.set = function (index, value) {
        if (index !== 0) {
            trace("Called set() on %s with a strange index (%d).", this, index);
        }
        var src = util_1.encodeUtf8(value);
        var dstLength = src.byteLength + index;
        var c;
        var original;
        // TODO: Consider reusing existing space if list is already initialized and there's enough room for the value.
        if (!pointer_1.isNull(this)) {
            c = pointer_1.getContent(this);
            // Only copy bytes that will remain after copying. Everything after `index` should end up truncated.
            var originalLength = this.getLength();
            if (originalLength >= index) {
                originalLength = index;
            }
            else {
                trace("%d byte gap exists between original text and new text in %s.", index - originalLength, this);
            }
            original = new Uint8Array(c.segment.buffer.slice(c.byteOffset, c.byteOffset + Math.min(originalLength, index)));
            pointer_1.erase(this);
        }
        // Always allocate an extra byte for the NUL byte.
        list_1.initList(list_element_size_1.ListElementSize.BYTE, dstLength + 1, this);
        c = pointer_1.getContent(this);
        var dst = new Uint8Array(c.segment.buffer, c.byteOffset, dstLength);
        if (original)
            dst.set(original);
        dst.set(src, index);
    };
    Text.prototype.toString = function () {
        return "Text_" + _super.prototype.toString.call(this);
    };
    return Text;
}(list_1.List));
exports.Text = Text;
function textFromPointerUnchecked(pointer) {
    return new Text(pointer.segment, pointer.byteOffset, pointer._capnp.depthLimit);
}

//# sourceMappingURL=text.js.map


/***/ }),

/***/ "./node_modules/capnp-ts/lib/serialization/pointers/uint16-list.js":
/*!*************************************************************************!*\
  !*** ./node_modules/capnp-ts/lib/serialization/pointers/uint16-list.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @author jdiaz5513
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var debug_1 = __webpack_require__(/*! debug */ "./node_modules/capnp-ts/node_modules/debug/src/browser.js");
var list_element_size_1 = __webpack_require__(/*! ../list-element-size */ "./node_modules/capnp-ts/lib/serialization/list-element-size.js");
var list_1 = __webpack_require__(/*! ./list */ "./node_modules/capnp-ts/lib/serialization/pointers/list.js");
var pointer_1 = __webpack_require__(/*! ./pointer */ "./node_modules/capnp-ts/lib/serialization/pointers/pointer.js");
var trace = debug_1.default("capnp:list:composite");
trace("load");
var Uint16List = /** @class */ (function (_super) {
    tslib_1.__extends(Uint16List, _super);
    function Uint16List() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Uint16List.prototype.get = function (index) {
        var c = pointer_1.getContent(this);
        return c.segment.getUint16(c.byteOffset + index * 2);
    };
    Uint16List.prototype.set = function (index, value) {
        var c = pointer_1.getContent(this);
        c.segment.setUint16(c.byteOffset + index * 2, value);
    };
    Uint16List.prototype.toString = function () {
        return "Uint16_" + _super.prototype.toString.call(this);
    };
    Uint16List._capnp = {
        displayName: "List<Uint16>",
        size: list_element_size_1.ListElementSize.BYTE_2
    };
    return Uint16List;
}(list_1.List));
exports.Uint16List = Uint16List;

//# sourceMappingURL=uint16-list.js.map


/***/ }),

/***/ "./node_modules/capnp-ts/lib/serialization/pointers/uint32-list.js":
/*!*************************************************************************!*\
  !*** ./node_modules/capnp-ts/lib/serialization/pointers/uint32-list.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @author jdiaz5513
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var debug_1 = __webpack_require__(/*! debug */ "./node_modules/capnp-ts/node_modules/debug/src/browser.js");
var list_element_size_1 = __webpack_require__(/*! ../list-element-size */ "./node_modules/capnp-ts/lib/serialization/list-element-size.js");
var list_1 = __webpack_require__(/*! ./list */ "./node_modules/capnp-ts/lib/serialization/pointers/list.js");
var pointer_1 = __webpack_require__(/*! ./pointer */ "./node_modules/capnp-ts/lib/serialization/pointers/pointer.js");
var trace = debug_1.default("capnp:list:composite");
trace("load");
var Uint32List = /** @class */ (function (_super) {
    tslib_1.__extends(Uint32List, _super);
    function Uint32List() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Uint32List.prototype.get = function (index) {
        var c = pointer_1.getContent(this);
        return c.segment.getUint32(c.byteOffset + index * 4);
    };
    Uint32List.prototype.set = function (index, value) {
        var c = pointer_1.getContent(this);
        c.segment.setUint32(c.byteOffset + index * 4, value);
    };
    Uint32List.prototype.toString = function () {
        return "Uint32_" + _super.prototype.toString.call(this);
    };
    Uint32List._capnp = {
        displayName: "List<Uint32>",
        size: list_element_size_1.ListElementSize.BYTE_4
    };
    return Uint32List;
}(list_1.List));
exports.Uint32List = Uint32List;

//# sourceMappingURL=uint32-list.js.map


/***/ }),

/***/ "./node_modules/capnp-ts/lib/serialization/pointers/uint64-list.js":
/*!*************************************************************************!*\
  !*** ./node_modules/capnp-ts/lib/serialization/pointers/uint64-list.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @author jdiaz5513
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var debug_1 = __webpack_require__(/*! debug */ "./node_modules/capnp-ts/node_modules/debug/src/browser.js");
var list_element_size_1 = __webpack_require__(/*! ../list-element-size */ "./node_modules/capnp-ts/lib/serialization/list-element-size.js");
var list_1 = __webpack_require__(/*! ./list */ "./node_modules/capnp-ts/lib/serialization/pointers/list.js");
var pointer_1 = __webpack_require__(/*! ./pointer */ "./node_modules/capnp-ts/lib/serialization/pointers/pointer.js");
var trace = debug_1.default("capnp:list:composite");
trace("load");
var Uint64List = /** @class */ (function (_super) {
    tslib_1.__extends(Uint64List, _super);
    function Uint64List() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Uint64List.prototype.get = function (index) {
        var c = pointer_1.getContent(this);
        return c.segment.getUint64(c.byteOffset + index * 8);
    };
    Uint64List.prototype.set = function (index, value) {
        var c = pointer_1.getContent(this);
        c.segment.setUint64(c.byteOffset + index * 8, value);
    };
    Uint64List.prototype.toString = function () {
        return "Uint64_" + _super.prototype.toString.call(this);
    };
    Uint64List._capnp = {
        displayName: "List<Uint64>",
        size: list_element_size_1.ListElementSize.BYTE_8
    };
    return Uint64List;
}(list_1.List));
exports.Uint64List = Uint64List;

//# sourceMappingURL=uint64-list.js.map


/***/ }),

/***/ "./node_modules/capnp-ts/lib/serialization/pointers/uint8-list.js":
/*!************************************************************************!*\
  !*** ./node_modules/capnp-ts/lib/serialization/pointers/uint8-list.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @author jdiaz5513
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var debug_1 = __webpack_require__(/*! debug */ "./node_modules/capnp-ts/node_modules/debug/src/browser.js");
var list_element_size_1 = __webpack_require__(/*! ../list-element-size */ "./node_modules/capnp-ts/lib/serialization/list-element-size.js");
var list_1 = __webpack_require__(/*! ./list */ "./node_modules/capnp-ts/lib/serialization/pointers/list.js");
var pointer_1 = __webpack_require__(/*! ./pointer */ "./node_modules/capnp-ts/lib/serialization/pointers/pointer.js");
var trace = debug_1.default("capnp:list:composite");
trace("load");
var Uint8List = /** @class */ (function (_super) {
    tslib_1.__extends(Uint8List, _super);
    function Uint8List() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Uint8List.prototype.get = function (index) {
        var c = pointer_1.getContent(this);
        return c.segment.getUint8(c.byteOffset + index);
    };
    Uint8List.prototype.set = function (index, value) {
        var c = pointer_1.getContent(this);
        c.segment.setUint8(c.byteOffset + index, value);
    };
    Uint8List.prototype.toString = function () {
        return "Uint8_" + _super.prototype.toString.call(this);
    };
    Uint8List._capnp = {
        displayName: "List<Uint8>",
        size: list_element_size_1.ListElementSize.BYTE
    };
    return Uint8List;
}(list_1.List));
exports.Uint8List = Uint8List;

//# sourceMappingURL=uint8-list.js.map


/***/ }),

/***/ "./node_modules/capnp-ts/lib/serialization/pointers/void-list.js":
/*!***********************************************************************!*\
  !*** ./node_modules/capnp-ts/lib/serialization/pointers/void-list.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Why would anyone **SANE** ever use this!?
 *
 * @author jdiaz5513
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var pointer_list_1 = __webpack_require__(/*! ./pointer-list */ "./node_modules/capnp-ts/lib/serialization/pointers/pointer-list.js");
var void_1 = __webpack_require__(/*! ./void */ "./node_modules/capnp-ts/lib/serialization/pointers/void.js");
exports.VoidList = pointer_list_1.PointerList(void_1.Void);

//# sourceMappingURL=void-list.js.map


/***/ }),

/***/ "./node_modules/capnp-ts/lib/serialization/pointers/void.js":
/*!******************************************************************!*\
  !*** ./node_modules/capnp-ts/lib/serialization/pointers/void.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @author jdiaz5513
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var object_size_1 = __webpack_require__(/*! ../object-size */ "./node_modules/capnp-ts/lib/serialization/object-size.js");
var struct_1 = __webpack_require__(/*! ./struct */ "./node_modules/capnp-ts/lib/serialization/pointers/struct.js");
var Void = /** @class */ (function (_super) {
    tslib_1.__extends(Void, _super);
    function Void() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Void._capnp = {
        displayName: "Void",
        id: "0",
        size: new object_size_1.ObjectSize(0, 0)
    };
    return Void;
}(struct_1.Struct));
exports.Void = Void;
// This following line makes a mysterious "whooshing" sound when it runs.
exports.VOID = undefined;

//# sourceMappingURL=void.js.map


/***/ }),

/***/ "./node_modules/capnp-ts/lib/serialization/segment.js":
/*!************************************************************!*\
  !*** ./node_modules/capnp-ts/lib/serialization/segment.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @author jdiaz5513
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var debug_1 = __webpack_require__(/*! debug */ "./node_modules/capnp-ts/node_modules/debug/src/browser.js");
var constants_1 = __webpack_require__(/*! ../constants */ "./node_modules/capnp-ts/lib/constants.js");
var errors_1 = __webpack_require__(/*! ../errors */ "./node_modules/capnp-ts/lib/errors.js");
var types_1 = __webpack_require__(/*! ../types */ "./node_modules/capnp-ts/lib/types/index.js");
var util_1 = __webpack_require__(/*! ../util */ "./node_modules/capnp-ts/lib/util.js");
var pointers_1 = __webpack_require__(/*! ./pointers */ "./node_modules/capnp-ts/lib/serialization/pointers/index.js");
var trace = debug_1.default("capnp:segment");
trace("load");
var Segment = /** @class */ (function () {
    function Segment(id, message, buffer, byteLength) {
        if (byteLength === void 0) { byteLength = 0; }
        this[Symbol.toStringTag] = "Segment";
        this.id = id;
        this.message = message;
        this.buffer = buffer;
        this._dv = new DataView(buffer);
        this.byteOffset = 0;
        this.byteLength = byteLength;
    }
    /**
     * Attempt to allocate the requested number of bytes in this segment. If this segment is full this method will return
     * a pointer to freshly allocated space in another segment from the same message.
     *
     * @param {number} byteLength The number of bytes to allocate, will be rounded up to the nearest word.
     * @returns {Pointer} A pointer to the newly allocated space.
     */
    Segment.prototype.allocate = function (byteLength) {
        trace("allocate(%d)", byteLength);
        var segment = this;
        byteLength = util_1.padToWord(byteLength);
        if (byteLength > constants_1.MAX_SEGMENT_LENGTH - 8) {
            throw new Error(util_1.format(errors_1.SEG_SIZE_OVERFLOW, byteLength));
        }
        if (!segment.hasCapacity(byteLength)) {
            segment = segment.message.allocateSegment(byteLength);
        }
        var byteOffset = segment.byteLength;
        segment.byteLength = segment.byteLength + byteLength;
        trace("Allocated %x bytes in %s (requested segment: %s).", byteLength, this, segment);
        return new pointers_1.Pointer(segment, byteOffset);
    };
    /**
     * Quickly copy a word (8 bytes) from `srcSegment` into this one at the given offset.
     *
     * @param {number} byteOffset The offset to write the word to.
     * @param {Segment} srcSegment The segment to copy the word from.
     * @param {number} srcByteOffset The offset from the start of `srcSegment` to copy from.
     * @returns {void}
     */
    Segment.prototype.copyWord = function (byteOffset, srcSegment, srcByteOffset) {
        var value = srcSegment._dv.getFloat64(srcByteOffset, constants_1.NATIVE_LITTLE_ENDIAN);
        this._dv.setFloat64(byteOffset, value, constants_1.NATIVE_LITTLE_ENDIAN);
    };
    /**
     * Quickly copy words from `srcSegment` into this one.
     *
     * @param {number} byteOffset The offset to start copying into.
     * @param {Segment} srcSegment The segment to copy from.
     * @param {number} srcByteOffset The start offset to copy from.
     * @param {number} wordLength The number of words to copy.
     * @returns {void}
     */
    Segment.prototype.copyWords = function (byteOffset, srcSegment, srcByteOffset, wordLength) {
        var dst = new Float64Array(this.buffer, byteOffset, wordLength);
        var src = new Float64Array(srcSegment.buffer, srcByteOffset, wordLength);
        dst.set(src);
    };
    /**
     * Quickly fill a number of words in the buffer with zeroes.
     *
     * @param {number} byteOffset The first byte to set to zero.
     * @param {number} wordLength The number of words (not bytes!) to zero out.
     * @returns {void}
     */
    Segment.prototype.fillZeroWords = function (byteOffset, wordLength) {
        new Float64Array(this.buffer, byteOffset, wordLength).fill(0);
    };
    /**
     * Get the total number of bytes available in this segment (the size of its underlying buffer).
     *
     * @returns {number} The total number of bytes this segment can hold.
     */
    Segment.prototype.getCapacity = function () {
        return this.buffer.byteLength;
    };
    /**
     * Read a float32 value out of this segment.
     *
     * @param {number} byteOffset The offset in bytes to the value.
     * @returns {number} The value.
     */
    Segment.prototype.getFloat32 = function (byteOffset) {
        return this._dv.getFloat32(byteOffset, true);
    };
    /**
     * Read a float64 value out of this segment.
     *
     * @param {number} byteOffset The offset in bytes to the value.
     * @returns {number} The value.
     */
    Segment.prototype.getFloat64 = function (byteOffset) {
        return this._dv.getFloat64(byteOffset, true);
    };
    /**
     * Read an int16 value out of this segment.
     *
     * @param {number} byteOffset The offset in bytes to the value.
     * @returns {number} The value.
     */
    Segment.prototype.getInt16 = function (byteOffset) {
        return this._dv.getInt16(byteOffset, true);
    };
    /**
     * Read an int32 value out of this segment.
     *
     * @param {number} byteOffset The offset in bytes to the value.
     * @returns {number} The value.
     */
    Segment.prototype.getInt32 = function (byteOffset) {
        return this._dv.getInt32(byteOffset, true);
    };
    /**
     * Read an int64 value out of this segment.
     *
     * @param {number} byteOffset The offset in bytes to the value.
     * @returns {number} The value.
     */
    Segment.prototype.getInt64 = function (byteOffset) {
        return new types_1.Int64(new Uint8Array(this.buffer.slice(byteOffset, byteOffset + 8)));
    };
    /**
     * Read an int8 value out of this segment.
     *
     * @param {number} byteOffset The offset in bytes to the value.
     * @returns {number} The value.
     */
    Segment.prototype.getInt8 = function (byteOffset) {
        return this._dv.getInt8(byteOffset);
    };
    /**
     * Read a uint16 value out of this segment.
     *
     * @param {number} byteOffset The offset in bytes to the value.
     * @returns {number} The value.
     */
    Segment.prototype.getUint16 = function (byteOffset) {
        return this._dv.getUint16(byteOffset, true);
    };
    /**
     * Read a uint32 value out of this segment.
     *
     * @param {number} byteOffset The offset in bytes to the value.
     * @returns {number} The value.
     */
    Segment.prototype.getUint32 = function (byteOffset) {
        return this._dv.getUint32(byteOffset, true);
    };
    /**
     * Read a uint8 value out of this segment.
     * NOTE: this does not copy the memory region, so updates to the underlying buffer will affect the Uint64 value!
     *
     * @param {number} byteOffset The offset in bytes to the value.
     * @returns {number} The value.
     */
    Segment.prototype.getUint64 = function (byteOffset) {
        return new types_1.Uint64(new Uint8Array(this.buffer.slice(byteOffset, byteOffset + 8)));
    };
    /**
     * Read a uint8 value out of this segment.
     *
     * @param {number} byteOffset The offset in bytes to the value.
     * @returns {number} The value.
     */
    Segment.prototype.getUint8 = function (byteOffset) {
        return this._dv.getUint8(byteOffset);
    };
    Segment.prototype.hasCapacity = function (byteLength) {
        trace("hasCapacity(%d)", byteLength);
        // capacity - allocated >= requested
        return this.buffer.byteLength - this.byteLength >= byteLength;
    };
    /**
     * Quickly check the word at the given offset to see if it is equal to zero.
     *
     * PERF_V8: Fastest way to do this is by reading the whole word as a `number` (float64) in the _native_ endian format
     * and see if it's zero.
     *
     * Benchmark: http://jsben.ch/#/Pjooc
     *
     * @param {number} byteOffset The offset to the word.
     * @returns {boolean} `true` if the word is zero.
     */
    Segment.prototype.isWordZero = function (byteOffset) {
        return this._dv.getFloat64(byteOffset, constants_1.NATIVE_LITTLE_ENDIAN) === 0;
    };
    /**
     * Swap out this segment's underlying buffer with a new one. It's assumed that the new buffer has the same content but
     * more free space, otherwise all existing pointers to this segment will be hilariously broken.
     *
     * @param {ArrayBuffer} buffer The new buffer to use.
     * @returns {void}
     */
    Segment.prototype.replaceBuffer = function (buffer) {
        trace("replaceBuffer(%p)", buffer);
        if (this.buffer === buffer)
            return;
        if (buffer.byteLength < this.byteLength) {
            throw new Error(errors_1.SEG_REPLACEMENT_BUFFER_TOO_SMALL);
        }
        this._dv = new DataView(buffer);
        this.buffer = buffer;
    };
    /**
     * Write a float32 value to the specified offset.
     *
     * @param {number} byteOffset The offset from the beginning of the buffer.
     * @param {number} val The value to store.
     * @returns {void}
     */
    Segment.prototype.setFloat32 = function (byteOffset, val) {
        this._dv.setFloat32(byteOffset, val, true);
    };
    /**
     * Write an float64 value to the specified offset.
     *
     * @param {number} byteOffset The offset from the beginning of the buffer.
     * @param {number} val The value to store.
     * @returns {void}
     */
    Segment.prototype.setFloat64 = function (byteOffset, val) {
        this._dv.setFloat64(byteOffset, val, true);
    };
    /**
     * Write an int16 value to the specified offset.
     *
     * @param {number} byteOffset The offset from the beginning of the buffer.
     * @param {number} val The value to store.
     * @returns {void}
     */
    Segment.prototype.setInt16 = function (byteOffset, val) {
        this._dv.setInt16(byteOffset, val, true);
    };
    /**
     * Write an int32 value to the specified offset.
     *
     * @param {number} byteOffset The offset from the beginning of the buffer.
     * @param {number} val The value to store.
     * @returns {void}
     */
    Segment.prototype.setInt32 = function (byteOffset, val) {
        this._dv.setInt32(byteOffset, val, true);
    };
    /**
     * Write an int8 value to the specified offset.
     *
     * @param {number} byteOffset The offset from the beginning of the buffer.
     * @param {number} val The value to store.
     * @returns {void}
     */
    Segment.prototype.setInt8 = function (byteOffset, val) {
        this._dv.setInt8(byteOffset, val);
    };
    /**
     * Write an int64 value to the specified offset.
     *
     * @param {number} byteOffset The offset from the beginning of the buffer.
     * @param {Int64} val The value to store.
     * @returns {void}
     */
    Segment.prototype.setInt64 = function (byteOffset, val) {
        this._dv.setUint8(byteOffset, val.buffer[0]);
        this._dv.setUint8(byteOffset + 1, val.buffer[1]);
        this._dv.setUint8(byteOffset + 2, val.buffer[2]);
        this._dv.setUint8(byteOffset + 3, val.buffer[3]);
        this._dv.setUint8(byteOffset + 4, val.buffer[4]);
        this._dv.setUint8(byteOffset + 5, val.buffer[5]);
        this._dv.setUint8(byteOffset + 6, val.buffer[6]);
        this._dv.setUint8(byteOffset + 7, val.buffer[7]);
    };
    /**
     * Write a uint16 value to the specified offset.
     *
     * @param {number} byteOffset The offset from the beginning of the buffer.
     * @param {number} val The value to store.
     * @returns {void}
     */
    Segment.prototype.setUint16 = function (byteOffset, val) {
        this._dv.setUint16(byteOffset, val, true);
    };
    /**
     * Write a uint32 value to the specified offset.
     *
     * @param {number} byteOffset The offset from the beginning of the buffer.
     * @param {number} val The value to store.
     * @returns {void}
     */
    Segment.prototype.setUint32 = function (byteOffset, val) {
        this._dv.setUint32(byteOffset, val, true);
    };
    /**
     * Write a uint64 value to the specified offset.
     * TODO: benchmark other ways to perform this write operation.
     *
     * @param {number} byteOffset The offset from the beginning of the buffer.
     * @param {Uint64} val The value to store.
     * @returns {void}
     */
    Segment.prototype.setUint64 = function (byteOffset, val) {
        this._dv.setUint8(byteOffset + 0, val.buffer[0]);
        this._dv.setUint8(byteOffset + 1, val.buffer[1]);
        this._dv.setUint8(byteOffset + 2, val.buffer[2]);
        this._dv.setUint8(byteOffset + 3, val.buffer[3]);
        this._dv.setUint8(byteOffset + 4, val.buffer[4]);
        this._dv.setUint8(byteOffset + 5, val.buffer[5]);
        this._dv.setUint8(byteOffset + 6, val.buffer[6]);
        this._dv.setUint8(byteOffset + 7, val.buffer[7]);
    };
    /**
     * Write a uint8 (byte) value to the specified offset.
     *
     * @param {number} byteOffset The offset from the beginning of the buffer.
     * @param {number} val The value to store.
     * @returns {void}
     */
    Segment.prototype.setUint8 = function (byteOffset, val) {
        this._dv.setUint8(byteOffset, val);
    };
    /**
     * Write a zero word (8 bytes) to the specified offset. This is slightly faster than calling `setUint64` or
     * `setFloat64` with a zero value.
     *
     * Benchmark: http://jsben.ch/#/dUdPI
     *
     * @param {number} byteOffset The offset of the word to set to zero.
     * @returns {void}
     */
    Segment.prototype.setWordZero = function (byteOffset) {
        this._dv.setFloat64(byteOffset, 0, constants_1.NATIVE_LITTLE_ENDIAN);
    };
    Segment.prototype.toString = function () {
        return util_1.format("Segment_id:%d,off:%a,len:%a,cap:%a", this.id, this.byteLength, this.byteOffset, this.buffer.byteLength);
    };
    return Segment;
}());
exports.Segment = Segment;

//# sourceMappingURL=segment.js.map


/***/ }),

/***/ "./node_modules/capnp-ts/lib/types/index.js":
/*!**************************************************!*\
  !*** ./node_modules/capnp-ts/lib/types/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @author jdiaz5513
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var int64_1 = __webpack_require__(/*! ./int64 */ "./node_modules/capnp-ts/lib/types/int64.js");
exports.Int64 = int64_1.Int64;
var uint64_1 = __webpack_require__(/*! ./uint64 */ "./node_modules/capnp-ts/lib/types/uint64.js");
exports.Uint64 = uint64_1.Uint64;

//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/capnp-ts/lib/types/int64.js":
/*!**************************************************!*\
  !*** ./node_modules/capnp-ts/lib/types/int64.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @author jdiaz5513
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.js");
var debug_1 = __webpack_require__(/*! debug */ "./node_modules/capnp-ts/node_modules/debug/src/browser.js");
var constants_1 = __webpack_require__(/*! ../constants */ "./node_modules/capnp-ts/lib/constants.js");
var util_1 = __webpack_require__(/*! ../util */ "./node_modules/capnp-ts/lib/util.js");
var uint64_1 = __webpack_require__(/*! ./uint64 */ "./node_modules/capnp-ts/lib/types/uint64.js");
var trace = debug_1.default("capnp:int64");
trace("load");
/**
 * Represents a signed 64-bit integer stored using a Uint8Array in little-endian format.
 *
 * You may convert this to a primitive number by calling `toNumber()` but be wary of precision loss!
 *
 * The value passed in as the source buffer is expected to be in little-endian format.
 */
var Int64 = /** @class */ (function (_super) {
    tslib_1.__extends(Int64, _super);
    function Int64() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Int64.fromArrayBuffer = function (source, offset, noCopy) {
        if (offset === void 0) { offset = 0; }
        if (noCopy === void 0) { noCopy = false; }
        if (noCopy)
            return new this(new Uint8Array(source, offset, 8));
        return new this(new Uint8Array(source.slice(offset, offset + 8)));
    };
    Int64.fromDataView = function (source, offset, noCopy) {
        if (offset === void 0) { offset = 0; }
        if (noCopy === void 0) { noCopy = false; }
        if (noCopy) {
            return new this(new Uint8Array(source.buffer, source.byteOffset + offset, 8));
        }
        return new this(new Uint8Array(source.buffer.slice(source.byteOffset + offset, source.byteLength + offset + 8)));
    };
    Int64.fromNumber = function (source) {
        var ret = new this(new Uint8Array(8));
        ret.setValue(source);
        return ret;
    };
    /**
     * Parse a hexadecimal string in **big endian format** as an Int64 value.
     *
     * The value will be negative if the string is either preceded with a `-` sign, or already in the negative 2's
     * complement form.
     *
     * @static
     * @param {string} source The source string.
     * @returns {Int64} The string parsed as a 64-bit signed integer.
     */
    Int64.fromHexString = function (source) {
        if (source.substr(0, 2) === "0x")
            source = source.substr(2);
        if (source.length < 1)
            return Int64.fromNumber(0);
        var neg = source[0] === "-";
        if (neg)
            source = source.substr(1);
        source = util_1.pad(source, 16);
        if (source.length !== 16) {
            throw new RangeError("Source string must contain at most 16 hexadecimal digits.");
        }
        var bytes = source.toLowerCase().replace(/[^\da-f]/g, "");
        var buf = new Uint8Array(new ArrayBuffer(8));
        for (var i = 0; i < 8; i++) {
            buf[7 - i] = parseInt(bytes.substr(i * 2, 2), 16);
        }
        var val = new Int64(buf);
        if (neg)
            val.negate();
        return val;
    };
    Int64.fromUint8Array = function (source, offset, noCopy) {
        if (offset === void 0) { offset = 0; }
        if (noCopy === void 0) { noCopy = false; }
        if (noCopy)
            return new this(source.subarray(offset, offset + 8));
        return new this(new Uint8Array(source.buffer.slice(source.byteOffset + offset, source.byteOffset + offset + 8)));
    };
    Int64.prototype.equals = function (other) {
        return _super.prototype.equals.call(this, other);
    };
    Int64.prototype.inspect = function () {
        return "[Int64 " + this.toString(10) + " 0x" + this.toHexString() + "]";
    };
    Int64.prototype.negate = function () {
        for (var b = this.buffer, carry = 1, i = 0; i < 8; i++) {
            var v = (b[i] ^ 0xff) + carry;
            b[i] = v & 0xff;
            carry = v >> 8;
        }
    };
    Int64.prototype.setValue = function (loWord, hiWord) {
        var negate = false;
        var lo = loWord;
        var hi = hiWord;
        if (hi === undefined) {
            hi = lo;
            negate = hi < 0;
            hi = Math.abs(hi);
            lo = hi % constants_1.VAL32;
            hi = hi / constants_1.VAL32;
            if (hi > constants_1.VAL32)
                throw new RangeError(loWord + " is outside Int64 range");
            hi = hi >>> 0;
        }
        for (var i = 0; i < 8; i++) {
            this.buffer[i] = lo & 0xff;
            lo = i === 3 ? hi : lo >>> 8;
        }
        if (negate)
            this.negate();
    };
    Int64.prototype.toHexString = function () {
        var b = this.buffer;
        var negate = b[7] & 0x80;
        if (negate)
            this.negate();
        var hex = "";
        for (var i = 7; i >= 0; i--) {
            var v = b[i].toString(16);
            if (v.length === 1)
                v = "0" + v;
            hex += v;
        }
        if (negate) {
            this.negate();
            hex = "-" + hex;
        }
        return hex;
    };
    /**
     * Convert to a native javascript number.
     *
     * WARNING: do not expect this number to be accurate to integer precision for large (positive or negative) numbers!
     *
     * @param {boolean} allowImprecise If `true`, no check is performed to verify the returned value is accurate;
     * otherwise out-of-range values are clamped to +/-Infinity.
     * @returns {number} A numeric representation of this integer.
     */
    Int64.prototype.toNumber = function (allowImprecise) {
        var b = this.buffer;
        var negate = b[7] & 0x80;
        var x = 0;
        var carry = 1;
        var i = 0;
        var m = 1;
        while (i < 8) {
            var v = b[i];
            if (negate) {
                v = (v ^ 0xff) + carry;
                carry = v >> 8;
                v = v & 0xff;
            }
            x += v * m;
            m *= 256;
            i++;
        }
        if (!allowImprecise && x >= constants_1.MAX_SAFE_INTEGER) {
            trace("Coercing out of range value %d to Infinity.", x);
            return negate ? -Infinity : Infinity;
        }
        return negate ? -x : x;
    };
    return Int64;
}(uint64_1.Uint64));
exports.Int64 = Int64;

//# sourceMappingURL=int64.js.map


/***/ }),

/***/ "./node_modules/capnp-ts/lib/types/uint64.js":
/*!***************************************************!*\
  !*** ./node_modules/capnp-ts/lib/types/uint64.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @author jdiaz5513
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
var debug_1 = __webpack_require__(/*! debug */ "./node_modules/capnp-ts/node_modules/debug/src/browser.js");
var constants_1 = __webpack_require__(/*! ../constants */ "./node_modules/capnp-ts/lib/constants.js");
var errors_1 = __webpack_require__(/*! ../errors */ "./node_modules/capnp-ts/lib/errors.js");
var util_1 = __webpack_require__(/*! ../util */ "./node_modules/capnp-ts/lib/util.js");
var trace = debug_1.default("capnp:uint64");
trace("load");
/**
 * Represents an unsigned 64-bit integer stored using a Uint8Array in little-endian format. It's a little bit faster
 * than int64 because we don't need to keep track of the sign bit or perform two's compliment operations on set.
 *
 * You may convert this to a primitive number by calling `toNumber()` but be wary of precision loss!
 *
 * Note that overflow is not implemented, so negative numbers passed into `setValue()` will be negated first.
 *
 * The value passed in as the source buffer is expected to be in little-endian format.
 */
var Uint64 = /** @class */ (function () {
    /**
     * Creates a new instance; this is a no-frills constructor for speed. Use the factory methods if you need to convert
     * from other types or use a different offset into the buffer.
     *
     * Will throw if the buffer is not at least 8 bytes long.
     *
     * @constructor
     * @param {Uint8Array} buffer The buffer to use for this 64-bit word; the bytes must be in little-endian order.
     */
    function Uint64(buffer) {
        if (buffer.byteLength < 8)
            throw new RangeError(errors_1.RANGE_INT64_UNDERFLOW);
        this.buffer = buffer;
    }
    Uint64.fromArrayBuffer = function (source, offset, noCopy) {
        if (offset === void 0) { offset = 0; }
        if (noCopy === void 0) { noCopy = false; }
        if (noCopy)
            return new this(new Uint8Array(source, offset, 8));
        return new this(new Uint8Array(source.slice(offset, offset + 8)));
    };
    Uint64.fromDataView = function (source, offset, noCopy) {
        if (offset === void 0) { offset = 0; }
        if (noCopy === void 0) { noCopy = false; }
        if (noCopy) {
            return new this(new Uint8Array(source.buffer, source.byteOffset + offset, 8));
        }
        return new this(new Uint8Array(source.buffer.slice(source.byteOffset + offset, source.byteLength + offset + 8)));
    };
    /**
     * Parse a hexadecimal string in **big endian format** as a Uint64 value.
     *
     * @static
     * @param {string} source The source string.
     * @returns {Uint64} The string parsed as a 64-bit unsigned integer.
     */
    Uint64.fromHexString = function (source) {
        if (source.substr(0, 2) === "0x")
            source = source.substr(2);
        if (source.length < 1)
            return Uint64.fromNumber(0);
        if (source[0] === "-")
            throw new RangeError("Source must not be negative.");
        source = util_1.pad(source, 16);
        if (source.length !== 16) {
            throw new RangeError("Source string must contain at most 16 hexadecimal digits.");
        }
        var bytes = source.toLowerCase().replace(/[^\da-f]/g, "");
        var buf = new Uint8Array(new ArrayBuffer(8));
        for (var i = 0; i < 8; i++) {
            buf[7 - i] = parseInt(bytes.substr(i * 2, 2), 16);
        }
        return new Uint64(buf);
    };
    Uint64.fromNumber = function (source) {
        var ret = new this(new Uint8Array(8));
        ret.setValue(source);
        return ret;
    };
    Uint64.fromUint8Array = function (source, offset, noCopy) {
        if (offset === void 0) { offset = 0; }
        if (noCopy === void 0) { noCopy = false; }
        if (noCopy)
            return new this(source.subarray(offset, offset + 8));
        return new this(new Uint8Array(source.buffer.slice(source.byteOffset + offset, source.byteOffset + offset + 8)));
    };
    Uint64.prototype.equals = function (other) {
        for (var i = 0; i < 8; i++) {
            if (this.buffer[i] !== other.buffer[i])
                return false;
        }
        return true;
    };
    Uint64.prototype.inspect = function () {
        return "[Uint64 " + this.toString(10) + " 0x" + this.toHexString() + "]";
    };
    /**
     * Faster way to check for zero values without converting to a number first.
     *
     * @returns {boolean} `true` if the contained value is zero.
     * @memberOf Uint64
     */
    Uint64.prototype.isZero = function () {
        for (var i = 0; i < 8; i++) {
            if (this.buffer[i] !== 0)
                return false;
        }
        return true;
    };
    Uint64.prototype.setValue = function (loWord, hiWord) {
        var lo = loWord;
        var hi = hiWord;
        if (hi === undefined) {
            hi = lo;
            hi = Math.abs(hi);
            lo = hi % constants_1.VAL32;
            hi = hi / constants_1.VAL32;
            if (hi > constants_1.VAL32)
                throw new RangeError(loWord + " is outside Uint64 range");
            hi = hi >>> 0;
        }
        for (var i = 0; i < 8; i++) {
            this.buffer[i] = lo & 0xff;
            lo = i === 3 ? hi : lo >>> 8;
        }
    };
    /**
     * Convert to a native javascript number.
     *
     * WARNING: do not expect this number to be accurate to integer precision for large (positive or negative) numbers!
     *
     * @param {boolean} allowImprecise If `true`, no check is performed to verify the returned value is accurate;
     * otherwise out-of-range values are clamped to +Infinity.
     * @returns {number} A numeric representation of this integer.
     */
    Uint64.prototype.toNumber = function (allowImprecise) {
        var b = this.buffer;
        var x = 0;
        var i = 0;
        var m = 1;
        while (i < 8) {
            var v = b[i];
            x += v * m;
            m *= 256;
            i++;
        }
        if (!allowImprecise && x >= constants_1.MAX_SAFE_INTEGER) {
            trace("Coercing out of range value %d to Infinity.", x);
            return Infinity;
        }
        return x;
    };
    Uint64.prototype.valueOf = function () {
        return this.toNumber(false);
    };
    Uint64.prototype.toArrayBuffer = function () {
        return this.buffer.buffer;
    };
    Uint64.prototype.toDataView = function () {
        return new DataView(this.buffer.buffer);
    };
    Uint64.prototype.toHexString = function () {
        var hex = "";
        for (var i = 7; i >= 0; i--) {
            var v = this.buffer[i].toString(16);
            if (v.length === 1)
                v = "0" + v;
            hex += v;
        }
        return hex;
    };
    Uint64.prototype.toString = function (radix) {
        return this.toNumber(true).toString(radix);
    };
    Uint64.prototype.toUint8Array = function () {
        return this.buffer;
    };
    return Uint64;
}());
exports.Uint64 = Uint64;

//# sourceMappingURL=uint64.js.map


/***/ }),

/***/ "./node_modules/capnp-ts/lib/util.js":
/*!*******************************************!*\
  !*** ./node_modules/capnp-ts/lib/util.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * @author jdiaz5513
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
// LINT: a lot of the util functions need the any type.
/* tslint:disable:no-any no-unsafe-any */
var debug_1 = __webpack_require__(/*! debug */ "./node_modules/capnp-ts/node_modules/debug/src/browser.js");
var constants_1 = __webpack_require__(/*! ./constants */ "./node_modules/capnp-ts/lib/constants.js");
var errors_1 = __webpack_require__(/*! ./errors */ "./node_modules/capnp-ts/lib/errors.js");
var trace = debug_1.default("capnp:util");
trace("load");
/**
 * Dump a hex string from the given buffer.
 *
 * @export
 * @param {ArrayBuffer} buffer The buffer to convert.
 * @returns {string} A hexadecimal string representing the buffer.
 */
function bufferToHex(buffer) {
    var a = new Uint8Array(buffer);
    var h = [];
    for (var i = 0; i < a.byteLength; i++)
        h.push(pad(a[i].toString(16), 2));
    return "[" + h.join(" ") + "]";
}
exports.bufferToHex = bufferToHex;
/**
 * Throw an error if the provided value cannot be represented as a 32-bit integer.
 *
 * @export
 * @param {number} value The number to check.
 * @returns {number} The same number if it is valid.
 */
function checkInt32(value) {
    if (value > constants_1.MAX_INT32 || value < -constants_1.MAX_INT32) {
        throw new RangeError(errors_1.RANGE_INT32_OVERFLOW);
    }
    return value;
}
exports.checkInt32 = checkInt32;
function checkUint32(value) {
    if (value < 0 || value > constants_1.MAX_UINT32) {
        throw new RangeError(errors_1.RANGE_UINT32_OVERFLOW);
    }
    return value;
}
exports.checkUint32 = checkUint32;
/**
 * Decode a UTF-8 encoded byte array into a JavaScript string (UCS-2).
 *
 * @export
 * @param {Uint8Array} src A utf-8 encoded byte array.
 * @returns {string} A string representation of the byte array.
 */
function decodeUtf8(src) {
    // This ain't for the faint of heart, kids. If you suffer from seizures, heart palpitations, or have had a history of
    // stroke you may want to look away now.
    var l = src.byteLength;
    var dst = "";
    var i = 0;
    var cp = 0;
    var a = 0;
    var b = 0;
    var c = 0;
    var d = 0;
    while (i < l) {
        a = src[i++];
        if ((a & 128) === 0) {
            cp = a;
        }
        else if ((a & 224) === 192) {
            if (i >= l)
                throw new RangeError(errors_1.RANGE_INVALID_UTF8);
            b = src[i++];
            cp = ((a & 31) << 6) | (b & 63);
        }
        else if ((a & 240) === 224) {
            if (i + 1 >= l)
                throw new RangeError(errors_1.RANGE_INVALID_UTF8);
            b = src[i++];
            c = src[i++];
            cp =
                ((a & 15) << 12) | ((b & 63) << 6) | (c & 63);
        }
        else if ((a & 248) === 240) {
            if (i + 2 >= l)
                throw new RangeError(errors_1.RANGE_INVALID_UTF8);
            b = src[i++];
            c = src[i++];
            d = src[i++];
            cp =
                ((a & 7) << 18) |
                    ((b & 63) << 12) |
                    ((c & 63) << 6) |
                    (d & 63);
        }
        else {
            throw new RangeError(errors_1.RANGE_INVALID_UTF8);
        }
        if (cp <= 0xd7ff || (cp >= 0xe000 && cp <= 0xffff)) {
            dst += String.fromCharCode(cp);
        }
        else {
            // We must reach into the astral plane and construct the surrogate pair!
            cp -= 0x00010000;
            var hi = (cp >>> 10) + 0xd800;
            var lo = (cp & 0x03ff) + 0xdc00;
            if (hi < 0xd800 || hi > 0xdbff)
                throw new RangeError(errors_1.RANGE_INVALID_UTF8);
            dst += String.fromCharCode(hi, lo);
        }
    }
    return dst;
}
exports.decodeUtf8 = decodeUtf8;
function dumpBuffer(buffer) {
    var b = buffer instanceof ArrayBuffer
        ? new Uint8Array(buffer)
        : new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    var byteLength = Math.min(b.byteLength, constants_1.MAX_BUFFER_DUMP_BYTES);
    var r = format("\n=== buffer[%d] ===", byteLength);
    for (var j = 0; j < byteLength; j += 16) {
        r += "\n" + pad(j.toString(16), 8) + ": ";
        var s = "";
        var k = void 0;
        for (k = 0; k < 16 && j + k < b.byteLength; k++) {
            var v = b[j + k];
            r += pad(v.toString(16), 2) + " ";
            // Printable ASCII range.
            s += v > 31 && v < 255 ? String.fromCharCode(v) : "·";
            if (k === 7)
                r += " ";
        }
        r += "" + repeat((17 - k) * 3, " ") + s;
    }
    r += "\n";
    if (byteLength !== b.byteLength) {
        r += format("=== (truncated %d bytes) ===\n", b.byteLength - byteLength);
    }
    return r;
}
exports.dumpBuffer = dumpBuffer;
/**
 * Encode a JavaScript string (UCS-2) to a UTF-8 encoded string inside a Uint8Array.
 *
 * Note that the underlying buffer for the array will likely be larger than the actual contents; ignore the extra bytes.
 *
 * @export
 * @param {string} src The input string.
 * @returns {Uint8Array} A UTF-8 encoded buffer with the string's contents.
 */
function encodeUtf8(src) {
    var l = src.length;
    var dst = new Uint8Array(new ArrayBuffer(l * 4));
    var j = 0;
    for (var i = 0; i < l; i++) {
        var c = src.charCodeAt(i);
        if (c <= 0x7f) {
            dst[j++] = c;
        }
        else if (c <= 0x07ff) {
            dst[j++] = 192 | (c >>> 6);
            dst[j++] = 128 | ((c >>> 0) & 63);
        }
        else if (c <= 0xd7ff || c >= 0xe000) {
            dst[j++] = 224 | (c >>> 12);
            dst[j++] = 128 | ((c >>> 6) & 63);
            dst[j++] = 128 | ((c >>> 0) & 63);
        }
        else {
            // Make sure the surrogate pair is complete.
            /* istanbul ignore next */
            if (i + 1 >= l)
                throw new RangeError(errors_1.RANGE_INVALID_UTF8);
            // I cast thee back into the astral plane.
            var hi = c - 0xd800;
            var lo = src.charCodeAt(++i) - 0xdc00;
            var cp = ((hi << 10) | lo) + 0x00010000;
            dst[j++] = 240 | (cp >>> 18);
            dst[j++] = 128 | ((cp >>> 12) & 63);
            dst[j++] = 128 | ((cp >>> 6) & 63);
            dst[j++] = 128 | ((cp >>> 0) & 63);
        }
    }
    return dst.subarray(0, j);
}
exports.encodeUtf8 = encodeUtf8;
/**
 * Produce a `printf`-style string. Nice for providing arguments to `assert` without paying the cost for string
 * concatenation up front. Precision is supported for floating point numbers.
 *
 * @param {string} s The format string. Supported format specifiers: b, c, d, f, j, o, s, x, and X.
 * @param {...any} args Values to be formatted in the string. Arguments beyond what are consumed by the format string
 * are ignored.
 * @returns {string} The formatted string.
 */
function format(s) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    var n = s.length;
    var arg;
    var argIndex = 0;
    var c;
    var escaped = false;
    var i = 0;
    var leadingZero = false;
    var precision;
    var result = "";
    function nextArg() {
        return args[argIndex++];
    }
    function slurpNumber() {
        var digits = "";
        while (/\d/.test(s[i])) {
            digits += s[i++];
            c = s[i];
        }
        return digits.length > 0 ? parseInt(digits, 10) : null;
    }
    for (; i < n; ++i) {
        c = s[i];
        if (escaped) {
            escaped = false;
            if (c === ".") {
                leadingZero = false;
                c = s[++i];
            }
            else if (c === "0" && s[i + 1] === ".") {
                leadingZero = true;
                i += 2;
                c = s[i];
            }
            else {
                leadingZero = true;
            }
            precision = slurpNumber();
            switch (c) {
                case "a": // number in hex with padding
                    result += "0x" + pad(parseInt(nextArg(), 10).toString(16), 8);
                    break;
                case "b": // number in binary
                    result += parseInt(nextArg(), 10).toString(2);
                    break;
                case "c": // character
                    arg = nextArg();
                    if (typeof arg === "string" || arg instanceof String) {
                        result += arg;
                    }
                    else {
                        result += String.fromCharCode(parseInt(arg, 10));
                    }
                    break;
                case "d": // number in decimal
                    result += parseInt(nextArg(), 10);
                    break;
                case "f": // floating point number
                    var tmp = String(parseFloat(nextArg()).toFixed(precision || 6));
                    result += leadingZero ? tmp : tmp.replace(/^0/, "");
                    break;
                case "j": // JSON
                    result += JSON.stringify(nextArg());
                    break;
                case "o": // number in octal
                    result += "0" + parseInt(nextArg(), 10).toString(8);
                    break;
                case "s": // string
                    result += nextArg();
                    break;
                case "x": // lowercase hexadecimal
                    result += "0x" + parseInt(nextArg(), 10).toString(16);
                    break;
                case "X": // uppercase hexadecimal
                    result +=
                        "0x" +
                            parseInt(nextArg(), 10)
                                .toString(16)
                                .toUpperCase();
                    break;
                default:
                    result += c;
                    break;
            }
        }
        else if (c === "%") {
            escaped = true;
        }
        else {
            result += c;
        }
    }
    return result;
}
exports.format = format;
/**
 * Return the thing that was passed in. Yaaaaawn.
 *
 * @export
 * @template T
 * @param {T} x A thing.
 * @returns {T} The same thing.
 */
function identity(x) {
    return x;
}
exports.identity = identity;
function pad(v, width, pad) {
    if (pad === void 0) { pad = "0"; }
    return v.length >= width ? v : new Array(width - v.length + 1).join(pad) + v;
}
exports.pad = pad;
/**
 * Add padding to a number to make it divisible by 8. Typically used to pad byte sizes so they align to a word boundary.
 *
 * @export
 * @param {number} size The number to pad.
 * @returns {number} The padded number.
 */
function padToWord(size) {
    return (size + 7) & ~7;
}
exports.padToWord = padToWord;
/**
 * Repeat a string n times. Shamelessly copied from lodash.repeat.
 *
 * @param {number} times Number of times to repeat.
 * @param {string} str The string to repeat.
 * @returns {string} The repeated string.
 */
function repeat(times, str) {
    var out = "";
    var n = times;
    var s = str;
    if (n < 1 || n > Number.MAX_VALUE)
        return out;
    // https://en.wikipedia.org/wiki/Exponentiation_by_squaring
    do {
        if (n % 2)
            out += s;
        n = Math.floor(n / 2);
        if (n)
            s += s;
    } while (n);
    return out;
}
exports.repeat = repeat;
// Set up custom debug formatters.
/* tslint:disable:no-string-literal */
/* istanbul ignore next */
debug_1.default.formatters["h"] = function (v) { return v.toString("hex"); };
/* istanbul ignore next */
debug_1.default.formatters["x"] = function (v) { return "0x" + v.toString(16); };
/* istanbul ignore next */
debug_1.default.formatters["a"] = function (v) { return "0x" + pad(v.toString(16), 8); };
/* istanbul ignore next */
debug_1.default.formatters["X"] = function (v) { return "0x" + v.toString(16).toUpperCase(); };
/* tslint:enable:no-string-literal */

//# sourceMappingURL=util.js.map


/***/ }),

/***/ "./node_modules/capnp-ts/node_modules/debug/src/browser.js":
/*!*****************************************************************!*\
  !*** ./node_modules/capnp-ts/node_modules/debug/src/browser.js ***!
  \*****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "./node_modules/process/browser.js");
/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(/*! ./debug */ "./node_modules/capnp-ts/node_modules/debug/src/debug.js");
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}


/***/ }),

/***/ "./node_modules/capnp-ts/node_modules/debug/src/debug.js":
/*!***************************************************************!*\
  !*** ./node_modules/capnp-ts/node_modules/debug/src/debug.js ***!
  \***************************************************************/
/***/ ((module, exports, __webpack_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = __webpack_require__(/*! ms */ "./node_modules/capnp-ts/node_modules/ms/index.js");

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  return debug;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}


/***/ }),

/***/ "./node_modules/capnp-ts/node_modules/ms/index.js":
/*!********************************************************!*\
  !*** ./node_modules/capnp-ts/node_modules/ms/index.js ***!
  \********************************************************/
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}


/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/***/ ((module) => {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/tslib/tslib.es6.js":
/*!*****************************************!*\
  !*** ./node_modules/tslib/tslib.es6.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "__extends": () => (/* binding */ __extends),
/* harmony export */   "__assign": () => (/* binding */ __assign),
/* harmony export */   "__rest": () => (/* binding */ __rest),
/* harmony export */   "__decorate": () => (/* binding */ __decorate),
/* harmony export */   "__param": () => (/* binding */ __param),
/* harmony export */   "__metadata": () => (/* binding */ __metadata),
/* harmony export */   "__awaiter": () => (/* binding */ __awaiter),
/* harmony export */   "__generator": () => (/* binding */ __generator),
/* harmony export */   "__createBinding": () => (/* binding */ __createBinding),
/* harmony export */   "__exportStar": () => (/* binding */ __exportStar),
/* harmony export */   "__values": () => (/* binding */ __values),
/* harmony export */   "__read": () => (/* binding */ __read),
/* harmony export */   "__spread": () => (/* binding */ __spread),
/* harmony export */   "__spreadArrays": () => (/* binding */ __spreadArrays),
/* harmony export */   "__await": () => (/* binding */ __await),
/* harmony export */   "__asyncGenerator": () => (/* binding */ __asyncGenerator),
/* harmony export */   "__asyncDelegator": () => (/* binding */ __asyncDelegator),
/* harmony export */   "__asyncValues": () => (/* binding */ __asyncValues),
/* harmony export */   "__makeTemplateObject": () => (/* binding */ __makeTemplateObject),
/* harmony export */   "__importStar": () => (/* binding */ __importStar),
/* harmony export */   "__importDefault": () => (/* binding */ __importDefault),
/* harmony export */   "__classPrivateFieldGet": () => (/* binding */ __classPrivateFieldGet),
/* harmony export */   "__classPrivateFieldSet": () => (/* binding */ __classPrivateFieldSet)
/* harmony export */ });
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __createBinding(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}

function __exportStar(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result.default = mod;
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
}

function __classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
}


/***/ }),

/***/ "./node_modules/axios/package.json":
/*!*****************************************!*\
  !*** ./node_modules/axios/package.json ***!
  \*****************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"axios","version":"0.21.4","description":"Promise based HTTP client for the browser and node.js","main":"index.js","scripts":{"test":"grunt test","start":"node ./sandbox/server.js","build":"NODE_ENV=production grunt build","preversion":"npm test","version":"npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json","postversion":"git push && git push --tags","examples":"node ./examples/server.js","coveralls":"cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js","fix":"eslint --fix lib/**/*.js"},"repository":{"type":"git","url":"https://github.com/axios/axios.git"},"keywords":["xhr","http","ajax","promise","node"],"author":"Matt Zabriskie","license":"MIT","bugs":{"url":"https://github.com/axios/axios/issues"},"homepage":"https://axios-http.com","devDependencies":{"coveralls":"^3.0.0","es6-promise":"^4.2.4","grunt":"^1.3.0","grunt-banner":"^0.6.0","grunt-cli":"^1.2.0","grunt-contrib-clean":"^1.1.0","grunt-contrib-watch":"^1.0.0","grunt-eslint":"^23.0.0","grunt-karma":"^4.0.0","grunt-mocha-test":"^0.13.3","grunt-ts":"^6.0.0-beta.19","grunt-webpack":"^4.0.2","istanbul-instrumenter-loader":"^1.0.0","jasmine-core":"^2.4.1","karma":"^6.3.2","karma-chrome-launcher":"^3.1.0","karma-firefox-launcher":"^2.1.0","karma-jasmine":"^1.1.1","karma-jasmine-ajax":"^0.1.13","karma-safari-launcher":"^1.0.0","karma-sauce-launcher":"^4.3.6","karma-sinon":"^1.0.5","karma-sourcemap-loader":"^0.3.8","karma-webpack":"^4.0.2","load-grunt-tasks":"^3.5.2","minimist":"^1.2.0","mocha":"^8.2.1","sinon":"^4.5.0","terser-webpack-plugin":"^4.2.3","typescript":"^4.0.5","url-search-params":"^0.10.0","webpack":"^4.44.2","webpack-dev-server":"^3.11.0"},"browser":{"./lib/adapters/http.js":"./lib/adapters/xhr.js"},"jsdelivr":"dist/axios.min.js","unpkg":"dist/axios.min.js","typings":"./index.d.ts","dependencies":{"follow-redirects":"^1.14.0"},"bundlesize":[{"path":"./dist/axios.min.js","threshold":"5kB"}]}');

/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_tiledb-inc_tiledb-cloud_lib_index_js.f38a23c8a24b44a25994.js.map